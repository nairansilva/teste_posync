{"ast":null,"code":"/**\n * LokiJS\n * @author Joe Minichino <joe.minichino@gmail.com>\n *\n * A lightweight document oriented javascript database\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // Browser globals\n    root.loki = factory();\n  }\n})(this, function () {\n  return function () {\n    'use strict';\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    function deepFreeze(obj) {\n      var prop, i;\n\n      if (Array.isArray(obj)) {\n        for (i = 0; i < obj.length; i++) {\n          deepFreeze(obj[i]);\n        }\n\n        freeze(obj);\n      } else if (obj !== null && typeof obj === 'object') {\n        for (prop in obj) {\n          if (obj.hasOwnProperty(prop)) {\n            deepFreeze(obj[prop]);\n          }\n        }\n\n        freeze(obj);\n      }\n    }\n\n    function freeze(obj) {\n      if (!Object.isFrozen(obj)) {\n        Object.freeze(obj);\n      }\n    }\n\n    function unFreeze(obj) {\n      if (!Object.isFrozen(obj)) {\n        return obj;\n      }\n\n      return clone(obj, 'shallow');\n    }\n\n    var Utils = {\n      copyProperties: function copyProperties(src, dest) {\n        var prop;\n\n        for (prop in src) {\n          dest[prop] = src[prop];\n        }\n      },\n      // used to recursively scan hierarchical transform step object for param substitution\n      resolveTransformObject: function resolveTransformObject(subObj, params, depth) {\n        var prop, pname;\n\n        if (typeof depth !== 'number') {\n          depth = 0;\n        }\n\n        if (++depth >= 10) return subObj;\n\n        for (prop in subObj) {\n          if (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n            pname = subObj[prop].substring(8);\n\n            if (params.hasOwnProperty(pname)) {\n              subObj[prop] = params[pname];\n            }\n          } else if (typeof subObj[prop] === \"object\") {\n            subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n          }\n        }\n\n        return subObj;\n      },\n      // top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n      resolveTransformParams: function resolveTransformParams(transform, params) {\n        var idx,\n            clonedStep,\n            resolvedTransform = [];\n        if (typeof params === 'undefined') return transform; // iterate all steps in the transform array\n\n        for (idx = 0; idx < transform.length; idx++) {\n          // clone transform so our scan/replace can operate directly on cloned transform\n          clonedStep = clone(transform[idx], \"shallow-recurse-objects\");\n          resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n        }\n\n        return resolvedTransform;\n      },\n      // By default (if usingDotNotation is false), looks up path in\n      // object via `object[path]`\n      //\n      // If `usingDotNotation` is true, then the path is assumed to\n      // represent a nested path. It can be in the form of an array of\n      // field names, or a period delimited string. The function will\n      // look up the value of object[path[0]], and then call\n      // result[path[1]] on the result, etc etc.\n      //\n      // If `usingDotNotation` is true, this function still supports\n      // non nested fields.\n      //\n      // `usingDotNotation` is a performance optimization. The caller\n      // may know that a path is *not* nested. In which case, this\n      // function avoids a costly string.split('.')\n      //\n      // examples:\n      // getIn({a: 1}, \"a\") => 1\n      // getIn({a: 1}, \"a\", true) => 1\n      // getIn({a: {b: 1}}, [\"a\", \"b\"], true) => 1\n      // getIn({a: {b: 1}}, \"a.b\", true) => 1\n      getIn: function getIn(object, path, usingDotNotation) {\n        if (object == null) {\n          return undefined;\n        }\n\n        if (!usingDotNotation) {\n          return object[path];\n        }\n\n        if (typeof path === \"string\") {\n          path = path.split(\".\");\n        }\n\n        if (!Array.isArray(path)) {\n          throw new Error(\"path must be a string or array. Found \" + typeof path);\n        }\n\n        var index = 0,\n            length = path.length;\n\n        while (object != null && index < length) {\n          object = object[path[index++]];\n        }\n\n        return index && index == length ? object : undefined;\n      }\n    }; // wrapping in object to expose to default export for potential user override.\n    // warning: overriding these methods will override behavior for all loki db instances in memory.\n    // warning: if you use binary indices these comparators should be the same for all inserts/updates/removes.\n\n    var Comparators = {\n      aeq: aeqHelper,\n      lt: ltHelper,\n      gt: gtHelper\n    };\n    /** Helper function for determining 'loki' abstract equality which is a little more abstract than ==\n     *     aeqHelper(5, '5') === true\n     *     aeqHelper(5.0, '5') === true\n     *     aeqHelper(new Date(\"1/1/2011\"), new Date(\"1/1/2011\")) === true\n     *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)\n     *     aeqHelper([1, 2, 3], [1, 3]) === false\n     *     aeqHelper([1, 2, 3], [1, 2, 3]) === true\n     *     aeqHelper(undefined, null) === true\n     */\n\n    function aeqHelper(prop1, prop2) {\n      var cv1, cv2, t1, t2;\n      if (prop1 === prop2) return true; // 'falsy' and Boolean handling\n\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        // dates and NaN conditions (typed dates before serialization)\n        switch (prop1) {\n          case undefined:\n            t1 = 1;\n            break;\n\n          case null:\n            t1 = 1;\n            break;\n\n          case false:\n            t1 = 3;\n            break;\n\n          case true:\n            t1 = 4;\n            break;\n\n          case \"\":\n            t1 = 5;\n            break;\n\n          default:\n            t1 = prop1 === prop1 ? 9 : 0;\n            break;\n        }\n\n        switch (prop2) {\n          case undefined:\n            t2 = 1;\n            break;\n\n          case null:\n            t2 = 1;\n            break;\n\n          case false:\n            t2 = 3;\n            break;\n\n          case true:\n            t2 = 4;\n            break;\n\n          case \"\":\n            t2 = 5;\n            break;\n\n          default:\n            t2 = prop2 === prop2 ? 9 : 0;\n            break;\n        } // one or both is edge case\n\n\n        if (t1 !== 9 || t2 !== 9) {\n          return t1 === t2;\n        }\n      } // Handle 'Number-like' comparisons\n\n\n      cv1 = Number(prop1);\n      cv2 = Number(prop2); // if one or both are 'number-like'...\n\n      if (cv1 === cv1 || cv2 === cv2) {\n        return cv1 === cv2;\n      } // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\n\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n      return cv1 == cv2;\n    }\n    /** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n     *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n     *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n     *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n     */\n\n\n    function ltHelper(prop1, prop2, equal) {\n      var cv1, cv2, t1, t2; // if one of the params is falsy or strictly true or not equal to itself\n      // 0, 0.0, \"\", NaN, null, undefined, not defined, false, true\n\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        switch (prop1) {\n          case undefined:\n            t1 = 1;\n            break;\n\n          case null:\n            t1 = 1;\n            break;\n\n          case false:\n            t1 = 3;\n            break;\n\n          case true:\n            t1 = 4;\n            break;\n\n          case \"\":\n            t1 = 5;\n            break;\n          // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null\n\n          default:\n            t1 = prop1 === prop1 ? 9 : 0;\n            break;\n        }\n\n        switch (prop2) {\n          case undefined:\n            t2 = 1;\n            break;\n\n          case null:\n            t2 = 1;\n            break;\n\n          case false:\n            t2 = 3;\n            break;\n\n          case true:\n            t2 = 4;\n            break;\n\n          case \"\":\n            t2 = 5;\n            break;\n\n          default:\n            t2 = prop2 === prop2 ? 9 : 0;\n            break;\n        } // one or both is edge case\n\n\n        if (t1 !== 9 || t2 !== 9) {\n          return t1 === t2 ? equal : t1 < t2;\n        }\n      } // if both are numbers (string encoded or not), compare as numbers\n\n\n      cv1 = Number(prop1);\n      cv2 = Number(prop2);\n\n      if (cv1 === cv1 && cv2 === cv2) {\n        if (cv1 < cv2) return true;\n        if (cv1 > cv2) return false;\n        return equal;\n      }\n\n      if (cv1 === cv1 && cv2 !== cv2) {\n        return true;\n      }\n\n      if (cv2 === cv2 && cv1 !== cv1) {\n        return false;\n      }\n\n      if (prop1 < prop2) return true;\n      if (prop1 > prop2) return false;\n      if (prop1 == prop2) return equal; // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n\n      if (cv1 < cv2) {\n        return true;\n      }\n\n      if (cv1 == cv2) {\n        return equal;\n      }\n\n      return false;\n    }\n\n    function gtHelper(prop1, prop2, equal) {\n      var cv1, cv2, t1, t2; // 'falsy' and Boolean handling\n\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        switch (prop1) {\n          case undefined:\n            t1 = 1;\n            break;\n\n          case null:\n            t1 = 1;\n            break;\n\n          case false:\n            t1 = 3;\n            break;\n\n          case true:\n            t1 = 4;\n            break;\n\n          case \"\":\n            t1 = 5;\n            break;\n          // NaN 0\n\n          default:\n            t1 = prop1 === prop1 ? 9 : 0;\n            break;\n        }\n\n        switch (prop2) {\n          case undefined:\n            t2 = 1;\n            break;\n\n          case null:\n            t2 = 1;\n            break;\n\n          case false:\n            t2 = 3;\n            break;\n\n          case true:\n            t2 = 4;\n            break;\n\n          case \"\":\n            t2 = 5;\n            break;\n\n          default:\n            t2 = prop2 === prop2 ? 9 : 0;\n            break;\n        } // one or both is edge case\n\n\n        if (t1 !== 9 || t2 !== 9) {\n          return t1 === t2 ? equal : t1 > t2;\n        }\n      } // if both are numbers (string encoded or not), compare as numbers\n\n\n      cv1 = Number(prop1);\n      cv2 = Number(prop2);\n\n      if (cv1 === cv1 && cv2 === cv2) {\n        if (cv1 > cv2) return true;\n        if (cv1 < cv2) return false;\n        return equal;\n      }\n\n      if (cv1 === cv1 && cv2 !== cv2) {\n        return false;\n      }\n\n      if (cv2 === cv2 && cv1 !== cv1) {\n        return true;\n      }\n\n      if (prop1 > prop2) return true;\n      if (prop1 < prop2) return false;\n      if (prop1 == prop2) return equal; // not strict equal nor less than nor gt so must be dates or mixed types\n      // convert to string and use that to compare\n\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n\n      if (cv1 > cv2) {\n        return true;\n      }\n\n      if (cv1 == cv2) {\n        return equal;\n      }\n\n      return false;\n    }\n\n    function sortHelper(prop1, prop2, desc) {\n      if (Comparators.aeq(prop1, prop2)) return 0;\n\n      if (Comparators.lt(prop1, prop2, false)) {\n        return desc ? 1 : -1;\n      }\n\n      if (Comparators.gt(prop1, prop2, false)) {\n        return desc ? -1 : 1;\n      } // not lt, not gt so implied equality-- date compatible\n\n\n      return 0;\n    }\n    /**\n     * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n     *\n     * @param {array} properties - array of property names, in order, by which to evaluate sort order\n     * @param {object} obj1 - first object to compare\n     * @param {object} obj2 - second object to compare\n     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n     */\n\n\n    function compoundeval(properties, obj1, obj2) {\n      var res = 0;\n      var prop, field, val1, val2, arr, path;\n\n      for (var i = 0, len = properties.length; i < len; i++) {\n        prop = properties[i];\n        field = prop[0];\n\n        if (~field.indexOf('.')) {\n          arr = field.split('.');\n          val1 = Utils.getIn(obj1, arr, true);\n          val2 = Utils.getIn(obj2, arr, true);\n        } else {\n          val1 = obj1[field];\n          val2 = obj2[field];\n        }\n\n        res = sortHelper(val1, val2, prop[1]);\n\n        if (res !== 0) {\n          return res;\n        }\n      }\n\n      return 0;\n    }\n    /**\n     * dotSubScan - helper function used for dot notation queries.\n     *\n     * @param {object} root - object to traverse\n     * @param {array} paths - array of properties to drill into\n     * @param {function} fun - evaluation function to test with\n     * @param {any} value - comparative value to also pass to (compare) fun\n     * @param {any} extra - extra arg to also pass to compare fun\n     * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n     */\n\n\n    function dotSubScan(root, paths, fun, value, extra, poffset) {\n      var pathOffset = poffset || 0;\n      var path = paths[pathOffset];\n      var valueFound = false;\n      var element;\n\n      if (typeof root === 'object' && path in root) {\n        element = root[path];\n      }\n\n      if (pathOffset + 1 >= paths.length) {\n        // if we have already expanded out the dot notation,\n        // then just evaluate the test function and value on the element\n        valueFound = fun(element, value, extra);\n      } else if (Array.isArray(element)) {\n        for (var index = 0, len = element.length; index < len; index += 1) {\n          valueFound = dotSubScan(element[index], paths, fun, value, extra, pathOffset + 1);\n\n          if (valueFound === true) {\n            break;\n          }\n        }\n      } else {\n        valueFound = dotSubScan(element, paths, fun, value, extra, pathOffset + 1);\n      }\n\n      return valueFound;\n    }\n\n    function containsCheckFn(a) {\n      if (typeof a === 'string' || Array.isArray(a)) {\n        return function (b) {\n          return a.indexOf(b) !== -1;\n        };\n      } else if (typeof a === 'object' && a !== null) {\n        return function (b) {\n          return hasOwnProperty.call(a, b);\n        };\n      }\n\n      return null;\n    }\n\n    function doQueryOp(val, op, record) {\n      for (var p in op) {\n        if (hasOwnProperty.call(op, p)) {\n          return LokiOps[p](val, op[p], record);\n        }\n      }\n\n      return false;\n    }\n\n    var LokiOps = {\n      // comparison operators\n      // a is the value in the collection\n      // b is the query value\n      $eq: function $eq(a, b) {\n        return a === b;\n      },\n      // abstract/loose equality\n      $aeq: function $aeq(a, b) {\n        return a == b;\n      },\n      $ne: function $ne(a, b) {\n        // ecma 5 safe test for NaN\n        if (b !== b) {\n          // ecma 5 test value is not NaN\n          return a === a;\n        }\n\n        return a !== b;\n      },\n      // date equality / loki abstract equality test\n      $dteq: function $dteq(a, b) {\n        return Comparators.aeq(a, b);\n      },\n      // loki comparisons: return identical unindexed results as indexed comparisons\n      $gt: function $gt(a, b) {\n        return Comparators.gt(a, b, false);\n      },\n      $gte: function $gte(a, b) {\n        return Comparators.gt(a, b, true);\n      },\n      $lt: function $lt(a, b) {\n        return Comparators.lt(a, b, false);\n      },\n      $lte: function $lte(a, b) {\n        return Comparators.lt(a, b, true);\n      },\n      // lightweight javascript comparisons\n      $jgt: function $jgt(a, b) {\n        return a > b;\n      },\n      $jgte: function $jgte(a, b) {\n        return a >= b;\n      },\n      $jlt: function $jlt(a, b) {\n        return a < b;\n      },\n      $jlte: function $jlte(a, b) {\n        return a <= b;\n      },\n      // ex : coll.find({'orderCount': {$between: [10, 50]}});\n      $between: function $between(a, vals) {\n        if (a === undefined || a === null) return false;\n        return Comparators.gt(a, vals[0], true) && Comparators.lt(a, vals[1], true);\n      },\n      $jbetween: function $jbetween(a, vals) {\n        if (a === undefined || a === null) return false;\n        return a >= vals[0] && a <= vals[1];\n      },\n      $in: function $in(a, b) {\n        return b.indexOf(a) !== -1;\n      },\n      $inSet: function $inSet(a, b) {\n        return b.has(a);\n      },\n      $nin: function $nin(a, b) {\n        return b.indexOf(a) === -1;\n      },\n      $keyin: function $keyin(a, b) {\n        return a in b;\n      },\n      $nkeyin: function $nkeyin(a, b) {\n        return !(a in b);\n      },\n      $definedin: function $definedin(a, b) {\n        return b[a] !== undefined;\n      },\n      $undefinedin: function $undefinedin(a, b) {\n        return b[a] === undefined;\n      },\n      $regex: function $regex(a, b) {\n        return b.test(a);\n      },\n      $containsString: function $containsString(a, b) {\n        return typeof a === 'string' && a.indexOf(b) !== -1;\n      },\n      $containsNone: function $containsNone(a, b) {\n        return !LokiOps.$containsAny(a, b);\n      },\n      $containsAny: function $containsAny(a, b) {\n        var checkFn = containsCheckFn(a);\n\n        if (checkFn !== null) {\n          return Array.isArray(b) ? b.some(checkFn) : checkFn(b);\n        }\n\n        return false;\n      },\n      $contains: function $contains(a, b) {\n        var checkFn = containsCheckFn(a);\n\n        if (checkFn !== null) {\n          return Array.isArray(b) ? b.every(checkFn) : checkFn(b);\n        }\n\n        return false;\n      },\n      $elemMatch: function $elemMatch(a, b) {\n        if (Array.isArray(a)) {\n          return a.some(function (item) {\n            return Object.keys(b).every(function (property) {\n              var filter = b[property];\n\n              if (!(typeof filter === 'object' && filter)) {\n                filter = {\n                  $eq: filter\n                };\n              }\n\n              if (property.indexOf('.') !== -1) {\n                return dotSubScan(item, property.split('.'), doQueryOp, b[property], item);\n              }\n\n              return doQueryOp(item[property], filter, item);\n            });\n          });\n        }\n\n        return false;\n      },\n      $type: function $type(a, b, record) {\n        var type = typeof a;\n\n        if (type === 'object') {\n          if (Array.isArray(a)) {\n            type = 'array';\n          } else if (a instanceof Date) {\n            type = 'date';\n          }\n        }\n\n        return typeof b !== 'object' ? type === b : doQueryOp(type, b, record);\n      },\n      $finite: function $finite(a, b) {\n        return b === isFinite(a);\n      },\n      $size: function $size(a, b, record) {\n        if (Array.isArray(a)) {\n          return typeof b !== 'object' ? a.length === b : doQueryOp(a.length, b, record);\n        }\n\n        return false;\n      },\n      $len: function $len(a, b, record) {\n        if (typeof a === 'string') {\n          return typeof b !== 'object' ? a.length === b : doQueryOp(a.length, b, record);\n        }\n\n        return false;\n      },\n      $where: function $where(a, b) {\n        return b(a) === true;\n      },\n      // field-level logical operators\n      // a is the value in the collection\n      // b is the nested query operation (for '$not')\n      //   or an array of nested query operations (for '$and' and '$or')\n      $not: function $not(a, b, record) {\n        return !doQueryOp(a, b, record);\n      },\n      $and: function $and(a, b, record) {\n        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n          if (!doQueryOp(a, b[idx], record)) {\n            return false;\n          }\n        }\n\n        return true;\n      },\n      $or: function $or(a, b, record) {\n        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n          if (doQueryOp(a, b[idx], record)) {\n            return true;\n          }\n        }\n\n        return false;\n      },\n      $exists: function $exists(a, b) {\n        if (b) {\n          return a !== undefined;\n        } else {\n          return a === undefined;\n        }\n      }\n    }; // ops that can be used with { $$op: 'column-name' } syntax\n\n    var valueLevelOps = ['$eq', '$aeq', '$ne', '$dteq', '$gt', '$gte', '$lt', '$lte', '$jgt', '$jgte', '$jlt', '$jlte', '$type'];\n    valueLevelOps.forEach(function (op) {\n      var fun = LokiOps[op];\n\n      LokiOps['$' + op] = function (a, spec, record) {\n        if (typeof spec === 'string') {\n          return fun(a, record[spec]);\n        } else if (typeof spec === 'function') {\n          return fun(a, spec(record));\n        } else {\n          throw new Error('Invalid argument to $$ matcher');\n        }\n      };\n    }); // if an op is registered in this object, our 'calculateRange' can use it with our binary indices.\n    // if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.\n    // those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.\n\n    var indexedOps = {\n      $eq: LokiOps.$eq,\n      $aeq: true,\n      $dteq: true,\n      $gt: true,\n      $gte: true,\n      $lt: true,\n      $lte: true,\n      $in: true,\n      $between: true\n    };\n\n    function clone(data, method) {\n      if (data === null || data === undefined) {\n        return null;\n      }\n\n      var cloneMethod = method || 'parse-stringify',\n          cloned;\n\n      switch (cloneMethod) {\n        case \"parse-stringify\":\n          cloned = JSON.parse(JSON.stringify(data));\n          break;\n\n        case \"jquery-extend-deep\":\n          cloned = jQuery.extend(true, {}, data);\n          break;\n\n        case \"shallow\":\n          // more compatible method for older browsers\n          cloned = Object.create(data.constructor.prototype);\n          Object.keys(data).map(function (i) {\n            cloned[i] = data[i];\n          });\n          break;\n\n        case \"shallow-assign\":\n          // should be supported by newer environments/browsers\n          cloned = Object.create(data.constructor.prototype);\n          Object.assign(cloned, data);\n          break;\n\n        case \"shallow-recurse-objects\":\n          // shallow clone top level properties\n          cloned = clone(data, \"shallow\");\n          var keys = Object.keys(data); // for each of the top level properties which are object literals, recursively shallow copy\n\n          keys.forEach(function (key) {\n            if (typeof data[key] === \"object\" && data[key].constructor.name === \"Object\") {\n              cloned[key] = clone(data[key], \"shallow-recurse-objects\");\n            } else if (Array.isArray(data[key])) {\n              cloned[key] = cloneObjectArray(data[key], \"shallow-recurse-objects\");\n            }\n          });\n          break;\n\n        default:\n          break;\n      }\n\n      return cloned;\n    }\n\n    function cloneObjectArray(objarray, method) {\n      if (method == \"parse-stringify\") {\n        return clone(objarray, method);\n      }\n\n      var result = [];\n\n      for (var i = 0, len = objarray.length; i < len; i++) {\n        result[i] = clone(objarray[i], method);\n      }\n\n      return result;\n    }\n\n    function localStorageAvailable() {\n      try {\n        return window && window.localStorage !== undefined && window.localStorage !== null;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\n     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n     * constructor that inherits EventEmitter to emit events and trigger\n     * listeners that have been added to the event through the on(event, callback) method\n     *\n     * @constructor LokiEventEmitter\n     */\n\n\n    function LokiEventEmitter() {}\n    /**\n     * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n     * @memberof LokiEventEmitter\n     */\n\n\n    LokiEventEmitter.prototype.events = {};\n    /**\n     * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n     * should happen in an async fashion or not\n     * Default is false, which means events are synchronous\n     * @memberof LokiEventEmitter\n     */\n\n    LokiEventEmitter.prototype.asyncListeners = false;\n    /**\n     * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n     * @param {function} listener - callback function of listener to attach\n     * @returns {int} the index of the callback in the array of listeners for a particular event\n     * @memberof LokiEventEmitter\n     */\n\n    LokiEventEmitter.prototype.on = function (eventName, listener) {\n      var event;\n      var self = this;\n\n      if (Array.isArray(eventName)) {\n        eventName.forEach(function (currentEventName) {\n          self.on(currentEventName, listener);\n        });\n        return listener;\n      }\n\n      event = this.events[eventName];\n\n      if (!event) {\n        event = this.events[eventName] = [];\n      }\n\n      event.push(listener);\n      return listener;\n    };\n    /**\n     * emit(eventName, data) - emits a particular event\n     * with the option of passing optional parameters which are going to be processed by the callback\n     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n     * @param {string} eventName - the name of the event\n     * @param {object=} data - optional object passed with the event\n     * @memberof LokiEventEmitter\n     */\n\n\n    LokiEventEmitter.prototype.emit = function (eventName) {\n      var self = this;\n      var selfArgs;\n\n      if (eventName && this.events[eventName]) {\n        if (this.events[eventName].length) {\n          selfArgs = Array.prototype.slice.call(arguments, 1);\n          this.events[eventName].forEach(function (listener) {\n            if (self.asyncListeners) {\n              setTimeout(function () {\n                listener.apply(self, selfArgs);\n              }, 1);\n            } else {\n              listener.apply(self, selfArgs);\n            }\n          });\n        }\n      } else {\n        throw new Error('No event ' + eventName + ' defined');\n      }\n    };\n    /**\n     * Alias of LokiEventEmitter.prototype.on\n     * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n     * @param {function} listener - callback function of listener to attach\n     * @returns {int} the index of the callback in the array of listeners for a particular event\n     * @memberof LokiEventEmitter\n     */\n\n\n    LokiEventEmitter.prototype.addListener = LokiEventEmitter.prototype.on;\n    /**\n     * removeListener() - removes the listener at position 'index' from the event 'eventName'\n     * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n     * @param {function} listener - the listener callback function to remove from emitter\n     * @memberof LokiEventEmitter\n     */\n\n    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {\n      var self = this;\n\n      if (Array.isArray(eventName)) {\n        eventName.forEach(function (currentEventName) {\n          self.removeListener(currentEventName, listener);\n        });\n        return;\n      }\n\n      if (this.events[eventName]) {\n        var listeners = this.events[eventName];\n        listeners.splice(listeners.indexOf(listener), 1);\n      }\n    };\n    /**\n     * Loki: The main database class\n     * @constructor Loki\n     * @implements LokiEventEmitter\n     * @param {string} filename - name of the file to be saved to\n     * @param {object=} options - (Optional) config options object\n     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n     * @param {boolean} [options.verbose=false] - enable console output\n     * @param {boolean} [options.autosave=false] - enables autosave\n     * @param {int} [options.autosaveInterval=5000] - time interval (in milliseconds) between saves (if dirty)\n     * @param {boolean} [options.autoload=false] - enables autoload on loki instantiation\n     * @param {function} options.autoloadCallback - user callback called after database load\n     * @param {adapter} options.adapter - an instance of a loki persistence adapter\n     * @param {string} [options.serializationMethod='normal'] - ['normal', 'pretty', 'destructured']\n     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n     * @param {boolean} [options.throttledSaves=true] - debounces multiple calls to to saveDatabase reducing number of disk I/O operations\n                                                and guaranteeing proper serialization of the calls.\n     */\n\n\n    function Loki(filename, options) {\n      this.filename = filename || 'loki.db';\n      this.collections = []; // persist version of code which created the database to the database.\n      // could use for upgrade scenarios\n\n      this.databaseVersion = 1.5;\n      this.engineVersion = 1.5; // autosave support (disabled by default)\n      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\n      this.autosave = false;\n      this.autosaveInterval = 5000;\n      this.autosaveHandle = null;\n      this.throttledSaves = true;\n      this.options = {}; // currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n      // will not or cannot be deserialized.  You are required to configure persistence every time\n      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n      // this is optional option param, otherwise environment detection will be used\n      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\n      this.persistenceMethod = null; // retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\n      this.persistenceAdapter = null; // flags used to throttle saves\n\n      this.throttledSavePending = false;\n      this.throttledCallbacks = []; // enable console output if verbose flag is set (disabled by default)\n\n      this.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n      this.events = {\n        'init': [],\n        'loaded': [],\n        'flushChanges': [],\n        'close': [],\n        'changes': [],\n        'warning': []\n      };\n\n      var getENV = function getENV() {\n        if (typeof global !== 'undefined' && (global.android || global.NSObject)) {\n          // If no adapter assume nativescript which needs adapter to be passed manually\n          return 'NATIVESCRIPT'; //nativescript\n        }\n\n        if (typeof window === 'undefined') {\n          return 'NODEJS';\n        }\n\n        if (typeof global !== 'undefined' && global.window && typeof process !== 'undefined') {\n          return 'NODEJS'; //node-webkit\n        }\n\n        if (typeof document !== 'undefined') {\n          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n            return 'CORDOVA';\n          }\n\n          return 'BROWSER';\n        }\n\n        return 'CORDOVA';\n      }; // refactored environment detection due to invalid detection for browser environments.\n      // if they do not specify an options.env we want to detect env rather than default to nodejs.\n      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n      //   might want to review whether we can consolidate.\n\n\n      if (options && options.hasOwnProperty('env')) {\n        this.ENV = options.env;\n      } else {\n        this.ENV = getENV();\n      } // not sure if this is necessary now that i have refactored the line above\n\n\n      if (this.ENV === 'undefined') {\n        this.ENV = 'NODEJS';\n      }\n\n      this.configureOptions(options, true);\n      this.on('init', this.clearChanges);\n    } // db class is an EventEmitter\n\n\n    Loki.prototype = new LokiEventEmitter();\n    Loki.prototype.constructor = Loki; // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n    // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n\n    Loki.prototype.getIndexedAdapter = function () {\n      var adapter;\n\n      if (typeof require === 'function') {\n        adapter = require(\"./loki-indexed-adapter.js\");\n      }\n\n      return adapter;\n    };\n    /**\n     * Allows reconfiguring database options\n     *\n     * @param {object} options - configuration options to apply to loki db object\n     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n     * @param {boolean} options.verbose - enable console output (default is 'false')\n     * @param {boolean} options.autosave - enables autosave\n     * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n     * @param {boolean} options.autoload - enables autoload on loki instantiation\n     * @param {function} options.autoloadCallback - user callback called after database load\n     * @param {adapter} options.adapter - an instance of a loki persistence adapter\n     * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n     * @param {boolean} initialConfig - (internal) true is passed when loki ctor is invoking\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.configureOptions = function (options, initialConfig) {\n      var defaultPersistence = {\n        'NODEJS': 'fs',\n        'BROWSER': 'localStorage',\n        'CORDOVA': 'localStorage',\n        'MEMORY': 'memory'\n      },\n          persistenceMethods = {\n        'fs': LokiFsAdapter,\n        'localStorage': LokiLocalStorageAdapter,\n        'memory': LokiMemoryAdapter\n      };\n      this.options = {};\n      this.persistenceMethod = null; // retain reference to optional persistence adapter 'instance'\n      // currently keeping outside options because it can't be serialized\n\n      this.persistenceAdapter = null; // process the options\n\n      if (typeof options !== 'undefined') {\n        this.options = options;\n\n        if (this.options.hasOwnProperty('persistenceMethod')) {\n          // check if the specified persistence method is known\n          if (typeof persistenceMethods[options.persistenceMethod] == 'function') {\n            this.persistenceMethod = options.persistenceMethod;\n            this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();\n          } // should be throw an error here, or just fall back to defaults ??\n\n        } // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\n\n        if (this.options.hasOwnProperty('adapter')) {\n          this.persistenceMethod = 'adapter';\n          this.persistenceAdapter = options.adapter;\n          this.options.adapter = null; // if true, will keep track of dirty ids\n\n          this.isIncremental = this.persistenceAdapter.mode === 'incremental';\n        } // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\n\n        if (options.autoload && initialConfig) {\n          // for autoload, let the constructor complete before firing callback\n          var self = this;\n          setTimeout(function () {\n            self.loadDatabase(options, options.autoloadCallback);\n          }, 1);\n        }\n\n        if (this.options.hasOwnProperty('autosaveInterval')) {\n          this.autosaveDisable();\n          this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n        }\n\n        if (this.options.hasOwnProperty('autosave') && this.options.autosave) {\n          this.autosaveDisable();\n          this.autosave = true;\n\n          if (this.options.hasOwnProperty('autosaveCallback')) {\n            this.autosaveEnable(options, options.autosaveCallback);\n          } else {\n            this.autosaveEnable();\n          }\n        }\n\n        if (this.options.hasOwnProperty('throttledSaves')) {\n          this.throttledSaves = this.options.throttledSaves;\n        }\n      } // end of options processing\n      // ensure defaults exists for options which were not set\n\n\n      if (!this.options.hasOwnProperty('serializationMethod')) {\n        this.options.serializationMethod = 'normal';\n      } // ensure passed or default option exists\n\n\n      if (!this.options.hasOwnProperty('destructureDelimiter')) {\n        this.options.destructureDelimiter = '$<\\n';\n      } // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\n\n      if (this.persistenceAdapter === null) {\n        this.persistenceMethod = defaultPersistence[this.ENV];\n\n        if (this.persistenceMethod) {\n          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n        }\n      }\n    };\n    /**\n     * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n     *\n     * @param {object} options - apply or override collection level settings\n     * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.copy = function (options) {\n      // in case running in an environment without accurate environment detection, pass 'NA'\n      var databaseCopy = new Loki(this.filename, {\n        env: \"NA\"\n      });\n      var clen, idx;\n      options = options || {}; // currently inverting and letting loadJSONObject do most of the work\n\n      databaseCopy.loadJSONObject(this, {\n        retainDirtyFlags: true\n      }); // since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n\n      if (options.hasOwnProperty(\"removeNonSerializable\") && options.removeNonSerializable === true) {\n        databaseCopy.autosaveHandle = null;\n        databaseCopy.persistenceAdapter = null;\n        clen = databaseCopy.collections.length;\n\n        for (idx = 0; idx < clen; idx++) {\n          databaseCopy.collections[idx].constraints = null;\n          databaseCopy.collections[idx].ttl = null;\n        }\n      }\n\n      return databaseCopy;\n    };\n    /**\n     * Adds a collection to the database.\n     * @param {string} name - name of collection to add\n     * @param {object=} options - (optional) options to configure collection with.\n     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for\n     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for\n     * @param {array=} [options.indices=[]] - array property names to define binary indexes for\n     * @param {boolean} [options.asyncListeners=false] - whether listeners are called asynchronously\n     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes Api\n     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically\n     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow, 'shallow-assign'\n     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.\n     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n     * @returns {Collection} a reference to the collection which was just added\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.addCollection = function (name, options) {\n      var i,\n          len = this.collections.length;\n\n      if (options && options.disableMeta === true) {\n        if (options.disableChangesApi === false) {\n          throw new Error(\"disableMeta option cannot be passed as true when disableChangesApi is passed as false\");\n        }\n\n        if (options.disableDeltaChangesApi === false) {\n          throw new Error(\"disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false\");\n        }\n\n        if (typeof options.ttl === \"number\" && options.ttl > 0) {\n          throw new Error(\"disableMeta option cannot be passed as true when ttl is enabled\");\n        }\n      }\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === name) {\n          return this.collections[i];\n        }\n      }\n\n      var collection = new Collection(name, options);\n      collection.isIncremental = this.isIncremental;\n      this.collections.push(collection);\n      if (this.verbose) collection.lokiConsoleWrapper = console;\n      return collection;\n    };\n\n    Loki.prototype.loadCollection = function (collection) {\n      if (!collection.name) {\n        throw new Error('Collection must have a name property to be loaded');\n      }\n\n      this.collections.push(collection);\n    };\n    /**\n     * Retrieves reference to a collection by name.\n     * @param {string} collectionName - name of collection to look up\n     * @returns {Collection} Reference to collection in database by that name, or null if not found\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.getCollection = function (collectionName) {\n      var i,\n          len = this.collections.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === collectionName) {\n          return this.collections[i];\n        }\n      } // no such collection\n\n\n      this.emit('warning', 'collection ' + collectionName + ' not found');\n      return null;\n    };\n    /**\n     * Renames an existing loki collection\n     * @param {string} oldName - name of collection to rename\n     * @param {string} newName - new name of collection\n     * @returns {Collection} reference to the newly renamed collection\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.renameCollection = function (oldName, newName) {\n      var c = this.getCollection(oldName);\n\n      if (c) {\n        c.name = newName;\n      }\n\n      return c;\n    };\n    /**\n     * Returns a list of collections in the database.\n     * @returns {object[]} array of objects containing 'name', 'type', and 'count' properties.\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.listCollections = function () {\n      var i = this.collections.length,\n          colls = [];\n\n      while (i--) {\n        colls.push({\n          name: this.collections[i].name,\n          type: this.collections[i].objType,\n          count: this.collections[i].data.length\n        });\n      }\n\n      return colls;\n    };\n    /**\n     * Removes a collection from the database.\n     * @param {string} collectionName - name of collection to remove\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.removeCollection = function (collectionName) {\n      var i,\n          len = this.collections.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === collectionName) {\n          var tmpcol = new Collection(collectionName, {});\n          var curcol = this.collections[i];\n\n          for (var prop in curcol) {\n            if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n              curcol[prop] = tmpcol[prop];\n            }\n          }\n\n          this.collections.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    Loki.prototype.getName = function () {\n      return this.name;\n    };\n    /**\n     * serializeReplacer - used to prevent certain properties from being serialized\n     *\n     */\n\n\n    Loki.prototype.serializeReplacer = function (key, value) {\n      switch (key) {\n        case 'autosaveHandle':\n        case 'persistenceAdapter':\n        case 'constraints':\n        case 'ttl':\n          return null;\n\n        case 'throttledSavePending':\n        case 'throttledCallbacks':\n          return undefined;\n\n        case 'lokiConsoleWrapper':\n          return null;\n\n        default:\n          return value;\n      }\n    };\n    /**\n     * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n     *\n     * @returns {string} Stringified representation of the loki database.\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.serialize = function (options) {\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"serializationMethod\")) {\n        options.serializationMethod = this.options.serializationMethod;\n      }\n\n      switch (options.serializationMethod) {\n        case \"normal\":\n          return JSON.stringify(this, this.serializeReplacer);\n\n        case \"pretty\":\n          return JSON.stringify(this, this.serializeReplacer, 2);\n\n        case \"destructured\":\n          return this.serializeDestructured();\n        // use default options\n\n        default:\n          return JSON.stringify(this, this.serializeReplacer);\n      }\n    }; // alias of serialize\n\n\n    Loki.prototype.toJson = Loki.prototype.serialize;\n    /**\n     * Database level destructured JSON serialization routine to allow alternate serialization methods.\n     * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n     * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n     * your own structured persistence or data exchange.\n     *\n     * @param {object=} options - output format options for use externally to loki\n     * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n     * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n     * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n     * @param {string=} options.delimiter - override default delimiter\n     *\n     * @returns {string|array} A custom, restructured aggregation of independent serializations.\n     * @memberof Loki\n     */\n\n    Loki.prototype.serializeDestructured = function (options) {\n      var idx, sidx, result, resultlen;\n      var reconstruct = [];\n      var dbcopy;\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"partitioned\")) {\n        options.partitioned = false;\n      }\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"delimiter\")) {\n        options.delimiter = this.options.destructureDelimiter;\n      } // 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n\n\n      if (options.partitioned === true && options.hasOwnProperty(\"partition\") && options.partition >= 0) {\n        return this.serializeCollection({\n          delimited: options.delimited,\n          delimiter: options.delimiter,\n          collectionIndex: options.partition\n        });\n      } // not just an individual collection, so we will need to serialize db container via shallow copy\n\n\n      dbcopy = new Loki(this.filename);\n      dbcopy.loadJSONObject(this);\n\n      for (idx = 0; idx < dbcopy.collections.length; idx++) {\n        dbcopy.collections[idx].data = [];\n      } // if we -only- wanted the db container portion, return it now\n\n\n      if (options.partitioned === true && options.partition === -1) {\n        // since we are deconstructing, override serializationMethod to normal for here\n        return dbcopy.serialize({\n          serializationMethod: \"normal\"\n        });\n      } // at this point we must be deconstructing the entire database\n      // start by pushing db serialization into first array element\n\n\n      reconstruct.push(dbcopy.serialize({\n        serializationMethod: \"normal\"\n      }));\n      dbcopy = null; // push collection data into subsequent elements\n\n      for (idx = 0; idx < this.collections.length; idx++) {\n        result = this.serializeCollection({\n          delimited: options.delimited,\n          delimiter: options.delimiter,\n          collectionIndex: idx\n        }); // NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n\n        if (options.partitioned === false && options.delimited === false) {\n          if (!Array.isArray(result)) {\n            throw new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n          } // Array.concat would probably duplicate memory overhead for copying strings.\n          // Instead copy each individually, and clear old value after each copy.\n          // Hopefully this will allow g.c. to reduce memory pressure, if needed.\n\n\n          resultlen = result.length;\n\n          for (sidx = 0; sidx < resultlen; sidx++) {\n            reconstruct.push(result[sidx]);\n            result[sidx] = null;\n          }\n\n          reconstruct.push(\"\");\n        } else {\n          reconstruct.push(result);\n        }\n      } // Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n\n\n      if (options.partitioned) {\n        // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n        // useful for simple future adaptations of existing persistence adapters to save collections separately\n        if (options.delimited) {\n          return reconstruct;\n        } // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n        // This format might be the most versatile for 'rolling your own' partitioned sync or save.\n        // Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n        else {\n            return reconstruct;\n          }\n      } else {\n        // D : one big Delimited string { partitioned: false, delimited : true }\n        // This is the method Loki will use internally if 'destructured'.\n        // Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n        if (options.delimited) {\n          // indicate no more collections\n          reconstruct.push(\"\");\n          return reconstruct.join(options.delimiter);\n        } // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n        // This format might be best candidate for custom synchronous syncs or saves\n        else {\n            // indicate no more collections\n            reconstruct.push(\"\");\n            return reconstruct;\n          }\n      }\n\n      reconstruct.push(\"\");\n      return reconstruct.join(delim);\n    };\n    /**\n     * Collection level utility method to serialize a collection in a 'destructured' format\n     *\n     * @param {object=} options - used to determine output of method\n     * @param {int} options.delimited - whether to return single delimited string or an array\n     * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n     * @param {int} options.collectionIndex -  specify which collection to serialize data for\n     *\n     * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.serializeCollection = function (options) {\n      var doccount,\n          docidx,\n          resultlines = [];\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"collectionIndex\")) {\n        throw new Error(\"serializeCollection called without 'collectionIndex' option\");\n      }\n\n      doccount = this.collections[options.collectionIndex].data.length;\n      resultlines = [];\n\n      for (docidx = 0; docidx < doccount; docidx++) {\n        resultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n      } // D and DA\n\n\n      if (options.delimited) {\n        // indicate no more documents in collection (via empty delimited string)\n        resultlines.push(\"\");\n        return resultlines.join(options.delimiter);\n      } else {\n        // NDAA and NDA\n        return resultlines;\n      }\n    };\n    /**\n     * Database level destructured JSON deserialization routine to minimize memory overhead.\n     * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n     * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n     * your own structured persistence or data exchange.\n     *\n     * @param {string|array} destructuredSource - destructured json or array to deserialize from\n     * @param {object=} options - source format options\n     * @param {bool=} [options.partitioned=false] - whether db and each collection are separate\n     * @param {int=} options.partition - can be used to deserialize only a single partition\n     * @param {bool=} [options.delimited=true] - whether subitems are delimited or subarrays\n     * @param {string=} options.delimiter - override default delimiter\n     *\n     * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.deserializeDestructured = function (destructuredSource, options) {\n      var workarray = [];\n      var len, cdb;\n      var idx,\n          collIndex = 0,\n          collCount,\n          lineIndex = 1,\n          done = false;\n      var currLine, currObject;\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"partitioned\")) {\n        options.partitioned = false;\n      }\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"delimiter\")) {\n        options.delimiter = this.options.destructureDelimiter;\n      } // Partitioned\n      // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n      // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n      // -or- single partition\n\n\n      if (options.partitioned) {\n        // handle single partition\n        if (options.hasOwnProperty('partition')) {\n          // db only\n          if (options.partition === -1) {\n            cdb = JSON.parse(destructuredSource[0]);\n            return cdb;\n          } // single collection, return doc array\n\n\n          return this.deserializeCollection(destructuredSource[options.partition + 1], options);\n        } // Otherwise we are restoring an entire partitioned db\n\n\n        cdb = JSON.parse(destructuredSource[0]);\n        collCount = cdb.collections.length;\n\n        for (collIndex = 0; collIndex < collCount; collIndex++) {\n          // attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n          cdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n        }\n\n        return cdb;\n      } // Non-Partitioned\n      // D : one big Delimited string { partitioned: false, delimited : true }\n      // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n      // D\n\n\n      if (options.delimited) {\n        workarray = destructuredSource.split(options.delimiter);\n        destructuredSource = null; // lower memory pressure\n\n        len = workarray.length;\n\n        if (len === 0) {\n          return null;\n        }\n      } // NDA\n      else {\n          workarray = destructuredSource;\n        } // first line is database and collection shells\n\n\n      cdb = JSON.parse(workarray[0]);\n      collCount = cdb.collections.length;\n      workarray[0] = null;\n\n      while (!done) {\n        currLine = workarray[lineIndex]; // empty string indicates either end of collection or end of file\n\n        if (workarray[lineIndex] === \"\") {\n          // if no more collections to load into, we are done\n          if (++collIndex > collCount) {\n            done = true;\n          }\n        } else {\n          currObject = JSON.parse(workarray[lineIndex]);\n          cdb.collections[collIndex].data.push(currObject);\n        } // lower memory pressure and advance iterator\n\n\n        workarray[lineIndex++] = null;\n      }\n\n      return cdb;\n    };\n    /**\n     * Collection level utility function to deserializes a destructured collection.\n     *\n     * @param {string|array} destructuredSource - destructured representation of collection to inflate\n     * @param {object=} options - used to describe format of destructuredSource input\n     * @param {int=} [options.delimited=false] - whether source is delimited string or an array\n     * @param {string=} options.delimiter - if delimited, this is delimiter to use (if other than default)\n     *\n     * @returns {array} an array of documents to attach to collection.data.\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.deserializeCollection = function (destructuredSource, options) {\n      var workarray = [];\n      var idx, len;\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"partitioned\")) {\n        options.partitioned = false;\n      }\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"delimiter\")) {\n        options.delimiter = this.options.destructureDelimiter;\n      }\n\n      if (options.delimited) {\n        workarray = destructuredSource.split(options.delimiter);\n        workarray.pop();\n      } else {\n        workarray = destructuredSource;\n      }\n\n      len = workarray.length;\n\n      for (idx = 0; idx < len; idx++) {\n        workarray[idx] = JSON.parse(workarray[idx]);\n      }\n\n      return workarray;\n    };\n    /**\n     * Inflates a loki database from a serialized JSON string\n     *\n     * @param {string} serializedDb - a serialized loki database string\n     * @param {object=} options - apply or override collection level settings\n     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.loadJSON = function (serializedDb, options) {\n      var dbObject;\n\n      if (serializedDb.length === 0) {\n        dbObject = {};\n      } else {\n        // using option defined in instantiated db not what was in serialized db\n        switch (this.options.serializationMethod) {\n          case \"normal\":\n          case \"pretty\":\n            dbObject = JSON.parse(serializedDb);\n            break;\n\n          case \"destructured\":\n            dbObject = this.deserializeDestructured(serializedDb);\n            break;\n\n          default:\n            dbObject = JSON.parse(serializedDb);\n            break;\n        }\n      }\n\n      this.loadJSONObject(dbObject, options);\n    };\n    /**\n     * Inflates a loki database from a JS object\n     *\n     * @param {object} dbObject - a serialized loki database string\n     * @param {object=} options - apply or override collection level settings\n     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.loadJSONObject = function (dbObject, options) {\n      var i = 0,\n          len = dbObject.collections ? dbObject.collections.length : 0,\n          coll,\n          copyColl,\n          clen,\n          j,\n          loader,\n          collObj;\n      this.name = dbObject.name; // restore save throttled boolean only if not defined in options\n\n      if (dbObject.hasOwnProperty('throttledSaves') && options && !options.hasOwnProperty('throttledSaves')) {\n        this.throttledSaves = dbObject.throttledSaves;\n      }\n\n      this.collections = [];\n\n      function makeLoader(coll) {\n        var collOptions = options[coll.name];\n        var inflater;\n\n        if (collOptions.proto) {\n          inflater = collOptions.inflate || Utils.copyProperties;\n          return function (data) {\n            var collObj = new collOptions.proto();\n            inflater(data, collObj);\n            return collObj;\n          };\n        }\n\n        return collOptions.inflate;\n      }\n\n      for (i; i < len; i += 1) {\n        coll = dbObject.collections[i];\n        copyColl = this.addCollection(coll.name, {\n          disableChangesApi: coll.disableChangesApi,\n          disableDeltaChangesApi: coll.disableDeltaChangesApi,\n          disableMeta: coll.disableMeta,\n          disableFreeze: coll.hasOwnProperty('disableFreeze') ? coll.disableFreeze : true\n        });\n        copyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? coll.adaptiveBinaryIndices === true : false;\n        copyColl.transactional = coll.transactional;\n        copyColl.asyncListeners = coll.asyncListeners;\n        copyColl.cloneObjects = coll.cloneObjects;\n        copyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n        copyColl.autoupdate = coll.autoupdate;\n        copyColl.changes = coll.changes;\n        copyColl.dirtyIds = coll.dirtyIds || [];\n\n        if (options && options.retainDirtyFlags === true) {\n          copyColl.dirty = coll.dirty;\n        } else {\n          copyColl.dirty = false;\n        } // load each element individually\n\n\n        clen = coll.data.length;\n        j = 0;\n\n        if (options && options.hasOwnProperty(coll.name)) {\n          loader = makeLoader(coll);\n\n          for (j; j < clen; j++) {\n            collObj = loader(coll.data[j]);\n            copyColl.data[j] = collObj;\n            copyColl.addAutoUpdateObserver(collObj);\n\n            if (!copyColl.disableFreeze) {\n              deepFreeze(copyColl.data[j]);\n            }\n          }\n        } else {\n          for (j; j < clen; j++) {\n            copyColl.data[j] = coll.data[j];\n            copyColl.addAutoUpdateObserver(copyColl.data[j]);\n\n            if (!copyColl.disableFreeze) {\n              deepFreeze(copyColl.data[j]);\n            }\n          }\n        }\n\n        copyColl.maxId = typeof coll.maxId === 'undefined' ? 0 : coll.maxId;\n\n        if (typeof coll.binaryIndices !== 'undefined') {\n          copyColl.binaryIndices = coll.binaryIndices;\n        }\n\n        if (typeof coll.transforms !== 'undefined') {\n          copyColl.transforms = coll.transforms;\n        } // regenerate unique indexes\n\n\n        copyColl.uniqueNames = [];\n\n        if (coll.hasOwnProperty(\"uniqueNames\")) {\n          copyColl.uniqueNames = coll.uniqueNames;\n        } // in case they are loading a database created before we added dynamic views, handle undefined\n\n\n        if (typeof coll.DynamicViews === 'undefined') continue; // reinflate DynamicViews and attached Resultsets\n\n        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n          var colldv = coll.DynamicViews[idx];\n          var dv = copyColl.addDynamicView(colldv.name, colldv.options);\n          dv.resultdata = colldv.resultdata;\n          dv.resultsdirty = colldv.resultsdirty;\n          dv.filterPipeline = colldv.filterPipeline;\n          dv.sortCriteriaSimple = colldv.sortCriteriaSimple;\n          dv.sortCriteria = colldv.sortCriteria;\n          dv.sortFunction = null;\n          dv.sortDirty = colldv.sortDirty;\n\n          if (!copyColl.disableFreeze) {\n            deepFreeze(dv.filterPipeline);\n\n            if (dv.sortCriteriaSimple) {\n              deepFreeze(dv.sortCriteriaSimple);\n            } else if (dv.sortCriteria) {\n              deepFreeze(dv.sortCriteria);\n            }\n          }\n\n          dv.resultset.filteredrows = colldv.resultset.filteredrows;\n          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n          dv.rematerialize({\n            removeWhereFilters: true\n          });\n        } // Upgrade Logic for binary index refactoring at version 1.5\n\n\n        if (dbObject.databaseVersion < 1.5) {\n          // rebuild all indices\n          copyColl.ensureAllIndexes(true);\n          copyColl.dirty = true;\n        }\n      }\n    };\n    /**\n     * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n     * Does not actually destroy the db.\n     *\n     * @param {function=} callback - (Optional) if supplied will be registered with close event before emitting.\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.close = function (callback) {\n      // for autosave scenarios, we will let close perform final save (if dirty)\n      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n      if (this.autosave) {\n        this.autosaveDisable();\n\n        if (this.autosaveDirty()) {\n          this.saveDatabase(callback);\n          callback = undefined;\n        }\n      }\n\n      if (callback) {\n        this.on('close', callback);\n      }\n\n      this.emit('close');\n    };\n    /**-------------------------+\n    | Changes API               |\n    +--------------------------*/\n\n    /**\n     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n     */\n\n    /**\n     * (Changes API) : takes all the changes stored in each\n     * collection and creates a single array for the entire database. If an array of names\n     * of collections is passed then only the included collections will be tracked.\n     *\n     * @param {array=} optional array of collection names. No arg means all collections are processed.\n     * @returns {array} array of changes\n     * @see private method createChange() in Collection\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {\n      function getCollName(coll) {\n        return coll.name;\n      }\n\n      var changes = [],\n          selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n      this.collections.forEach(function (coll) {\n        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n          changes = changes.concat(coll.getChanges());\n        }\n      });\n      return changes;\n    };\n    /**\n     * (Changes API) - stringify changes for network transmission\n     * @returns {string} string representation of the changes\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.serializeChanges = function (collectionNamesArray) {\n      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n    };\n    /**\n     * (Changes API) : clears all the changes in all collections.\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.clearChanges = function () {\n      this.collections.forEach(function (coll) {\n        if (coll.flushChanges) {\n          coll.flushChanges();\n        }\n      });\n    };\n    /*------------------+\n    | PERSISTENCE       |\n    -------------------*/\n\n    /** there are two build in persistence adapters for internal use\n     * fs             for use in Nodejs type environments\n     * localStorage   for use in browser environment\n     * defined as helper classes here so its easy and clean to use\n     */\n\n    /**\n     * In in-memory persistence adapter for an in-memory database.\n     * This simple 'key/value' adapter is intended for unit testing and diagnostics.\n     *\n     * @param {object=} options - memory adapter options\n     * @param {boolean} [options.asyncResponses=false] - whether callbacks are invoked asynchronously\n     * @param {int} [options.asyncTimeout=50] - timeout in ms to queue callbacks\n     * @constructor LokiMemoryAdapter\n     */\n\n\n    function LokiMemoryAdapter(options) {\n      this.hashStore = {};\n      this.options = options || {};\n\n      if (!this.options.hasOwnProperty('asyncResponses')) {\n        this.options.asyncResponses = false;\n      }\n\n      if (!this.options.hasOwnProperty('asyncTimeout')) {\n        this.options.asyncTimeout = 50; // 50 ms default\n      }\n    }\n    /**\n     * Loads a serialized database from its in-memory store.\n     * (Loki persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - adapter callback to return load result to caller\n     * @memberof LokiMemoryAdapter\n     */\n\n\n    LokiMemoryAdapter.prototype.loadDatabase = function (dbname, callback) {\n      var self = this;\n\n      if (this.options.asyncResponses) {\n        setTimeout(function () {\n          if (self.hashStore.hasOwnProperty(dbname)) {\n            callback(self.hashStore[dbname].value);\n          } else {\n            // database doesn't exist, return falsy\n            callback(null);\n          }\n        }, this.options.asyncTimeout);\n      } else {\n        if (this.hashStore.hasOwnProperty(dbname)) {\n          // database doesn't exist, return falsy\n          callback(this.hashStore[dbname].value);\n        } else {\n          callback(null);\n        }\n      }\n    };\n    /**\n     * Saves a serialized database to its in-memory store.\n     * (Loki persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - adapter callback to return load result to caller\n     * @memberof LokiMemoryAdapter\n     */\n\n\n    LokiMemoryAdapter.prototype.saveDatabase = function (dbname, dbstring, callback) {\n      var self = this;\n      var saveCount;\n\n      if (this.options.asyncResponses) {\n        setTimeout(function () {\n          saveCount = self.hashStore.hasOwnProperty(dbname) ? self.hashStore[dbname].savecount : 0;\n          self.hashStore[dbname] = {\n            savecount: saveCount + 1,\n            lastsave: new Date(),\n            value: dbstring\n          };\n          callback();\n        }, this.options.asyncTimeout);\n      } else {\n        saveCount = this.hashStore.hasOwnProperty(dbname) ? this.hashStore[dbname].savecount : 0;\n        this.hashStore[dbname] = {\n          savecount: saveCount + 1,\n          lastsave: new Date(),\n          value: dbstring\n        };\n        callback();\n      }\n    };\n    /**\n     * Deletes a database from its in-memory store.\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - function to call when done\n     * @memberof LokiMemoryAdapter\n     */\n\n\n    LokiMemoryAdapter.prototype.deleteDatabase = function (dbname, callback) {\n      if (this.hashStore.hasOwnProperty(dbname)) {\n        delete this.hashStore[dbname];\n      }\n\n      if (typeof callback === \"function\") {\n        callback();\n      }\n    };\n    /**\n     * An adapter for adapters.  Converts a non reference mode adapter into a reference mode adapter\n     * which can perform destructuring and partioning.  Each collection will be stored in its own key/save and\n     * only dirty collections will be saved.  If you  turn on paging with default page size of 25megs and save\n     * a 75 meg collection it should use up roughly 3 save slots (key/value pairs sent to inner adapter).\n     * A dirty collection that spans three pages will save all three pages again\n     * Paging mode was added mainly because Chrome has issues saving 'too large' of a string within a\n     * single indexeddb row.  If a single document update causes the collection to be flagged as dirty, all\n     * of that collection's pages will be written on next save.\n     *\n     * @param {object} adapter - reference to a 'non-reference' mode loki adapter instance.\n     * @param {object=} options - configuration options for partitioning and paging\n     * @param {bool} options.paging - (default: false) set to true to enable paging collection data.\n     * @param {int} options.pageSize - (default : 25MB) you can use this to limit size of strings passed to inner adapter.\n     * @param {string} options.delimiter - allows you to override the default delimeter\n     * @constructor LokiPartitioningAdapter\n     */\n\n\n    function LokiPartitioningAdapter(adapter, options) {\n      this.mode = \"reference\";\n      this.adapter = null;\n      this.options = options || {};\n      this.dbref = null;\n      this.dbname = \"\";\n      this.pageIterator = {}; // verify user passed an appropriate adapter\n\n      if (adapter) {\n        if (adapter.mode === \"reference\") {\n          throw new Error(\"LokiPartitioningAdapter cannot be instantiated with a reference mode adapter\");\n        } else {\n          this.adapter = adapter;\n        }\n      } else {\n        throw new Error(\"LokiPartitioningAdapter requires a (non-reference mode) adapter on construction\");\n      } // set collection paging defaults\n\n\n      if (!this.options.hasOwnProperty(\"paging\")) {\n        this.options.paging = false;\n      } // default to page size of 25 megs (can be up to your largest serialized object size larger than this)\n\n\n      if (!this.options.hasOwnProperty(\"pageSize\")) {\n        this.options.pageSize = 25 * 1024 * 1024;\n      }\n\n      if (!this.options.hasOwnProperty(\"delimiter\")) {\n        this.options.delimiter = '$<\\n';\n      }\n    }\n    /**\n     * Loads a database which was partitioned into several key/value saves.\n     * (Loki persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - adapter callback to return load result to caller\n     * @memberof LokiPartitioningAdapter\n     */\n\n\n    LokiPartitioningAdapter.prototype.loadDatabase = function (dbname, callback) {\n      var self = this;\n      this.dbname = dbname;\n      this.dbref = new Loki(dbname); // load the db container (without data)\n\n      this.adapter.loadDatabase(dbname, function (result) {\n        // empty database condition is for inner adapter return null/undefined/falsy\n        if (!result) {\n          // partition 0 not found so new database, no need to try to load other partitions.\n          // return same falsy result to loadDatabase to signify no database exists (yet)\n          callback(result);\n          return;\n        }\n\n        if (typeof result !== \"string\") {\n          callback(new Error(\"LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()\"));\n        } // I will want to use loki destructuring helper methods so i will inflate into typed instance\n\n\n        var db = JSON.parse(result);\n        self.dbref.loadJSONObject(db);\n        db = null;\n        var clen = self.dbref.collections.length;\n\n        if (self.dbref.collections.length === 0) {\n          callback(self.dbref);\n          return;\n        }\n\n        self.pageIterator = {\n          collection: 0,\n          pageIndex: 0\n        };\n        self.loadNextPartition(0, function () {\n          callback(self.dbref);\n        });\n      });\n    };\n    /**\n     * Used to sequentially load each collection partition, one at a time.\n     *\n     * @param {int} partition - ordinal collection position to load next\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n\n\n    LokiPartitioningAdapter.prototype.loadNextPartition = function (partition, callback) {\n      var keyname = this.dbname + \".\" + partition;\n      var self = this;\n\n      if (this.options.paging === true) {\n        this.pageIterator.pageIndex = 0;\n        this.loadNextPage(callback);\n        return;\n      }\n\n      this.adapter.loadDatabase(keyname, function (result) {\n        var data = self.dbref.deserializeCollection(result, {\n          delimited: true,\n          collectionIndex: partition\n        });\n        self.dbref.collections[partition].data = data;\n\n        if (++partition < self.dbref.collections.length) {\n          self.loadNextPartition(partition, callback);\n        } else {\n          callback();\n        }\n      });\n    };\n    /**\n     * Used to sequentially load the next page of collection partition, one at a time.\n     *\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n\n\n    LokiPartitioningAdapter.prototype.loadNextPage = function (callback) {\n      // calculate name for next saved page in sequence\n      var keyname = this.dbname + \".\" + this.pageIterator.collection + \".\" + this.pageIterator.pageIndex;\n      var self = this; // load whatever page is next in sequence\n\n      this.adapter.loadDatabase(keyname, function (result) {\n        var data = result.split(self.options.delimiter);\n        result = \"\"; // free up memory now that we have split it into array\n\n        var dlen = data.length;\n        var idx; // detect if last page by presence of final empty string element and remove it if so\n\n        var isLastPage = data[dlen - 1] === \"\";\n\n        if (isLastPage) {\n          data.pop();\n          dlen = data.length; // empty collections are just a delimiter meaning two blank items\n\n          if (data[dlen - 1] === \"\" && dlen === 1) {\n            data.pop();\n            dlen = data.length;\n          }\n        } // convert stringified array elements to object instances and push to collection data\n\n\n        for (idx = 0; idx < dlen; idx++) {\n          self.dbref.collections[self.pageIterator.collection].data.push(JSON.parse(data[idx]));\n          data[idx] = null;\n        }\n\n        data = []; // if last page, we are done with this partition\n\n        if (isLastPage) {\n          // if there are more partitions, kick off next partition load\n          if (++self.pageIterator.collection < self.dbref.collections.length) {\n            self.loadNextPartition(self.pageIterator.collection, callback);\n          } else {\n            callback();\n          }\n        } else {\n          self.pageIterator.pageIndex++;\n          self.loadNextPage(callback);\n        }\n      });\n    };\n    /**\n     * Saves a database by partioning into separate key/value saves.\n     * (Loki 'reference mode' persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {object} dbref - reference to database which we will partition and save.\n     * @param {function} callback - adapter callback to return load result to caller\n     *\n     * @memberof LokiPartitioningAdapter\n     */\n\n\n    LokiPartitioningAdapter.prototype.exportDatabase = function (dbname, dbref, callback) {\n      var self = this;\n      var idx,\n          clen = dbref.collections.length;\n      this.dbref = dbref;\n      this.dbname = dbname; // queue up dirty partitions to be saved\n\n      this.dirtyPartitions = [-1];\n\n      for (idx = 0; idx < clen; idx++) {\n        if (dbref.collections[idx].dirty) {\n          this.dirtyPartitions.push(idx);\n        }\n      }\n\n      this.saveNextPartition(function (err) {\n        callback(err);\n      });\n    };\n    /**\n     * Helper method used internally to save each dirty collection, one at a time.\n     *\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n\n\n    LokiPartitioningAdapter.prototype.saveNextPartition = function (callback) {\n      var self = this;\n      var partition = this.dirtyPartitions.shift();\n      var keyname = this.dbname + (partition === -1 ? \"\" : \".\" + partition); // if we are doing paging and this is collection partition\n\n      if (this.options.paging && partition !== -1) {\n        this.pageIterator = {\n          collection: partition,\n          docIndex: 0,\n          pageIndex: 0\n        }; // since saveNextPage recursively calls itself until done, our callback means this whole paged partition is finished\n\n        this.saveNextPage(function (err) {\n          if (self.dirtyPartitions.length === 0) {\n            callback(err);\n          } else {\n            self.saveNextPartition(callback);\n          }\n        });\n        return;\n      } // otherwise this is 'non-paged' partioning...\n\n\n      var result = this.dbref.serializeDestructured({\n        partitioned: true,\n        delimited: true,\n        partition: partition\n      });\n      this.adapter.saveDatabase(keyname, result, function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        if (self.dirtyPartitions.length === 0) {\n          callback(null);\n        } else {\n          self.saveNextPartition(callback);\n        }\n      });\n    };\n    /**\n     * Helper method used internally to generate and save the next page of the current (dirty) partition.\n     *\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n\n\n    LokiPartitioningAdapter.prototype.saveNextPage = function (callback) {\n      var self = this;\n      var coll = this.dbref.collections[this.pageIterator.collection];\n      var keyname = this.dbname + \".\" + this.pageIterator.collection + \".\" + this.pageIterator.pageIndex;\n      var pageLen = 0,\n          cdlen = coll.data.length,\n          delimlen = this.options.delimiter.length;\n      var serializedObject = \"\",\n          pageBuilder = \"\";\n      var doneWithPartition = false,\n          doneWithPage = false;\n\n      var pageSaveCallback = function pageSaveCallback(err) {\n        pageBuilder = \"\";\n\n        if (err) {\n          callback(err);\n        } // update meta properties then continue process by invoking callback\n\n\n        if (doneWithPartition) {\n          callback(null);\n        } else {\n          self.pageIterator.pageIndex++;\n          self.saveNextPage(callback);\n        }\n      };\n\n      if (coll.data.length === 0) {\n        doneWithPartition = true;\n      }\n\n      while (true) {\n        if (!doneWithPartition) {\n          // serialize object\n          serializedObject = JSON.stringify(coll.data[this.pageIterator.docIndex]);\n          pageBuilder += serializedObject;\n          pageLen += serializedObject.length; // if no more documents in collection to add, we are done with partition\n\n          if (++this.pageIterator.docIndex >= cdlen) doneWithPartition = true;\n        } // if our current page is bigger than defined pageSize, we are done with page\n\n\n        if (pageLen >= this.options.pageSize) doneWithPage = true; // if not done with current page, need delimiter before next item\n        // if done with partition we also want a delmiter to indicate 'end of pages' final empty row\n\n        if (!doneWithPage || doneWithPartition) {\n          pageBuilder += this.options.delimiter;\n          pageLen += delimlen;\n        } // if we are done with page save it and pass off to next recursive call or callback\n\n\n        if (doneWithPartition || doneWithPage) {\n          this.adapter.saveDatabase(keyname, pageBuilder, pageSaveCallback);\n          return;\n        }\n      }\n    };\n    /**\n     * A loki persistence adapter which persists using node fs module\n     * @constructor LokiFsAdapter\n     */\n\n\n    function LokiFsAdapter() {\n      try {\n        this.fs = require('fs');\n      } catch (e) {\n        this.fs = null;\n      }\n    }\n    /**\n     * loadDatabase() - Load data from file, will throw an error if the file does not exist\n     * @param {string} dbname - the filename of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiFsAdapter\n     */\n\n\n    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {\n      var self = this;\n      this.fs.stat(dbname, function (err, stats) {\n        if (!err && stats.isFile()) {\n          self.fs.readFile(dbname, {\n            encoding: 'utf8'\n          }, function readFileCallback(err, data) {\n            if (err) {\n              callback(new Error(err));\n            } else {\n              callback(data);\n            }\n          });\n        } else {\n          callback(null);\n        }\n      });\n    };\n    /**\n     * saveDatabase() - save data to file, will throw an error if the file can't be saved\n     * might want to expand this to avoid dataloss on partial save\n     * @param {string} dbname - the filename of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiFsAdapter\n     */\n\n\n    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {\n      var self = this;\n      var tmpdbname = dbname + '~';\n      this.fs.writeFile(tmpdbname, dbstring, function writeFileCallback(err) {\n        if (err) {\n          callback(new Error(err));\n        } else {\n          self.fs.rename(tmpdbname, dbname, callback);\n        }\n      });\n    };\n    /**\n     * deleteDatabase() - delete the database file, will throw an error if the\n     * file can't be deleted\n     * @param {string} dbname - the filename of the database to delete\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiFsAdapter\n     */\n\n\n    LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {\n      this.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n        if (err) {\n          callback(new Error(err));\n        } else {\n          callback();\n        }\n      });\n    };\n    /**\n     * A loki persistence adapter which persists to web browser's local storage object\n     * @constructor LokiLocalStorageAdapter\n     */\n\n\n    function LokiLocalStorageAdapter() {}\n    /**\n     * loadDatabase() - Load data from localstorage\n     * @param {string} dbname - the name of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiLocalStorageAdapter\n     */\n\n\n    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {\n      if (localStorageAvailable()) {\n        callback(localStorage.getItem(dbname));\n      } else {\n        callback(new Error('localStorage is not available'));\n      }\n    };\n    /**\n     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n     * might want to expand this to avoid dataloss on partial save\n     * @param {string} dbname - the filename of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiLocalStorageAdapter\n     */\n\n\n    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {\n      if (localStorageAvailable()) {\n        localStorage.setItem(dbname, dbstring);\n        callback(null);\n      } else {\n        callback(new Error('localStorage is not available'));\n      }\n    };\n    /**\n     * deleteDatabase() - delete the database from localstorage, will throw an error if it\n     * can't be deleted\n     * @param {string} dbname - the filename of the database to delete\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiLocalStorageAdapter\n     */\n\n\n    LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {\n      if (localStorageAvailable()) {\n        localStorage.removeItem(dbname);\n        callback(null);\n      } else {\n        callback(new Error('localStorage is not available'));\n      }\n    };\n    /**\n     * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.\n     *\n     * @param {function} callback - callback to fire when save queue is drained, it is passed a sucess parameter value\n     * @param {object=} options - configuration options\n     * @param {boolean} options.recursiveWait - (default: true) if after queue is drained, another save was kicked off, wait for it\n     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n     * @memberof Loki\n     */\n\n\n    Loki.prototype.throttledSaveDrain = function (callback, options) {\n      var self = this;\n      var now = new Date().getTime();\n\n      if (!this.throttledSaves) {\n        callback(true);\n      }\n\n      options = options || {};\n\n      if (!options.hasOwnProperty('recursiveWait')) {\n        options.recursiveWait = true;\n      }\n\n      if (!options.hasOwnProperty('recursiveWaitLimit')) {\n        options.recursiveWaitLimit = false;\n      }\n\n      if (!options.hasOwnProperty('recursiveWaitLimitDuration')) {\n        options.recursiveWaitLimitDuration = 2000;\n      }\n\n      if (!options.hasOwnProperty('started')) {\n        options.started = new Date().getTime();\n      } // if save is pending\n\n\n      if (this.throttledSaves && this.throttledSavePending) {\n        // if we want to wait until we are in a state where there are no pending saves at all\n        if (options.recursiveWait) {\n          // queue the following meta callback for when it completes\n          this.throttledCallbacks.push(function () {\n            // if there is now another save pending...\n            if (self.throttledSavePending) {\n              // if we wish to wait only so long and we have exceeded limit of our waiting, callback with false success value\n              if (options.recursiveWaitLimit && now - options.started > options.recursiveWaitLimitDuration) {\n                callback(false);\n                return;\n              } // it must be ok to wait on next queue drain\n\n\n              self.throttledSaveDrain(callback, options);\n              return;\n            } // no pending saves so callback with true success\n            else {\n                callback(true);\n                return;\n              }\n          });\n        } // just notify when current queue is depleted\n        else {\n            this.throttledCallbacks.push(callback);\n            return;\n          }\n      } // no save pending, just callback\n      else {\n          callback(true);\n        }\n    };\n    /**\n     * Internal load logic, decoupled from throttling/contention logic\n     *\n     * @param {object} options - not currently used (remove or allow overrides?)\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     */\n\n\n    Loki.prototype.loadDatabaseInternal = function (options, callback) {\n      var cFun = callback || function (err, data) {\n        if (err) {\n          throw err;\n        }\n      },\n          self = this; // the persistenceAdapter should be present if all is ok, but check to be sure.\n\n\n      if (this.persistenceAdapter !== null) {\n        this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {\n          if (typeof dbString === 'string') {\n            var parseSuccess = false;\n\n            try {\n              self.loadJSON(dbString, options || {});\n              parseSuccess = true;\n            } catch (err) {\n              cFun(err);\n            }\n\n            if (parseSuccess) {\n              cFun(null);\n              self.emit('loaded', 'database ' + self.filename + ' loaded');\n            }\n          } else {\n            // falsy result means new database\n            if (!dbString) {\n              cFun(null);\n              self.emit('loaded', 'empty database ' + self.filename + ' loaded');\n              return;\n            } // instanceof error means load faulted\n\n\n            if (dbString instanceof Error) {\n              cFun(dbString);\n              return;\n            } // if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\n\n            if (typeof dbString === \"object\") {\n              self.loadJSONObject(dbString, options || {});\n              cFun(null); // return null on success\n\n              self.emit('loaded', 'database ' + self.filename + ' loaded');\n              return;\n            }\n\n            cFun(\"unexpected adapter response : \" + dbString);\n          }\n        });\n      } else {\n        cFun(new Error('persistenceAdapter not configured'));\n      }\n    };\n    /**\n     * Handles manually loading from file system, local storage, or adapter (such as indexeddb)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *    To avoid contention with any throttledSaves, we will drain the save queue first.\n     *\n     * If you are configured with autosave, you do not need to call this method yourself.\n     *\n     * @param {object} options - if throttling saves and loads, this controls how we drain save queue before loading\n     * @param {boolean} options.recursiveWait - (default: true) wait recursively until no saves are queued\n     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     * @memberof Loki\n     * @example\n     * db.loadDatabase({}, function(err) {\n     *   if (err) {\n     *     console.log(\"error : \" + err);\n     *   }\n     *   else {\n     *     console.log(\"database loaded.\");\n     *   }\n     * });\n     */\n\n\n    Loki.prototype.loadDatabase = function (options, callback) {\n      var self = this; // if throttling disabled, just call internal\n\n      if (!this.throttledSaves) {\n        this.loadDatabaseInternal(options, callback);\n        return;\n      } // try to drain any pending saves in the queue to lock it for loading\n\n\n      this.throttledSaveDrain(function (success) {\n        if (success) {\n          // pause/throttle saving until loading is done\n          self.throttledSavePending = true;\n          self.loadDatabaseInternal(options, function (err) {\n            // now that we are finished loading, if no saves were throttled, disable flag\n            if (self.throttledCallbacks.length === 0) {\n              self.throttledSavePending = false;\n            } // if saves requests came in while loading, kick off new save to kick off resume saves\n            else {\n                self.saveDatabase();\n              }\n\n            if (typeof callback === 'function') {\n              callback(err);\n            }\n          });\n          return;\n        } else {\n          if (typeof callback === 'function') {\n            callback(new Error(\"Unable to pause save throttling long enough to read database\"));\n          }\n        }\n      }, options);\n    };\n    /**\n     * Internal save logic, decoupled from save throttling logic\n     */\n\n\n    Loki.prototype.saveDatabaseInternal = function (callback) {\n      var cFun = callback || function (err) {\n        if (err) {\n          throw err;\n        }\n\n        return;\n      };\n\n      var self = this; // the persistenceAdapter should be present if all is ok, but check to be sure.\n\n      if (!this.persistenceAdapter) {\n        cFun(new Error('persistenceAdapter not configured'));\n        return;\n      } // run incremental, reference, or normal mode adapters, depending on what's available\n\n\n      if (this.persistenceAdapter.mode === \"incremental\") {\n        var cachedDirty; // ignore autosave until we copy loki (only then we can clear dirty flags,\n        // but if we don't do it now, autosave will be triggered a lot unnecessarily)\n\n        this.ignoreAutosave = true;\n        this.persistenceAdapter.saveDatabase(this.filename, function getLokiCopy() {\n          self.ignoreAutosave = false;\n\n          if (cachedDirty) {\n            cFun(new Error('adapter error - getLokiCopy called more than once'));\n            return;\n          }\n\n          var lokiCopy = self.copy({\n            removeNonSerializable: true\n          }); // remember and clear dirty ids -- we must do it before the save so that if\n          // and update occurs between here and callback, it will get saved later\n\n          cachedDirty = self.collections.map(function (collection) {\n            return [collection.dirty, collection.dirtyIds];\n          });\n          self.collections.forEach(function (col) {\n            col.dirty = false;\n            col.dirtyIds = [];\n          });\n          return lokiCopy;\n        }, function exportDatabaseCallback(err) {\n          self.ignoreAutosave = false;\n\n          if (err && cachedDirty) {\n            // roll back dirty IDs to be saved later\n            self.collections.forEach(function (col, i) {\n              var cached = cachedDirty[i];\n              col.dirty = col.dirty || cached[0];\n              col.dirtyIds = col.dirtyIds.concat(cached[1]);\n            });\n          }\n\n          cFun(err);\n        });\n      } else if (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n        // TODO: dirty should be cleared here\n        // filename may seem redundant but loadDatabase will need to expect this same filename\n        this.persistenceAdapter.exportDatabase(this.filename, this.copy({\n          removeNonSerializable: true\n        }), function exportDatabaseCallback(err) {\n          self.autosaveClearFlags();\n          cFun(err);\n        });\n      } // otherwise just pass the serialized database to adapter\n      else {\n          // persistenceAdapter might be asynchronous, so we must clear `dirty` immediately\n          // or autosave won't work if an update occurs between here and the callback\n          // TODO: This should be stored and rolled back in case of DB save failure\n          this.autosaveClearFlags();\n          this.persistenceAdapter.saveDatabase(this.filename, this.serialize(), function saveDatabasecallback(err) {\n            cFun(err);\n          });\n        }\n    };\n    /**\n     * Handles manually saving to file system, local storage, or adapter (such as indexeddb)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *\n     * If you are configured with autosave, you do not need to call this method yourself.\n     *\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     * @memberof Loki\n     * @example\n     * db.saveDatabase(function(err) {\n     *   if (err) {\n     *     console.log(\"error : \" + err);\n     *   }\n     *   else {\n     *     console.log(\"database saved.\");\n     *   }\n     * });\n     */\n\n\n    Loki.prototype.saveDatabase = function (callback) {\n      if (!this.throttledSaves) {\n        this.saveDatabaseInternal(callback);\n        return;\n      }\n\n      if (this.throttledSavePending) {\n        this.throttledCallbacks.push(callback);\n        return;\n      }\n\n      var localCallbacks = this.throttledCallbacks;\n      this.throttledCallbacks = [];\n      localCallbacks.unshift(callback);\n      this.throttledSavePending = true;\n      var self = this;\n      this.saveDatabaseInternal(function (err) {\n        self.throttledSavePending = false;\n        localCallbacks.forEach(function (pcb) {\n          if (typeof pcb === 'function') {\n            // Queue the callbacks so we first finish this method execution\n            setTimeout(function () {\n              pcb(err);\n            }, 1);\n          }\n        }); // since this is called async, future requests may have come in, if so.. kick off next save\n\n        if (self.throttledCallbacks.length > 0) {\n          self.saveDatabase();\n        }\n      });\n    }; // alias\n\n\n    Loki.prototype.save = Loki.prototype.saveDatabase;\n    /**\n     * Handles deleting a database from file system, local\n     *    storage, or adapter (indexeddb)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     * @memberof Loki\n     */\n\n    Loki.prototype.deleteDatabase = function (options, callback) {\n      var cFun = callback || function (err, data) {\n        if (err) {\n          throw err;\n        }\n      }; // we aren't even using options, so we will support syntax where\n      // callback is passed as first and only argument\n\n\n      if (typeof options === 'function' && !callback) {\n        cFun = options;\n      } // the persistenceAdapter should be present if all is ok, but check to be sure.\n\n\n      if (this.persistenceAdapter !== null) {\n        this.persistenceAdapter.deleteDatabase(this.filename, function deleteDatabaseCallback(err) {\n          cFun(err);\n        });\n      } else {\n        cFun(new Error('persistenceAdapter not configured'));\n      }\n    };\n    /**\n     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n     *\n     * @returns {boolean} - true if database has changed since last autosave, false if not.\n     */\n\n\n    Loki.prototype.autosaveDirty = function () {\n      for (var idx = 0; idx < this.collections.length; idx++) {\n        if (this.collections[idx].dirty) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n    /**\n     * autosaveClearFlags - resets dirty flags on all collections.\n     *    Called from saveDatabase() after db is saved.\n     *\n     */\n\n\n    Loki.prototype.autosaveClearFlags = function () {\n      for (var idx = 0; idx < this.collections.length; idx++) {\n        this.collections[idx].dirty = false;\n      }\n    };\n    /**\n     * autosaveEnable - begin a javascript interval to periodically save the database.\n     *\n     * @param {object} options - not currently used (remove or allow overrides?)\n     * @param {function=} callback - (Optional) user supplied async callback\n     */\n\n\n    Loki.prototype.autosaveEnable = function (options, callback) {\n      this.autosave = true;\n      var delay = 5000,\n          self = this;\n\n      if (typeof this.autosaveInterval !== 'undefined' && this.autosaveInterval !== null) {\n        delay = this.autosaveInterval;\n      }\n\n      this.autosaveHandle = setInterval(function autosaveHandleInterval() {\n        // use of dirty flag will need to be hierarchical since mods are done at collection level with no visibility of 'db'\n        // so next step will be to implement collection level dirty flags set on insert/update/remove\n        // along with loki level isdirty() function which iterates all collections to see if any are dirty\n        if (self.autosaveDirty() && !self.ignoreAutosave) {\n          self.saveDatabase(callback);\n        }\n      }, delay);\n    };\n    /**\n     * autosaveDisable - stop the autosave interval timer.\n     *\n     */\n\n\n    Loki.prototype.autosaveDisable = function () {\n      if (typeof this.autosaveHandle !== 'undefined' && this.autosaveHandle !== null) {\n        clearInterval(this.autosaveHandle);\n        this.autosaveHandle = null;\n      }\n    };\n    /**\n     * Resultset class allowing chainable queries.  Intended to be instanced internally.\n     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n     *\n     * @example\n     *    mycollection.chain()\n     *      .find({ 'doors' : 4 })\n     *      .where(function(obj) { return obj.name === 'Toyota' })\n     *      .data();\n     *\n     * @constructor Resultset\n     * @param {Collection} collection - The collection which this Resultset will query against.\n     */\n\n\n    function Resultset(collection, options) {\n      options = options || {}; // retain reference to collection we are querying against\n\n      this.collection = collection;\n      this.filteredrows = [];\n      this.filterInitialized = false;\n      return this;\n    }\n    /**\n     * reset() - Reset the resultset to its initial state.\n     *\n     * @returns {Resultset} Reference to this resultset, for future chain operations.\n     */\n\n\n    Resultset.prototype.reset = function () {\n      if (this.filteredrows.length > 0) {\n        this.filteredrows = [];\n      }\n\n      this.filterInitialized = false;\n      return this;\n    };\n    /**\n     * toJSON() - Override of toJSON to avoid circular references\n     *\n     */\n\n\n    Resultset.prototype.toJSON = function () {\n      var copy = this.copy();\n      copy.collection = null;\n      return copy;\n    };\n    /**\n     * Allows you to limit the number of documents passed to next chain operation.\n     *    A resultset copy() is made to avoid altering original resultset.\n     *\n     * @param {int} qty - The number of documents to return.\n     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n     * @memberof Resultset\n     * // find the two oldest users\n     * var result = users.chain().simplesort(\"age\", true).limit(2).data();\n     */\n\n\n    Resultset.prototype.limit = function (qty) {\n      // if this has no filters applied, we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var rscopy = new Resultset(this.collection);\n      rscopy.filteredrows = this.filteredrows.slice(0, qty);\n      rscopy.filterInitialized = true;\n      return rscopy;\n    };\n    /**\n     * Used for skipping 'pos' number of documents in the resultset.\n     *\n     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n     * @memberof Resultset\n     * // find everyone but the two oldest users\n     * var result = users.chain().simplesort(\"age\", true).offset(2).data();\n     */\n\n\n    Resultset.prototype.offset = function (pos) {\n      // if this has no filters applied, we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var rscopy = new Resultset(this.collection);\n      rscopy.filteredrows = this.filteredrows.slice(pos);\n      rscopy.filterInitialized = true;\n      return rscopy;\n    };\n    /**\n     * copy() - To support reuse of resultset in branched query situations.\n     *\n     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n     * @memberof Resultset\n     */\n\n\n    Resultset.prototype.copy = function () {\n      var result = new Resultset(this.collection);\n\n      if (this.filteredrows.length > 0) {\n        result.filteredrows = this.filteredrows.slice();\n      }\n\n      result.filterInitialized = this.filterInitialized;\n      return result;\n    };\n    /**\n     * Alias of copy()\n     * @memberof Resultset\n     */\n\n\n    Resultset.prototype.branch = Resultset.prototype.copy;\n    /**\n     * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n     *\n     * @param transform {(string|array)} - name of collection transform or raw transform array\n     * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n     * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n     * @memberof Resultset\n     * @example\n     * users.addTransform('CountryFilter', [\n     *   {\n     *     type: 'find',\n     *     value: {\n     *       'country': { $eq: '[%lktxp]Country' }\n     *     }\n     *   },\n     *   {\n     *     type: 'simplesort',\n     *     property: 'age',\n     *     options: { desc: false}\n     *   }\n     * ]);\n     * var results = users.chain().transform(\"CountryFilter\", { Country: 'fr' }).data();\n     */\n\n    Resultset.prototype.transform = function (transform, parameters) {\n      var idx,\n          step,\n          rs = this; // if transform is name, then do lookup first\n\n      if (typeof transform === 'string') {\n        if (this.collection.transforms.hasOwnProperty(transform)) {\n          transform = this.collection.transforms[transform];\n        }\n      } // either they passed in raw transform array or we looked it up, so process\n\n\n      if (typeof transform !== 'object' || !Array.isArray(transform)) {\n        throw new Error(\"Invalid transform\");\n      }\n\n      if (typeof parameters !== 'undefined') {\n        transform = Utils.resolveTransformParams(transform, parameters);\n      }\n\n      for (idx = 0; idx < transform.length; idx++) {\n        step = transform[idx];\n\n        switch (step.type) {\n          case \"find\":\n            rs.find(step.value);\n            break;\n\n          case \"where\":\n            rs.where(step.value);\n            break;\n\n          case \"simplesort\":\n            rs.simplesort(step.property, step.desc || step.options);\n            break;\n\n          case \"compoundsort\":\n            rs.compoundsort(step.value);\n            break;\n\n          case \"sort\":\n            rs.sort(step.value);\n            break;\n\n          case \"limit\":\n            rs = rs.limit(step.value);\n            break;\n          // limit makes copy so update reference\n\n          case \"offset\":\n            rs = rs.offset(step.value);\n            break;\n          // offset makes copy so update reference\n\n          case \"map\":\n            rs = rs.map(step.value, step.dataOptions);\n            break;\n\n          case \"eqJoin\":\n            rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun, step.dataOptions);\n            break;\n          // following cases break chain by returning array data so make any of these last in transform steps\n\n          case \"mapReduce\":\n            rs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n            break;\n          // following cases update documents in current filtered resultset (use carefully)\n\n          case \"update\":\n            rs.update(step.value);\n            break;\n\n          case \"remove\":\n            rs.remove();\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return rs;\n    };\n    /**\n     * User supplied compare function is provided two documents to compare. (chainable)\n     * @example\n     *    rslt.sort(function(obj1, obj2) {\n     *      if (obj1.name === obj2.name) return 0;\n     *      if (obj1.name > obj2.name) return 1;\n     *      if (obj1.name < obj2.name) return -1;\n     *    });\n     *\n     * @param {function} comparefun - A javascript compare function used for sorting.\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     */\n\n\n    Resultset.prototype.sort = function (comparefun) {\n      // if this has no filters applied, just we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var wrappedComparer = function (userComparer, data) {\n        return function (a, b) {\n          return userComparer(data[a], data[b]);\n        };\n      }(comparefun, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n      return this;\n    };\n    /**\n     * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n     *    Sorting based on the same lt/gt helper functions used for binary indices.\n     *\n     * @param {string} propname - name of property to sort by.\n     * @param {object|bool=} options - boolean to specify if isdescending, or options object\n     * @param {boolean} [options.desc=false] - whether to sort descending\n     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.\n     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).\n     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     * @example\n     * var results = users.chain().simplesort('age').data();\n     */\n\n\n    Resultset.prototype.simplesort = function (propname, options) {\n      var eff,\n          targetEff = 10,\n          dc = this.collection.data.length,\n          frl = this.filteredrows.length,\n          hasBinaryIndex = this.collection.binaryIndices.hasOwnProperty(propname);\n\n      if (typeof options === 'undefined' || options === false) {\n        options = {\n          desc: false\n        };\n      }\n\n      if (options === true) {\n        options = {\n          desc: true\n        };\n      } // if nothing in filtered rows array...\n\n\n      if (frl === 0) {\n        // if the filter is initialized to be empty resultset, do nothing\n        if (this.filterInitialized) {\n          return this;\n        } // otherwise no filters applied implies all documents, so we need to populate filteredrows first\n        // if we have a binary index, we can just use that instead of sorting (again)\n\n\n        if (this.collection.binaryIndices.hasOwnProperty(propname)) {\n          // make sure index is up-to-date\n          this.collection.ensureIndex(propname); // copy index values into filteredrows\n\n          this.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\n          if (options.desc) {\n            this.filteredrows.reverse();\n          } // we are done, return this (resultset) for further chain ops\n\n\n          return this;\n        } // otherwise initialize array for sort below\n        else {\n            // build full document index (to be sorted subsequently)\n            this.filteredrows = this.collection.prepareFullDocIndex();\n          }\n      } // otherwise we had results to begin with, see if we qualify for index intercept optimization\n      else {\n          // If already filtered, but we want to leverage binary index on sort.\n          // This will use custom array intection algorithm.\n          if (!options.disableIndexIntersect && hasBinaryIndex) {\n            // calculate filter efficiency\n            eff = dc / frl; // when javascript sort fallback is enabled, you generally need more than ~17% of total docs in resultset\n            // before array intersect is determined to be the faster algorithm, otherwise leave at 10% for loki sort.\n\n            if (options.useJavascriptSorting) {\n              targetEff = 6;\n            } // anything more than ratio of 10:1 (total documents/current results) should use old sort code path\n            // So we will only use array intersection if you have more than 10% of total docs in your current resultset.\n\n\n            if (eff <= targetEff || options.forceIndexIntersect) {\n              var idx,\n                  fr = this.filteredrows;\n              var io = {}; // set up hashobject for simple 'inclusion test' with existing (filtered) results\n\n              for (idx = 0; idx < frl; idx++) {\n                io[fr[idx]] = true;\n              } // grab full sorted binary index array\n\n\n              var pv = this.collection.binaryIndices[propname].values; // filter by existing results\n\n              this.filteredrows = pv.filter(function (n) {\n                return io[n];\n              });\n\n              if (options.desc) {\n                this.filteredrows.reverse();\n              }\n\n              return this;\n            }\n          }\n        } // at this point, we will not be able to leverage binary index so we will have to do an array sort\n      // if we have opted to use simplified javascript comparison function...\n\n\n      if (options.useJavascriptSorting) {\n        return this.sort(function (obj1, obj2) {\n          if (obj1[propname] === obj2[propname]) return 0;\n          if (obj1[propname] > obj2[propname]) return 1;\n          if (obj1[propname] < obj2[propname]) return -1;\n        });\n      } // otherwise use loki sort which will return same results if column is indexed or not\n\n\n      var wrappedComparer = function (prop, desc, data) {\n        var val1, val2, arr;\n        return function (a, b) {\n          if (~prop.indexOf('.')) {\n            arr = prop.split('.');\n            val1 = Utils.getIn(data[a], arr, true);\n            val2 = Utils.getIn(data[b], arr, true);\n          } else {\n            val1 = data[a][prop];\n            val2 = data[b][prop];\n          }\n\n          return sortHelper(val1, val2, desc);\n        };\n      }(propname, options.desc, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n      return this;\n    };\n    /**\n     * Allows sorting a resultset based on multiple columns.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * rs.compoundsort(['age', 'name']);\n     * // to sort by age (ascending) and then by name (descending)\n     * rs.compoundsort(['age', ['name', true]]);\n     *\n     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     */\n\n\n    Resultset.prototype.compoundsort = function (properties) {\n      if (properties.length === 0) {\n        throw new Error(\"Invalid call to compoundsort, need at least one property\");\n      }\n\n      var prop;\n\n      if (properties.length === 1) {\n        prop = properties[0];\n\n        if (Array.isArray(prop)) {\n          return this.simplesort(prop[0], prop[1]);\n        }\n\n        return this.simplesort(prop, false);\n      } // unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\n\n      for (var i = 0, len = properties.length; i < len; i += 1) {\n        prop = properties[i];\n\n        if (!Array.isArray(prop)) {\n          properties[i] = [prop, false];\n        }\n      } // if this has no filters applied, just we need to populate filteredrows first\n\n\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var wrappedComparer = function (props, data) {\n        return function (a, b) {\n          return compoundeval(props, data[a], data[b]);\n        };\n      }(properties, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n      return this;\n    };\n    /**\n     * findOr() - oversee the operation of OR'ed query expressions.\n     *    OR'ed expression evaluation runs each expression individually against the full collection,\n     *    and finally does a set OR on each expression's results.\n     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n     *\n     * @param {array} expressionArray - array of expressions\n     * @returns {Resultset} this resultset for further chain ops.\n     */\n\n\n    Resultset.prototype.findOr = function (expressionArray) {\n      var fr = null,\n          fri = 0,\n          frlen = 0,\n          docset = [],\n          idxset = [],\n          idx = 0,\n          origCount = this.count(); // If filter is already initialized, then we query against only those items already in filter.\n      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\n      for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n        // we need to branch existing query to run each filter separately and combine results\n        fr = this.branch().find(expressionArray[ei]).filteredrows;\n        frlen = fr.length; // add any document 'hits'\n\n        for (fri = 0; fri < frlen; fri++) {\n          idx = fr[fri];\n\n          if (idxset[idx] === undefined) {\n            idxset[idx] = true;\n            docset.push(idx);\n          }\n        }\n      }\n\n      this.filteredrows = docset;\n      this.filterInitialized = true;\n      return this;\n    };\n\n    Resultset.prototype.$or = Resultset.prototype.findOr; // precompile recursively\n\n    function precompileQuery(operator, value) {\n      // for regex ops, precompile\n      if (operator === '$regex') {\n        if (Array.isArray(value)) {\n          value = new RegExp(value[0], value[1]);\n        } else if (!(value instanceof RegExp)) {\n          value = new RegExp(value);\n        }\n      } else if (typeof value === 'object') {\n        for (var key in value) {\n          if (key === '$regex' || typeof value[key] === 'object') {\n            value[key] = precompileQuery(key, value[key]);\n          }\n        }\n      }\n\n      return value;\n    }\n    /**\n     * findAnd() - oversee the operation of AND'ed query expressions.\n     *    AND'ed expression evaluation runs each expression progressively against the full collection,\n     *    internally utilizing existing chained resultset functionality.\n     *    Only the first filter can utilize a binary index.\n     *\n     * @param {array} expressionArray - array of expressions\n     * @returns {Resultset} this resultset for further chain ops.\n     */\n\n\n    Resultset.prototype.findAnd = function (expressionArray) {\n      // we have already implementing method chaining in this (our Resultset class)\n      // so lets just progressively apply user supplied and filters\n      for (var i = 0, len = expressionArray.length; i < len; i++) {\n        if (this.count() === 0) {\n          return this;\n        }\n\n        this.find(expressionArray[i]);\n      }\n\n      return this;\n    };\n\n    Resultset.prototype.$and = Resultset.prototype.findAnd;\n    /**\n     * Used for querying via a mongo-style query object.\n     *\n     * @param {object} query - A mongo-style query object used for filtering current results.\n     * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * var over30 = users.chain().find({ age: { $gte: 30 } }).data();\n     */\n\n    Resultset.prototype.find = function (query, firstOnly) {\n      if (this.collection.data.length === 0) {\n        this.filteredrows = [];\n        this.filterInitialized = true;\n        return this;\n      }\n\n      var queryObject = query || 'getAll',\n          p,\n          property,\n          queryObjectOp,\n          obj,\n          operator,\n          value,\n          key,\n          searchByIndex = false,\n          result = [],\n          filters = [],\n          index = null; // flag if this was invoked via findOne()\n\n      firstOnly = firstOnly || false;\n\n      if (typeof queryObject === 'object') {\n        for (p in queryObject) {\n          obj = {};\n          obj[p] = queryObject[p];\n          filters.push(obj);\n\n          if (hasOwnProperty.call(queryObject, p)) {\n            property = p;\n            queryObjectOp = queryObject[p];\n          }\n        } // if more than one expression in single query object,\n        // convert implicit $and to explicit $and\n\n\n        if (filters.length > 1) {\n          return this.find({\n            '$and': filters\n          }, firstOnly);\n        }\n      } // apply no filters if they want all\n\n\n      if (!property || queryObject === 'getAll') {\n        if (firstOnly) {\n          if (this.filterInitialized) {\n            this.filteredrows = this.filteredrows.slice(0, 1);\n          } else {\n            this.filteredrows = this.collection.data.length > 0 ? [0] : [];\n            this.filterInitialized = true;\n          }\n        }\n\n        return this;\n      } // injecting $and and $or expression tree evaluation here.\n\n\n      if (property === '$and' || property === '$or') {\n        this[property](queryObjectOp); // for chained find with firstonly,\n\n        if (firstOnly && this.filteredrows.length > 1) {\n          this.filteredrows = this.filteredrows.slice(0, 1);\n        }\n\n        return this;\n      } // see if query object is in shorthand mode (assuming eq operator)\n\n\n      if (queryObjectOp === null || typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date) {\n        operator = '$eq';\n        value = queryObjectOp;\n      } else if (typeof queryObjectOp === 'object') {\n        for (key in queryObjectOp) {\n          if (hasOwnProperty.call(queryObjectOp, key)) {\n            operator = key;\n            value = queryObjectOp[key];\n            break;\n          }\n        }\n      } else {\n        throw new Error('Do not know what you want to do.');\n      }\n\n      if (operator === '$regex' || typeof value === 'object') {\n        value = precompileQuery(operator, value);\n      } // if user is deep querying the object such as find('name.first': 'odin')\n\n\n      var usingDotNotation = property.indexOf('.') !== -1; // if an index exists for the property being queried against, use it\n      // for now only enabling where it is the first filter applied and prop is indexed\n\n      var doIndexCheck = !this.filterInitialized;\n\n      if (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator]) {\n        // this is where our lazy index rebuilding will take place\n        // basically we will leave all indexes dirty until we need them\n        // so here we will rebuild only the index tied to this property\n        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n        if (this.collection.adaptiveBinaryIndices !== true) {\n          this.collection.ensureIndex(property);\n        }\n\n        searchByIndex = true;\n        index = this.collection.binaryIndices[property];\n      } // opportunistically speed up $in searches from O(n*m) to O(n*log m)\n\n\n      if (!searchByIndex && operator === '$in' && Array.isArray(value) && typeof Set !== 'undefined') {\n        value = new Set(value);\n        operator = '$inSet';\n      } // the comparison function\n\n\n      var fun = LokiOps[operator]; // \"shortcut\" for collection data\n\n      var t = this.collection.data; // filter data length\n\n      var i = 0,\n          len = 0; // Query executed differently depending on :\n      //    - whether the property being queried has an index defined\n      //    - if chained, we handle first pass differently for initial filteredrows[] population\n      //\n      // For performance reasons, each case has its own if block to minimize in-loop calculations\n\n      var filter,\n          rowIdx = 0,\n          record; // If the filteredrows[] is already initialized, use it\n\n      if (this.filterInitialized) {\n        filter = this.filteredrows;\n        len = filter.length; // currently supporting dot notation for non-indexed conditions only\n\n        if (usingDotNotation) {\n          property = property.split('.');\n\n          for (i = 0; i < len; i++) {\n            rowIdx = filter[i];\n            record = t[rowIdx];\n\n            if (dotSubScan(record, property, fun, value, record)) {\n              result.push(rowIdx);\n\n              if (firstOnly) {\n                this.filteredrows = result;\n                return this;\n              }\n            }\n          }\n        } else {\n          for (i = 0; i < len; i++) {\n            rowIdx = filter[i];\n            record = t[rowIdx];\n\n            if (fun(record[property], value, record)) {\n              result.push(rowIdx);\n\n              if (firstOnly) {\n                this.filteredrows = result;\n                return this;\n              }\n            }\n          }\n        }\n      } // first chained query so work against data[] but put results in filteredrows\n      else {\n          // if not searching by index\n          if (!searchByIndex) {\n            len = t.length;\n\n            if (usingDotNotation) {\n              property = property.split('.');\n\n              for (i = 0; i < len; i++) {\n                record = t[i];\n\n                if (dotSubScan(record, property, fun, value, record)) {\n                  result.push(i);\n\n                  if (firstOnly) {\n                    this.filteredrows = result;\n                    this.filterInitialized = true;\n                    return this;\n                  }\n                }\n              }\n            } else {\n              for (i = 0; i < len; i++) {\n                record = t[i];\n\n                if (fun(record[property], value, record)) {\n                  result.push(i);\n\n                  if (firstOnly) {\n                    this.filteredrows = result;\n                    this.filterInitialized = true;\n                    return this;\n                  }\n                }\n              }\n            }\n          } else {\n            // search by index\n            var segm = this.collection.calculateRange(operator, property, value);\n\n            if (operator !== '$in') {\n              for (i = segm[0]; i <= segm[1]; i++) {\n                if (indexedOps[operator] !== true) {\n                  // must be a function, implying 2nd phase filtering of results from calculateRange\n                  if (indexedOps[operator](Utils.getIn(t[index.values[i]], property, usingDotNotation), value)) {\n                    result.push(index.values[i]);\n\n                    if (firstOnly) {\n                      this.filteredrows = result;\n                      this.filterInitialized = true;\n                      return this;\n                    }\n                  }\n                } else {\n                  result.push(index.values[i]);\n\n                  if (firstOnly) {\n                    this.filteredrows = result;\n                    this.filterInitialized = true;\n                    return this;\n                  }\n                }\n              }\n            } else {\n              for (i = 0, len = segm.length; i < len; i++) {\n                result.push(index.values[segm[i]]);\n\n                if (firstOnly) {\n                  this.filteredrows = result;\n                  this.filterInitialized = true;\n                  return this;\n                }\n              }\n            }\n          }\n        }\n\n      this.filteredrows = result;\n      this.filterInitialized = true; // next time work against filteredrows[]\n\n      return this;\n    };\n    /**\n     * where() - Used for filtering via a javascript filter function.\n     *\n     * @param {function} fun - A javascript function used for filtering current results by.\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * var over30 = users.chain().where(function(obj) { return obj.age >= 30; }.data();\n     */\n\n\n    Resultset.prototype.where = function (fun) {\n      var viewFunction,\n          result = [];\n\n      if ('function' === typeof fun) {\n        viewFunction = fun;\n      } else {\n        throw new TypeError('Argument is not a stored view or a function');\n      }\n\n      try {\n        // If the filteredrows[] is already initialized, use it\n        if (this.filterInitialized) {\n          var j = this.filteredrows.length;\n\n          while (j--) {\n            if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n              result.push(this.filteredrows[j]);\n            }\n          }\n\n          this.filteredrows = result;\n          return this;\n        } // otherwise this is initial chained op, work against data, push into filteredrows[]\n        else {\n            var k = this.collection.data.length;\n\n            while (k--) {\n              if (viewFunction(this.collection.data[k]) === true) {\n                result.push(k);\n              }\n            }\n\n            this.filteredrows = result;\n            this.filterInitialized = true;\n            return this;\n          }\n      } catch (err) {\n        throw err;\n      }\n    };\n    /**\n     * count() - returns the number of documents in the resultset.\n     *\n     * @returns {number} The number of documents in the resultset.\n     * @memberof Resultset\n     * @example\n     * var over30Count = users.chain().find({ age: { $gte: 30 } }).count();\n     */\n\n\n    Resultset.prototype.count = function () {\n      if (this.filterInitialized) {\n        return this.filteredrows.length;\n      }\n\n      return this.collection.count();\n    };\n    /**\n     * Terminates the chain and returns array of filtered documents\n     *\n     * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n     *        the collection is not configured for clone object.\n     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents\n     *\n     * @returns {array} Array of documents in the resultset\n     * @memberof Resultset\n     * @example\n     * var resutls = users.chain().find({ age: 34 }).data();\n     */\n\n\n    Resultset.prototype.data = function (options) {\n      var result = [],\n          data = this.collection.data,\n          obj,\n          len,\n          i,\n          method;\n      options = options || {}; // if user opts to strip meta, then force clones and use 'shallow' if 'force' options are not present\n\n      if (options.removeMeta && !options.forceClones) {\n        options.forceClones = true;\n        options.forceCloneMethod = options.forceCloneMethod || 'shallow';\n      } // if collection has delta changes active, then force clones and use 'parse-stringify' for effective change tracking of nested objects\n      // if collection is immutable freeze and unFreeze takes care of cloning\n\n\n      if (!this.collection.disableDeltaChangesApi && this.collection.disableFreeze) {\n        options.forceClones = true;\n        options.forceCloneMethod = 'parse-stringify';\n      } // if this has no filters applied, just return collection.data\n\n\n      if (!this.filterInitialized) {\n        if (this.filteredrows.length === 0) {\n          // determine whether we need to clone objects or not\n          if (this.collection.cloneObjects || options.forceClones) {\n            len = data.length;\n            method = options.forceCloneMethod || this.collection.cloneMethod;\n\n            for (i = 0; i < len; i++) {\n              obj = clone(data[i], method);\n\n              if (options.removeMeta) {\n                delete obj.$loki;\n                delete obj.meta;\n              }\n\n              result.push(obj);\n            }\n\n            return result;\n          } // otherwise we are not cloning so return sliced array with same object references\n          else {\n              return data.slice();\n            }\n        } else {\n          // filteredrows must have been set manually, so use it\n          this.filterInitialized = true;\n        }\n      }\n\n      var fr = this.filteredrows;\n      len = fr.length;\n\n      if (this.collection.cloneObjects || options.forceClones) {\n        method = options.forceCloneMethod || this.collection.cloneMethod;\n\n        for (i = 0; i < len; i++) {\n          obj = clone(data[fr[i]], method);\n\n          if (options.removeMeta) {\n            delete obj.$loki;\n            delete obj.meta;\n          }\n\n          result.push(obj);\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          result.push(data[fr[i]]);\n        }\n      }\n\n      return result;\n    };\n    /**\n     * Used to run an update operation on all documents currently in the resultset.\n     *\n     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * users.chain().find({ country: 'de' }).update(function(user) {\n     *   user.phoneFormat = \"+49 AAAA BBBBBB\";\n     * });\n     */\n\n\n    Resultset.prototype.update = function (updateFunction) {\n      if (typeof updateFunction !== \"function\") {\n        throw new TypeError('Argument is not a function');\n      } // if this has no filters applied, we need to populate filteredrows first\n\n\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var obj,\n          len = this.filteredrows.length,\n          rcd = this.collection.data; // pass in each document object currently in resultset to user supplied updateFunction\n\n      for (var idx = 0; idx < len; idx++) {\n        // if we have cloning option specified or are doing differential delta changes, clone object first\n        if (!this.disableFreeze || this.collection.cloneObjects || !this.collection.disableDeltaChangesApi) {\n          obj = clone(rcd[this.filteredrows[idx]], this.collection.cloneMethod);\n          updateFunction(obj);\n          this.collection.update(obj);\n        } else {\n          // no need to clone, so just perform update on collection data object instance\n          updateFunction(rcd[this.filteredrows[idx]]);\n          this.collection.update(rcd[this.filteredrows[idx]]);\n        }\n      }\n\n      return this;\n    };\n    /**\n     * Removes all document objects which are currently in resultset from collection (as well as resultset)\n     *\n     * @returns {Resultset} this (empty) resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * // remove users inactive since 1/1/2001\n     * users.chain().find({ lastActive: { $lte: new Date(\"1/1/2001\").getTime() } }).remove();\n     */\n\n\n    Resultset.prototype.remove = function () {\n      // if this has no filters applied, we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      this.collection.removeBatchByPositions(this.filteredrows);\n      this.filteredrows = [];\n      return this;\n    };\n    /**\n     * data transformation via user supplied functions\n     *\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns {value} The output of your reduceFunction\n     * @memberof Resultset\n     * @example\n     * var db = new loki(\"order.db\");\n     * var orders = db.addCollection(\"orders\");\n     * orders.insert([{ qty: 4, unitCost: 100.00 }, { qty: 10, unitCost: 999.99 }, { qty: 2, unitCost: 49.99 }]);\n     *\n     * function mapfun (obj) { return obj.qty*obj.unitCost };\n     * function reducefun(array) {\n     *   var grandTotal=0;\n     *   array.forEach(function(orderTotal) { grandTotal += orderTotal; });\n     *   return grandTotal;\n     * }\n     * var grandOrderTotal = orders.chain().mapReduce(mapfun, reducefun);\n     * console.log(grandOrderTotal);\n     */\n\n\n    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data().map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n    /**\n     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n     * @param {Array|Resultset|Collection} joinData - Data array to join to.\n     * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n     * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n     * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n     * @param {object=} dataOptions - options to data() before input to your map function\n     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n     * @memberof Resultset\n     * @example\n     * var db = new loki('sandbox.db');\n     *\n     * var products = db.addCollection('products');\n     * var orders = db.addCollection('orders');\n     *\n     * products.insert({ productId: \"100234\", name: \"flywheel energy storage\", unitCost: 19999.99 });\n     * products.insert({ productId: \"140491\", name: \"300F super capacitor\", unitCost: 129.99 });\n     * products.insert({ productId: \"271941\", name: \"fuel cell\", unitCost: 3999.99 });\n     * products.insert({ productId: \"174592\", name: \"390V 3AH lithium bank\", unitCost: 4999.99 });\n     *\n     * orders.insert({ orderDate : new Date(\"12/1/2017\").getTime(), prodId: \"174592\", qty: 2, customerId: 2 });\n     * orders.insert({ orderDate : new Date(\"4/15/2016\").getTime(), prodId: \"271941\", qty: 1, customerId: 1 });\n     * orders.insert({ orderDate : new Date(\"3/12/2017\").getTime(), prodId: \"140491\", qty: 4, customerId: 4 });\n     * orders.insert({ orderDate : new Date(\"7/31/2017\").getTime(), prodId: \"100234\", qty: 7, customerId: 3 });\n     * orders.insert({ orderDate : new Date(\"8/3/2016\").getTime(), prodId: \"174592\", qty: 3, customerId: 5 });\n     *\n     * var mapfun = function(left, right) {\n     *   return {\n     *     orderId: left.$loki,\n     *     orderDate: new Date(left.orderDate) + '',\n     *     customerId: left.customerId,\n     *     qty: left.qty,\n     *     productId: left.prodId,\n     *     prodName: right.name,\n     *     prodCost: right.unitCost,\n     *     orderTotal: +((right.unitCost * left.qty).toFixed(2))\n     *   };\n     * };\n     *\n     * // join orders with relevant product info via eqJoin\n     * var orderSummary = orders.chain().eqJoin(products, \"prodId\", \"productId\", mapfun).data();\n     *\n     * console.log(orderSummary);\n     */\n\n\n    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun, dataOptions) {\n      var leftData = [],\n          leftDataLength,\n          rightData = [],\n          rightDataLength,\n          key,\n          result = [],\n          leftKeyisFunction = typeof leftJoinKey === 'function',\n          rightKeyisFunction = typeof rightJoinKey === 'function',\n          joinMap = {}; //get the left data\n\n      leftData = this.data(dataOptions);\n      leftDataLength = leftData.length; //get the right data\n\n      if (joinData instanceof Collection) {\n        rightData = joinData.chain().data(dataOptions);\n      } else if (joinData instanceof Resultset) {\n        rightData = joinData.data(dataOptions);\n      } else if (Array.isArray(joinData)) {\n        rightData = joinData;\n      } else {\n        throw new TypeError('joinData needs to be an array or result set');\n      }\n\n      rightDataLength = rightData.length; //construct a lookup table\n\n      for (var i = 0; i < rightDataLength; i++) {\n        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n        joinMap[key] = rightData[i];\n      }\n\n      if (!mapFun) {\n        mapFun = function mapFun(left, right) {\n          return {\n            left: left,\n            right: right\n          };\n        };\n      } //Run map function over each object in the resultset\n\n\n      for (var j = 0; j < leftDataLength; j++) {\n        key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n        result.push(mapFun(leftData[j], joinMap[key] || {}));\n      } //return return a new resultset with no filters\n\n\n      this.collection = new Collection('joinData');\n      this.collection.insert(result);\n      this.filteredrows = [];\n      this.filterInitialized = false;\n      return this;\n    };\n    /**\n     * Applies a map function into a new collection for further chaining.\n     * @param {function} mapFun - javascript map function\n     * @param {object=} dataOptions - options to data() before input to your map function\n     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     * @memberof Resultset\n     * @example\n     * var orders.chain().find({ productId: 32 }).map(function(obj) {\n     *   return {\n     *     orderId: $loki,\n     *     productId: productId,\n     *     quantity: qty\n     *   };\n     * });\n     */\n\n\n    Resultset.prototype.map = function (mapFun, dataOptions) {\n      var data = this.data(dataOptions).map(mapFun); //return return a new resultset with no filters\n\n      this.collection = new Collection('mappedData');\n      this.collection.insert(data);\n      this.filteredrows = [];\n      this.filterInitialized = false;\n      return this;\n    };\n    /**\n     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n     *\n     * @example\n     * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n     * mydv.applyFind({ 'doors' : 4 });\n     * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n     * var results = mydv.data();\n     *\n     * @constructor DynamicView\n     * @implements LokiEventEmitter\n     * @param {Collection} collection - A reference to the collection to work against\n     * @param {string} name - The name of this dynamic view\n     * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'\n     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)\n     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n     * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n     */\n\n\n    function DynamicView(collection, name, options) {\n      this.collection = collection;\n      this.name = name;\n      this.rebuildPending = false;\n      this.options = options || {};\n\n      if (!this.options.hasOwnProperty('persistent')) {\n        this.options.persistent = false;\n      } // 'persistentSortPriority':\n      // 'passive' will defer the sort phase until they call data(). (most efficient overall)\n      // 'active' will sort async whenever next idle. (prioritizes read speeds)\n\n\n      if (!this.options.hasOwnProperty('sortPriority')) {\n        this.options.sortPriority = 'passive';\n      }\n\n      if (!this.options.hasOwnProperty('minRebuildInterval')) {\n        this.options.minRebuildInterval = 1;\n      }\n\n      this.resultset = new Resultset(collection);\n      this.resultdata = [];\n      this.resultsdirty = false;\n      this.cachedresultset = null; // keep ordered filter pipeline\n\n      this.filterPipeline = [];\n\n      if (!this.collection.disableFreeze) {\n        Object.freeze(this.filterPipeline);\n      } // sorting member variables\n      // we only support one active search, applied using applySort() or applySimpleSort()\n\n\n      this.sortFunction = null;\n      this.sortCriteria = null;\n      this.sortCriteriaSimple = null;\n      this.sortDirty = false; // for now just have 1 event for when we finally rebuilt lazy view\n      // once we refactor transactions, i will tie in certain transactional events\n\n      this.events = {\n        'rebuild': [],\n        'filter': [],\n        'sort': []\n      };\n    }\n\n    DynamicView.prototype = new LokiEventEmitter();\n    DynamicView.prototype.constructor = DynamicView;\n    /**\n     * getSort() - used to get the current sort\n     *\n     * @returns function (sortFunction) or array (sortCriteria) or object (sortCriteriaSimple)\n     */\n\n    DynamicView.prototype.getSort = function () {\n      return this.sortFunction || this.sortCriteria || this.sortCriteriaSimple;\n    };\n    /**\n     * rematerialize() - internally used immediately after deserialization (loading)\n     *    This will clear out and reapply filterPipeline ops, recreating the view.\n     *    Since where filters do not persist correctly, this method allows\n     *    restoring the view to state where user can re-apply those where filters.\n     *\n     * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n     * @returns {DynamicView} This dynamic view for further chained ops.\n     * @memberof DynamicView\n     * @fires DynamicView.rebuild\n     */\n\n\n    DynamicView.prototype.rematerialize = function (options) {\n      var fpl, fpi, idx;\n      options = options || {};\n      this.resultdata = [];\n      this.resultsdirty = true;\n      this.resultset = new Resultset(this.collection);\n\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.sortDirty = true;\n      }\n\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n\n      if (options.hasOwnProperty('removeWhereFilters')) {\n        // for each view see if it had any where filters applied... since they don't\n        // serialize those functions lets remove those invalid filters\n        if (wasFrozen) {\n          this.filterPipeline = this.filterPipeline.slice();\n        }\n\n        fpl = this.filterPipeline.length;\n        fpi = fpl;\n\n        while (fpi--) {\n          if (this.filterPipeline[fpi].type === 'where') {\n            if (fpi !== this.filterPipeline.length - 1) {\n              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n            }\n\n            this.filterPipeline.length--;\n          }\n        }\n      } // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\n\n      var ofp = this.filterPipeline;\n      this.filterPipeline = []; // now re-apply 'find' filterPipeline ops\n\n      fpl = ofp.length;\n\n      for (idx = 0; idx < fpl; idx++) {\n        this.applyFind(ofp[idx].val, ofp[idx].uid);\n      }\n\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      } // during creation of unit tests, i will remove this forced refresh and leave lazy\n\n\n      this.data(); // emit rebuild event in case user wants to be notified\n\n      this.emit('rebuild', this);\n      return this;\n    };\n    /**\n     * branchResultset() - Makes a copy of the internal resultset for branched queries.\n     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n     *    so your branched query should be immediately resolved and not held for future evaluation.\n     *\n     * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n     * @param {object=} parameters - optional parameters (if optional transform requires them)\n     * @returns {Resultset} A copy of the internal resultset for branched queries.\n     * @memberof DynamicView\n     * @example\n     * var db = new loki('test');\n     * var coll = db.addCollection('mydocs');\n     * var dv = coll.addDynamicView('myview');\n     * var tx = [\n     *   {\n     *     type: 'offset',\n     *     value: '[%lktxp]pageStart'\n     *   },\n     *   {\n     *     type: 'limit',\n     *     value: '[%lktxp]pageSize'\n     *   }\n     * ];\n     * coll.addTransform('viewPaging', tx);\n     *\n     * // add some records\n     *\n     * var results = dv.branchResultset('viewPaging', { pageStart: 10, pageSize: 10 }).data();\n     */\n\n\n    DynamicView.prototype.branchResultset = function (transform, parameters) {\n      var rs = this.resultset.branch();\n\n      if (typeof transform === 'undefined') {\n        return rs;\n      }\n\n      return rs.transform(transform, parameters);\n    };\n    /**\n     * toJSON() - Override of toJSON to avoid circular references\n     *\n     */\n\n\n    DynamicView.prototype.toJSON = function () {\n      var copy = new DynamicView(this.collection, this.name, this.options);\n      copy.resultset = this.resultset;\n      copy.resultdata = []; // let's not save data (copy) to minimize size\n\n      copy.resultsdirty = true;\n      copy.filterPipeline = this.filterPipeline;\n      copy.sortFunction = this.sortFunction;\n      copy.sortCriteria = this.sortCriteria;\n      copy.sortCriteriaSimple = this.sortCriteriaSimple || null;\n      copy.sortDirty = this.sortDirty; // avoid circular reference, reapply in db.loadJSON()\n\n      copy.collection = null;\n      return copy;\n    };\n    /**\n     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n     *     Existing options should be retained.\n     * @param {object=} options - configure removeFilter behavior\n     * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.removeFilters = function (options) {\n      options = options || {};\n      this.rebuildPending = false;\n      this.resultset.reset();\n      this.resultdata = [];\n      this.resultsdirty = true;\n      this.cachedresultset = null;\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n      var filterChanged = this.filterPipeline.length > 0; // keep ordered filter pipeline\n\n      this.filterPipeline = [];\n\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      } // sorting member variables\n      // we only support one active search, applied using applySort() or applySimpleSort()\n\n\n      this.sortFunction = null;\n      this.sortCriteria = null;\n      this.sortCriteriaSimple = null;\n      this.sortDirty = false;\n\n      if (options.queueSortPhase === true) {\n        this.queueSortPhase();\n      }\n\n      if (filterChanged) {\n        this.emit('filter');\n      }\n    };\n    /**\n     * applySort() - Used to apply a sort to the dynamic view\n     * @example\n     * dv.applySort(function(obj1, obj2) {\n     *   if (obj1.name === obj2.name) return 0;\n     *   if (obj1.name > obj2.name) return 1;\n     *   if (obj1.name < obj2.name) return -1;\n     * });\n     *\n     * @param {function} comparefun - a javascript compare function used for sorting\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.applySort = function (comparefun) {\n      this.sortFunction = comparefun;\n      this.sortCriteria = null;\n      this.sortCriteriaSimple = null;\n      this.queueSortPhase();\n      this.emit('sort');\n      return this;\n    };\n    /**\n     * applySimpleSort() - Used to specify a property used for view translation.\n     * @example\n     * dv.applySimpleSort(\"name\");\n     *\n     * @param {string} propname - Name of property by which to sort.\n     * @param {object|boolean=} options - boolean for sort descending or options object\n     * @param {boolean} [options.desc=false] - whether we should sort descending.\n     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.\n     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).\n     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.applySimpleSort = function (propname, options) {\n      this.sortCriteriaSimple = {\n        propname: propname,\n        options: options || false\n      };\n\n      if (!this.collection.disableFreeze) {\n        deepFreeze(this.sortCriteriaSimple);\n      }\n\n      this.sortCriteria = null;\n      this.sortFunction = null;\n      this.queueSortPhase();\n      this.emit('sort');\n      return this;\n    };\n    /**\n     * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * dv.applySortCriteria(['age', 'name']);\n     * // to sort by age (ascending) and then by name (descending)\n     * dv.applySortCriteria(['age', ['name', true]);\n     * // to sort by age (descending) and then by name (descending)\n     * dv.applySortCriteria(['age', true], ['name', true]);\n     *\n     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.applySortCriteria = function (criteria) {\n      this.sortCriteria = criteria;\n\n      if (!this.collection.disableFreeze) {\n        deepFreeze(this.sortCriteria);\n      }\n\n      this.sortCriteriaSimple = null;\n      this.sortFunction = null;\n      this.queueSortPhase();\n      this.emit('sort');\n      return this;\n    };\n    /**\n     * startTransaction() - marks the beginning of a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n\n\n    DynamicView.prototype.startTransaction = function () {\n      this.cachedresultset = this.resultset.copy();\n      return this;\n    };\n    /**\n     * commit() - commits a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n\n\n    DynamicView.prototype.commit = function () {\n      this.cachedresultset = null;\n      return this;\n    };\n    /**\n     * rollback() - rolls back a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n\n\n    DynamicView.prototype.rollback = function () {\n      this.resultset = this.cachedresultset;\n\n      if (this.options.persistent) {\n        // for now just rebuild the persistent dynamic view data in this worst case scenario\n        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n        this.resultdata = this.resultset.data();\n        this.emit('rebuild', this);\n      }\n\n      return this;\n    };\n    /**\n     * Implementation detail.\n     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n     *\n     * @param {(string|number)} uid - The unique ID of the filter.\n     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n     */\n\n\n    DynamicView.prototype._indexOfFilterWithId = function (uid) {\n      if (typeof uid === 'string' || typeof uid === 'number') {\n        for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n          if (uid === this.filterPipeline[idx].uid) {\n            return idx;\n          }\n        }\n      }\n\n      return -1;\n    };\n    /**\n     * Implementation detail.\n     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n     *\n     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n     */\n\n\n    DynamicView.prototype._addFilter = function (filter) {\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n\n      if (wasFrozen) {\n        this.filterPipeline = this.filterPipeline.slice();\n      }\n\n      if (!this.collection.disableFreeze) {\n        deepFreeze(filter);\n      }\n\n      this.filterPipeline.push(filter);\n\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n\n      this.resultset[filter.type](filter.val);\n    };\n    /**\n     * reapplyFilters() - Reapply all the filters in the current pipeline.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n\n\n    DynamicView.prototype.reapplyFilters = function () {\n      this.resultset.reset();\n      this.cachedresultset = null;\n\n      if (this.options.persistent) {\n        this.resultdata = [];\n        this.resultsdirty = true;\n      }\n\n      var filters = this.filterPipeline;\n      var wasFrozen = Object.isFrozen(filters);\n      this.filterPipeline = [];\n\n      for (var idx = 0, len = filters.length; idx < len; idx += 1) {\n        this._addFilter(filters[idx]);\n      }\n\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      this.emit('filter');\n      return this;\n    };\n    /**\n     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n     *\n     * @param {object} filter - A filter object to add to the pipeline.\n     *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.applyFilter = function (filter) {\n      var idx = this._indexOfFilterWithId(filter.uid);\n\n      if (idx >= 0) {\n        var wasFrozen = Object.isFrozen(this.filterPipeline);\n\n        if (wasFrozen) {\n          this.filterPipeline = this.filterPipeline.slice();\n        }\n\n        this.filterPipeline[idx] = filter;\n\n        if (wasFrozen) {\n          freeze(filter);\n          Object.freeze(this.filterPipeline);\n        }\n\n        return this.reapplyFilters();\n      }\n\n      this.cachedresultset = null;\n\n      if (this.options.persistent) {\n        this.resultdata = [];\n        this.resultsdirty = true;\n      }\n\n      this._addFilter(filter);\n\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      this.emit('filter');\n      return this;\n    };\n    /**\n     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n     *\n     * @param {object} query - A mongo-style query object to apply to pipeline\n     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.applyFind = function (query, uid) {\n      this.applyFilter({\n        type: 'find',\n        val: query,\n        uid: uid\n      });\n      return this;\n    };\n    /**\n     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n     *\n     * @param {function} fun - A javascript filter function to apply to pipeline\n     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.applyWhere = function (fun, uid) {\n      this.applyFilter({\n        type: 'where',\n        val: fun,\n        uid: uid\n      });\n      return this;\n    };\n    /**\n     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n     *\n     * @param {(string|number)} uid - The unique ID of the filter to be removed.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.removeFilter = function (uid) {\n      var idx = this._indexOfFilterWithId(uid);\n\n      if (idx < 0) {\n        throw new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n      }\n\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n\n      if (wasFrozen) {\n        this.filterPipeline = this.filterPipeline.slice();\n      }\n\n      this.filterPipeline.splice(idx, 1);\n\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n\n      this.reapplyFilters();\n      return this;\n    };\n    /**\n     * count() - returns the number of documents representing the current DynamicView contents.\n     *\n     * @returns {number} The number of documents representing the current DynamicView contents.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.count = function () {\n      // in order to be accurate we will pay the minimum cost (and not alter dv state management)\n      // recurring resultset data resolutions should know internally its already up to date.\n      // for persistent data this will not update resultdata nor fire rebuild event.\n      if (this.resultsdirty) {\n        this.resultdata = this.resultset.data();\n      }\n\n      return this.resultset.count();\n    };\n    /**\n     * data() - resolves and pending filtering and sorting, then returns document array as result.\n     *\n     * @param {object=} options - optional parameters to pass to resultset.data() if non-persistent\n     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n     *        the collection is not configured for clone object.\n     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents\n     * @returns {array} An array of documents representing the current DynamicView contents.\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.data = function (options) {\n      // using final sort phase as 'catch all' for a few use cases which require full rebuild\n      if (this.sortDirty || this.resultsdirty) {\n        this.performSortPhase({\n          suppressRebuildEvent: true\n        });\n      }\n\n      return this.options.persistent ? this.resultdata : this.resultset.data(options);\n    };\n    /**\n     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n     *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n     */\n\n\n    DynamicView.prototype.queueRebuildEvent = function () {\n      if (this.rebuildPending) {\n        return;\n      }\n\n      this.rebuildPending = true;\n      var self = this;\n      setTimeout(function () {\n        if (self.rebuildPending) {\n          self.rebuildPending = false;\n          self.emit('rebuild', self);\n        }\n      }, this.options.minRebuildInterval);\n    };\n    /**\n     * queueSortPhase : If the view is sorted we will throttle sorting to either :\n     *    (1) passive - when the user calls data(), or\n     *    (2) active - once they stop updating and yield js thread control\n     */\n\n\n    DynamicView.prototype.queueSortPhase = function () {\n      // already queued? exit without queuing again\n      if (this.sortDirty) {\n        return;\n      }\n\n      this.sortDirty = true;\n      var self = this;\n\n      if (this.options.sortPriority === \"active\") {\n        // active sorting... once they are done and yield js thread, run async performSortPhase()\n        setTimeout(function () {\n          self.performSortPhase();\n        }, this.options.minRebuildInterval);\n      } else {\n        // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n        // potentially notify user that data has changed.\n        this.queueRebuildEvent();\n      }\n    };\n    /**\n     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n     *\n     */\n\n\n    DynamicView.prototype.performSortPhase = function (options) {\n      // async call to this may have been pre-empted by synchronous call to data before async could fire\n      if (!this.sortDirty && !this.resultsdirty) {\n        return;\n      }\n\n      options = options || {};\n\n      if (this.sortDirty) {\n        if (this.sortFunction) {\n          this.resultset.sort(this.sortFunction);\n        } else if (this.sortCriteria) {\n          this.resultset.compoundsort(this.sortCriteria);\n        } else if (this.sortCriteriaSimple) {\n          this.resultset.simplesort(this.sortCriteriaSimple.propname, this.sortCriteriaSimple.options);\n        }\n\n        this.sortDirty = false;\n      }\n\n      if (this.options.persistent) {\n        // persistent view, rebuild local resultdata array\n        this.resultdata = this.resultset.data();\n        this.resultsdirty = false;\n      }\n\n      if (!options.suppressRebuildEvent) {\n        this.emit('rebuild', this);\n      }\n    };\n    /**\n     * evaluateDocument() - internal method for (re)evaluating document inclusion.\n     *    Called by : collection.insert() and collection.update().\n     *\n     * @param {int} objIndex - index of document to (re)run through filter pipeline.\n     * @param {bool} isNew - true if the document was just added to the collection.\n     */\n\n\n    DynamicView.prototype.evaluateDocument = function (objIndex, isNew) {\n      // if no filter applied yet, the result 'set' should remain 'everything'\n      if (!this.resultset.filterInitialized) {\n        if (this.options.persistent) {\n          this.resultdata = this.resultset.data();\n        } // need to re-sort to sort new document\n\n\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n\n      var ofr = this.resultset.filteredrows;\n      var oldPos = isNew ? -1 : ofr.indexOf(+objIndex);\n      var oldlen = ofr.length; // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\n      var evalResultset = new Resultset(this.collection);\n      evalResultset.filteredrows = [objIndex];\n      evalResultset.filterInitialized = true;\n      var filter;\n\n      for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n        filter = this.filterPipeline[idx];\n        evalResultset[filter.type](filter.val);\n      } // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\n\n      var newPos = evalResultset.filteredrows.length === 0 ? -1 : 0; // wasn't in old, shouldn't be now... do nothing\n\n      if (oldPos === -1 && newPos === -1) return; // wasn't in resultset, should be now... add\n\n      if (oldPos === -1 && newPos !== -1) {\n        ofr.push(objIndex);\n\n        if (this.options.persistent) {\n          this.resultdata.push(this.collection.data[objIndex]);\n        } // need to re-sort to sort new document\n\n\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      } // was in resultset, shouldn't be now... delete\n\n\n      if (oldPos !== -1 && newPos === -1) {\n        if (oldPos < oldlen - 1) {\n          ofr.splice(oldPos, 1);\n\n          if (this.options.persistent) {\n            this.resultdata.splice(oldPos, 1);\n          }\n        } else {\n          ofr.length = oldlen - 1;\n\n          if (this.options.persistent) {\n            this.resultdata.length = oldlen - 1;\n          }\n        } // in case changes to data altered a sort column\n\n\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      } // was in resultset, should still be now... (update persistent only?)\n\n\n      if (oldPos !== -1 && newPos !== -1) {\n        if (this.options.persistent) {\n          // in case document changed, replace persistent view data with the latest collection.data document\n          this.resultdata[oldPos] = this.collection.data[objIndex];\n        } // in case changes to data altered a sort column\n\n\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n    };\n    /**\n     * removeDocument() - internal function called on collection.delete()\n     * @param {number|number[]} objIndex - index of document to (re)run through filter pipeline.\n     */\n\n\n    DynamicView.prototype.removeDocument = function (objIndex) {\n      var idx,\n          rmidx,\n          rmlen,\n          rxo = {},\n          fxo = {};\n      var adjels = [];\n      var drs = this.resultset;\n      var fr = this.resultset.filteredrows;\n      var frlen = fr.length; // if no filter applied yet, the result 'set' should remain 'everything'\n\n      if (!this.resultset.filterInitialized) {\n        if (this.options.persistent) {\n          this.resultdata = this.resultset.data();\n        } // in case changes to data altered a sort column\n\n\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      } // if passed single index, wrap in array\n\n\n      if (!Array.isArray(objIndex)) {\n        objIndex = [objIndex];\n      }\n\n      rmlen = objIndex.length; // create intersection object of data indices to remove\n\n      for (rmidx = 0; rmidx < rmlen; rmidx++) {\n        rxo[objIndex[rmidx]] = true;\n      } // pivot remove data indices into remove filteredrows indices and dump in hashobject\n\n\n      for (idx = 0; idx < frlen; idx++) {\n        if (rxo[fr[idx]]) fxo[idx] = true;\n      } // if any of the removed items were in our filteredrows...\n\n\n      if (Object.keys(fxo).length > 0) {\n        // remove them from filtered rows\n        this.resultset.filteredrows = this.resultset.filteredrows.filter(function (di, idx) {\n          return !fxo[idx];\n        }); // if persistent...\n\n        if (this.options.persistent) {\n          // remove from resultdata\n          this.resultdata = this.resultdata.filter(function (obj, idx) {\n            return !fxo[idx];\n          });\n        } // and queue sorts\n\n\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n      } // to remove holes, we need to 'shift down' indices, this filter function finds number of positions to shift\n\n\n      var filt = function filt(idx) {\n        return function (di) {\n          return di < drs.filteredrows[idx];\n        };\n      };\n\n      frlen = drs.filteredrows.length;\n\n      for (idx = 0; idx < frlen; idx++) {\n        // grab subset of removed elements where data index is less than current filtered row data index;\n        // use this to determine how many positions iterated remaining data index needs to be 'shifted down'\n        adjels = objIndex.filter(filt(idx));\n        drs.filteredrows[idx] -= adjels.length;\n      }\n    };\n    /**\n     * mapReduce() - data transformation via user supplied functions\n     *\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns The output of your reduceFunction\n     * @memberof DynamicView\n     */\n\n\n    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data().map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n    /**\n     * Collection class that handles documents of same type\n     * @constructor Collection\n     * @implements LokiEventEmitter\n     * @param {string} name - collection name\n     * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for\n     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for\n     * @param {array=} [options.indices=[]] - array property names to define binary indexes for\n     * @param {boolean} [options.adaptiveBinaryIndices=true] - collection indices will be actively rebuilt rather than lazily\n     * @param {boolean} [options.asyncListeners=false] - whether listeners are invoked asynchronously\n     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes API\n     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically\n     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n     * @param {boolean} [options.serializableIndices=true[]] - converts date values on binary indexed properties to epoch time\n     * @param {boolean} [options.disableFreeze=true] - when false all docs are frozen\n     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.\n     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n     * @see {@link Loki#addCollection} for normal creation of collections\n     */\n\n\n    function Collection(name, options) {\n      // the name of the collection\n      this.name = name; // the data held by the collection\n\n      this.data = [];\n      this.idIndex = null; // position->$loki index (built lazily)\n\n      this.binaryIndices = {}; // user defined indexes\n\n      this.constraints = {\n        unique: {},\n        exact: {}\n      }; // unique contraints contain duplicate object references, so they are not persisted.\n      // we will keep track of properties which have unique contraint applied here, and regenerate lazily\n\n      this.uniqueNames = []; // transforms will be used to store frequently used query chains as a series of steps\n      // which itself can be stored along with the database.\n\n      this.transforms = {}; // the object type of the collection\n\n      this.objType = name; // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n      // defaulting to true since this is called from addCollection and adding a collection should trigger save\n\n      this.dirty = true; // private holders for cached data\n\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n      this.cachedData = null;\n      var self = this;\n      /* OPTIONS */\n\n      options = options || {}; // exact match and unique constraints\n\n      if (options.hasOwnProperty('unique')) {\n        if (!Array.isArray(options.unique)) {\n          options.unique = [options.unique];\n        } // save names; actual index is built lazily\n\n\n        options.unique.forEach(function (prop) {\n          self.uniqueNames.push(prop);\n        });\n      }\n\n      if (options.hasOwnProperty('exact')) {\n        options.exact.forEach(function (prop) {\n          self.constraints.exact[prop] = new ExactIndex(prop);\n        });\n      } // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n      // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\n\n      this.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true; // is collection transactional\n\n      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false; // options to clone objects when inserting them\n\n      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false; // default clone method (if enabled) is parse-stringify\n\n      this.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\"; // option to make event listeners async, default is sync\n\n      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false; // if set to true we will not maintain a meta property for a document\n\n      this.disableMeta = options.hasOwnProperty('disableMeta') ? options.disableMeta : false; // disable track changes\n\n      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true; // disable delta update object style on changes\n\n      this.disableDeltaChangesApi = options.hasOwnProperty('disableDeltaChangesApi') ? options.disableDeltaChangesApi : true;\n\n      if (this.disableChangesApi) {\n        this.disableDeltaChangesApi = true;\n      } // option to observe objects and update them automatically, ignored if Object.observe is not supported\n\n\n      this.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false; // by default, if you insert a document into a collection with binary indices, if those indexed properties contain\n      // a DateTime we will convert to epoch time format so that (across serializations) its value position will be the\n      // same 'after' serialization as it was 'before'.\n\n      this.serializableIndices = options.hasOwnProperty('serializableIndices') ? options.serializableIndices : true; // option to deep freeze all documents\n\n      this.disableFreeze = options.hasOwnProperty('disableFreeze') ? options.disableFreeze : true; //option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\n      this.ttl = {\n        age: null,\n        ttlInterval: null,\n        daemon: null\n      };\n      this.setTTL(options.ttl || -1, options.ttlInterval); // currentMaxId - change manually at your own peril!\n\n      this.maxId = 0;\n      this.DynamicViews = []; // events\n\n      this.events = {\n        'insert': [],\n        'update': [],\n        'pre-insert': [],\n        'pre-update': [],\n        'close': [],\n        'flushbuffer': [],\n        'error': [],\n        'delete': [],\n        'warning': []\n      }; // changes are tracked by collection and aggregated by the db\n\n      this.changes = []; // lightweight changes tracking (loki IDs only) for optimized db saving\n\n      this.dirtyIds = []; // initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\n      var indices = [];\n\n      if (options && options.indices) {\n        if (Object.prototype.toString.call(options.indices) === '[object Array]') {\n          indices = options.indices;\n        } else if (typeof options.indices === 'string') {\n          indices = [options.indices];\n        } else {\n          throw new TypeError('Indices needs to be a string or an array of strings');\n        }\n      }\n\n      for (var idx = 0; idx < indices.length; idx++) {\n        this.ensureIndex(indices[idx]);\n      }\n\n      function observerCallback(changes) {\n        var changedObjects = typeof Set === 'function' ? new Set() : [];\n        if (!changedObjects.add) changedObjects.add = function (object) {\n          if (this.indexOf(object) === -1) this.push(object);\n          return this;\n        };\n        changes.forEach(function (change) {\n          changedObjects.add(change.object);\n        });\n        changedObjects.forEach(function (object) {\n          if (!hasOwnProperty.call(object, '$loki')) return self.removeAutoUpdateObserver(object);\n\n          try {\n            self.update(object);\n          } catch (err) {}\n        });\n      }\n\n      this.observerCallback = observerCallback; //Compare changed object (which is a forced clone) with existing object and return the delta\n\n      function getChangeDelta(obj, old) {\n        if (old) {\n          return getObjectDelta(old, obj);\n        } else {\n          return JSON.parse(JSON.stringify(obj));\n        }\n      }\n\n      this.getChangeDelta = getChangeDelta;\n\n      function getObjectDelta(oldObject, newObject) {\n        var propertyNames = newObject !== null && typeof newObject === 'object' ? Object.keys(newObject) : null;\n\n        if (propertyNames && propertyNames.length && ['string', 'boolean', 'number'].indexOf(typeof newObject) < 0) {\n          var delta = {};\n\n          for (var i = 0; i < propertyNames.length; i++) {\n            var propertyName = propertyNames[i];\n\n            if (newObject.hasOwnProperty(propertyName)) {\n              if (!oldObject.hasOwnProperty(propertyName) || self.uniqueNames.indexOf(propertyName) >= 0 || propertyName == '$loki' || propertyName == 'meta') {\n                delta[propertyName] = newObject[propertyName];\n              } else {\n                var propertyDelta = getObjectDelta(oldObject[propertyName], newObject[propertyName]);\n\n                if (typeof propertyDelta !== \"undefined\" && propertyDelta != {}) {\n                  delta[propertyName] = propertyDelta;\n                }\n              }\n            }\n          }\n\n          return Object.keys(delta).length === 0 ? undefined : delta;\n        } else {\n          return oldObject === newObject ? undefined : newObject;\n        }\n      }\n\n      this.getObjectDelta = getObjectDelta; // clear all the changes\n\n      function flushChanges() {\n        self.changes = [];\n      }\n\n      this.getChanges = function () {\n        return self.changes;\n      };\n\n      this.flushChanges = flushChanges;\n\n      this.setChangesApi = function (enabled) {\n        self.disableChangesApi = !enabled;\n\n        if (!enabled) {\n          self.disableDeltaChangesApi = false;\n        }\n      };\n\n      this.on('delete', function deleteCallback(obj) {\n        if (!self.disableChangesApi) {\n          self.createChange(self.name, 'R', obj);\n        }\n      });\n      this.on('warning', function (warning) {\n        self.lokiConsoleWrapper.warn(warning);\n      }); // for de-serialization purposes\n\n      flushChanges();\n    }\n\n    Collection.prototype = new LokiEventEmitter();\n    Collection.prototype.contructor = Collection;\n    /*\n      * For ChangeAPI default to clone entire object, for delta changes create object with only differences (+ $loki and meta)\n      */\n\n    Collection.prototype.createChange = function (name, op, obj, old) {\n      this.changes.push({\n        name: name,\n        operation: op,\n        obj: op == 'U' && !this.disableDeltaChangesApi ? this.getChangeDelta(obj, old) : JSON.parse(JSON.stringify(obj))\n      });\n    };\n\n    Collection.prototype.insertMeta = function (obj) {\n      var len, idx;\n\n      if (this.disableMeta || !obj) {\n        return;\n      } // if batch insert\n\n\n      if (Array.isArray(obj)) {\n        len = obj.length;\n\n        for (idx = 0; idx < len; idx++) {\n          if (!obj[idx].hasOwnProperty('meta')) {\n            obj[idx].meta = {};\n          }\n\n          obj[idx].meta.created = new Date().getTime();\n          obj[idx].meta.revision = 0;\n        }\n\n        return;\n      } // single object\n\n\n      if (!obj.meta) {\n        obj.meta = {};\n      }\n\n      obj.meta.created = new Date().getTime();\n      obj.meta.revision = 0;\n    };\n\n    Collection.prototype.updateMeta = function (obj) {\n      if (this.disableMeta || !obj) {\n        return obj;\n      }\n\n      if (!this.disableFreeze) {\n        obj = unFreeze(obj);\n        obj.meta = unFreeze(obj.meta);\n      }\n\n      obj.meta.updated = new Date().getTime();\n      obj.meta.revision += 1;\n      return obj;\n    };\n\n    Collection.prototype.createInsertChange = function (obj) {\n      this.createChange(this.name, 'I', obj);\n    };\n\n    Collection.prototype.createUpdateChange = function (obj, old) {\n      this.createChange(this.name, 'U', obj, old);\n    };\n\n    Collection.prototype.insertMetaWithChange = function (obj) {\n      this.insertMeta(obj);\n      this.createInsertChange(obj);\n    };\n\n    Collection.prototype.updateMetaWithChange = function (obj, old, objFrozen) {\n      obj = this.updateMeta(obj, objFrozen);\n      this.createUpdateChange(obj, old);\n      return obj;\n    };\n\n    Collection.prototype.lokiConsoleWrapper = {\n      log: function log() {},\n      warn: function warn() {},\n      error: function error() {}\n    };\n\n    Collection.prototype.addAutoUpdateObserver = function (object) {\n      if (!this.autoupdate || typeof Object.observe !== 'function') return;\n      Object.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n    };\n\n    Collection.prototype.removeAutoUpdateObserver = function (object) {\n      if (!this.autoupdate || typeof Object.observe !== 'function') return;\n      Object.unobserve(object, this.observerCallback);\n    };\n    /**\n     * Adds a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {array} transform - an array of transformation 'step' objects to save into the collection\n     * @memberof Collection\n     * @example\n     * users.addTransform('progeny', [\n     *   {\n     *     type: 'find',\n     *     value: {\n     *       'age': {'$lte': 40}\n     *     }\n     *   }\n     * ]);\n     *\n     * var results = users.chain('progeny').data();\n     */\n\n\n    Collection.prototype.addTransform = function (name, transform) {\n      if (this.transforms.hasOwnProperty(name)) {\n        throw new Error(\"a transform by that name already exists\");\n      }\n\n      this.transforms[name] = transform;\n    };\n    /**\n     * Retrieves a named transform from the collection.\n     * @param {string} name - name of the transform to lookup.\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.getTransform = function (name) {\n      return this.transforms[name];\n    };\n    /**\n     * Updates a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {object} transform - a transformation object to save into collection\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.setTransform = function (name, transform) {\n      this.transforms[name] = transform;\n    };\n    /**\n     * Removes a named collection transform from the collection\n     * @param {string} name - name of collection transform to remove\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.removeTransform = function (name) {\n      delete this.transforms[name];\n    };\n\n    Collection.prototype.byExample = function (template) {\n      var k, obj, query;\n      query = [];\n\n      for (k in template) {\n        if (!template.hasOwnProperty(k)) continue;\n        query.push((obj = {}, obj[k] = template[k], obj));\n      }\n\n      return {\n        '$and': query\n      };\n    };\n\n    Collection.prototype.findObject = function (template) {\n      return this.findOne(this.byExample(template));\n    };\n\n    Collection.prototype.findObjects = function (template) {\n      return this.find(this.byExample(template));\n    };\n    /*----------------------------+\n    | TTL daemon                  |\n    +----------------------------*/\n\n\n    Collection.prototype.ttlDaemonFuncGen = function () {\n      var collection = this;\n      var age = this.ttl.age;\n      return function ttlDaemon() {\n        var now = Date.now();\n        var toRemove = collection.chain().where(function daemonFilter(member) {\n          var timestamp = member.meta.updated || member.meta.created;\n          var diff = now - timestamp;\n          return age < diff;\n        });\n        toRemove.remove();\n      };\n    };\n    /**\n     * Updates or applies collection TTL settings.\n     * @param {int} age - age (in ms) to expire document from collection\n     * @param {int} interval - time (in ms) to clear collection of aged documents.\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.setTTL = function (age, interval) {\n      if (age < 0) {\n        clearInterval(this.ttl.daemon);\n      } else {\n        this.ttl.age = age;\n        this.ttl.ttlInterval = interval;\n        this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n      }\n    };\n    /*----------------------------+\n    | INDEXING                    |\n    +----------------------------*/\n\n    /**\n     * create a row filter that covers all documents in the collection\n     */\n\n\n    Collection.prototype.prepareFullDocIndex = function () {\n      var len = this.data.length;\n      var indexes = new Array(len);\n\n      for (var i = 0; i < len; i += 1) {\n        indexes[i] = i;\n      }\n\n      return indexes;\n    };\n    /**\n     * Will allow reconfiguring certain collection options.\n     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.configureOptions = function (options) {\n      options = options || {};\n\n      if (options.hasOwnProperty('adaptiveBinaryIndices')) {\n        this.adaptiveBinaryIndices = options.adaptiveBinaryIndices; // if switching to adaptive binary indices, make sure none are 'dirty'\n\n        if (this.adaptiveBinaryIndices) {\n          this.ensureAllIndexes();\n        }\n      }\n    };\n    /**\n     * Ensure binary index on a certain field\n     * @param {string} property - name of property to create binary index on\n     * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.ensureIndex = function (property, force) {\n      // optional parameter to force rebuild whether flagged as dirty or not\n      if (typeof force === 'undefined') {\n        force = false;\n      }\n\n      if (property === null || property === undefined) {\n        throw new Error('Attempting to set index without an associated property');\n      }\n\n      if (this.binaryIndices[property] && !force) {\n        if (!this.binaryIndices[property].dirty) return;\n      } // if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n\n\n      if (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {\n        return;\n      }\n\n      var index = {\n        'name': property,\n        'dirty': true,\n        'values': this.prepareFullDocIndex()\n      };\n      this.binaryIndices[property] = index;\n\n      var wrappedComparer = function (prop, data) {\n        var val1, val2;\n        var propPath = ~prop.indexOf('.') ? prop.split('.') : false;\n        return function (a, b) {\n          if (propPath) {\n            val1 = Utils.getIn(data[a], propPath, true);\n            val2 = Utils.getIn(data[b], propPath, true);\n          } else {\n            val1 = data[a][prop];\n            val2 = data[b][prop];\n          }\n\n          if (val1 !== val2) {\n            if (Comparators.lt(val1, val2, false)) return -1;\n            if (Comparators.gt(val1, val2, false)) return 1;\n          }\n\n          return 0;\n        };\n      }(property, this.data);\n\n      index.values.sort(wrappedComparer);\n      index.dirty = false;\n      this.dirty = true; // for autosave scenarios\n    };\n    /**\n     * Perform checks to determine validity/consistency of all binary indices\n     * @param {object=} options - optional configuration object\n     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used\n     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample\n     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered\n     * @returns {string[]} array of index names where problems were found.\n     * @memberof Collection\n     * @example\n     * // check all indices on a collection, returns array of invalid index names\n     * var result = coll.checkAllIndexes({ repair: true, randomSampling: true, randomSamplingFactor: 0.15 });\n     * if (result.length > 0) {\n     *   results.forEach(function(name) {\n     *     console.log('problem encountered with index : ' + name);\n     *   });\n     * }\n     */\n\n\n    Collection.prototype.checkAllIndexes = function (options) {\n      var key,\n          bIndices = this.binaryIndices;\n      var results = [],\n          result;\n\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          result = this.checkIndex(key, options);\n\n          if (!result) {\n            results.push(key);\n          }\n        }\n      }\n\n      return results;\n    };\n    /**\n     * Perform checks to determine validity/consistency of a binary index\n     * @param {string} property - name of the binary-indexed property to check\n     * @param {object=} options - optional configuration object\n     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used\n     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample\n     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered\n     * @returns {boolean} whether the index was found to be valid (before optional correcting).\n     * @memberof Collection\n     * @example\n     * // full test\n     * var valid = coll.checkIndex('name');\n     * // full test with repair (if issues found)\n     * valid = coll.checkIndex('name', { repair: true });\n     * // random sampling (default is 10% of total document count)\n     * valid = coll.checkIndex('name', { randomSampling: true });\n     * // random sampling (sample 20% of total document count)\n     * valid = coll.checkIndex('name', { randomSampling: true, randomSamplingFactor: 0.20 });\n     * // random sampling (implied boolean)\n     * valid = coll.checkIndex('name', { randomSamplingFactor: 0.20 });\n     * // random sampling with repair (if issues found)\n     * valid = coll.checkIndex('name', { repair: true, randomSampling: true });\n     */\n\n\n    Collection.prototype.checkIndex = function (property, options) {\n      options = options || {}; // if 'randomSamplingFactor' specified but not 'randomSampling', assume true\n\n      if (options.randomSamplingFactor && options.randomSampling !== false) {\n        options.randomSampling = true;\n      }\n\n      options.randomSamplingFactor = options.randomSamplingFactor || 0.1;\n\n      if (options.randomSamplingFactor < 0 || options.randomSamplingFactor > 1) {\n        options.randomSamplingFactor = 0.1;\n      }\n\n      var valid = true,\n          idx,\n          iter,\n          pos,\n          len,\n          biv; // make sure we are passed a valid binary index name\n\n      if (!this.binaryIndices.hasOwnProperty(property)) {\n        throw new Error(\"called checkIndex on property without an index: \" + property);\n      } // if lazy indexing, rebuild only if flagged as dirty\n\n\n      if (!this.adaptiveBinaryIndices) {\n        this.ensureIndex(property);\n      }\n\n      biv = this.binaryIndices[property].values;\n      len = biv.length; // if the index has an incorrect number of values\n\n      if (len !== this.data.length) {\n        if (options.repair) {\n          this.ensureIndex(property, true);\n        }\n\n        return false;\n      }\n\n      if (len === 0) {\n        return true;\n      }\n\n      var usingDotNotation = property.indexOf('.') !== -1;\n\n      if (len === 1) {\n        valid = biv[0] === 0;\n      } else {\n        if (options.randomSampling) {\n          // validate first and last\n          if (!LokiOps.$lte(Utils.getIn(this.data[biv[0]], property, usingDotNotation), Utils.getIn(this.data[biv[1]], property, usingDotNotation))) {\n            valid = false;\n          }\n\n          if (!LokiOps.$lte(Utils.getIn(this.data[biv[len - 2]], property, usingDotNotation), Utils.getIn(this.data[biv[len - 1]], property, usingDotNotation))) {\n            valid = false;\n          } // if first and last positions are sorted correctly with their nearest neighbor,\n          // continue onto random sampling phase...\n\n\n          if (valid) {\n            // # random samplings = total count * sampling factor\n            iter = Math.floor((len - 1) * options.randomSamplingFactor); // for each random sampling, validate that the binary index is sequenced properly\n            // with next higher value.\n\n            for (idx = 0; idx < iter - 1; idx++) {\n              // calculate random position\n              pos = Math.floor(Math.random() * (len - 1));\n\n              if (!LokiOps.$lte(Utils.getIn(this.data[biv[pos]], property, usingDotNotation), Utils.getIn(this.data[biv[pos + 1]], property, usingDotNotation))) {\n                valid = false;\n                break;\n              }\n            }\n          }\n        } else {\n          // validate that the binary index is sequenced properly\n          for (idx = 0; idx < len - 1; idx++) {\n            if (!LokiOps.$lte(Utils.getIn(this.data[biv[idx]], property, usingDotNotation), Utils.getIn(this.data[biv[idx + 1]], property, usingDotNotation))) {\n              valid = false;\n              break;\n            }\n          }\n        }\n      } // if incorrectly sequenced and we are to fix problems, rebuild index\n\n\n      if (!valid && options.repair) {\n        this.ensureIndex(property, true);\n      }\n\n      return valid;\n    };\n\n    Collection.prototype.getBinaryIndexValues = function (property) {\n      var idx,\n          idxvals = this.binaryIndices[property].values;\n      var result = [];\n\n      for (idx = 0; idx < idxvals.length; idx++) {\n        result.push(Utils.getIn(this.data[idxvals[idx]], property, true));\n      }\n\n      return result;\n    };\n    /**\n     * Returns a named unique index\n     * @param {string} field - indexed field name\n     * @param {boolean} force - if `true`, will rebuild index; otherwise, function may return null\n     */\n\n\n    Collection.prototype.getUniqueIndex = function (field, force) {\n      var index = this.constraints.unique[field];\n\n      if (!index && force) {\n        return this.ensureUniqueIndex(field);\n      }\n\n      return index;\n    };\n\n    Collection.prototype.ensureUniqueIndex = function (field) {\n      var index = this.constraints.unique[field];\n\n      if (!index) {\n        // keep track of new unique index for regenerate after database (re)load.\n        if (this.uniqueNames.indexOf(field) == -1) {\n          this.uniqueNames.push(field);\n        }\n      } // if index already existed, (re)loading it will likely cause collisions, rebuild always\n\n\n      this.constraints.unique[field] = index = new UniqueIndex(field);\n      this.data.forEach(function (obj) {\n        index.set(obj);\n      });\n      return index;\n    };\n    /**\n     * Ensure all binary indices\n     * @param {boolean} force - whether to force rebuild of existing lazy binary indices\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.ensureAllIndexes = function (force) {\n      var key,\n          bIndices = this.binaryIndices;\n\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          this.ensureIndex(key, force);\n        }\n      }\n    };\n    /**\n     * Internal method used to flag all lazy index as dirty\n     */\n\n\n    Collection.prototype.flagBinaryIndexesDirty = function () {\n      var key,\n          bIndices = this.binaryIndices;\n\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          bIndices[key].dirty = true;\n        }\n      }\n    };\n    /**\n     * Internal method used to flag a lazy index as dirty\n     */\n\n\n    Collection.prototype.flagBinaryIndexDirty = function (index) {\n      if (this.binaryIndices[index]) this.binaryIndices[index].dirty = true;\n    };\n    /**\n     * Quickly determine number of documents in collection (or query)\n     * @param {object=} query - (optional) query object to count results of\n     * @returns {number} number of documents in the collection\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.count = function (query) {\n      if (!query) {\n        return this.data.length;\n      }\n\n      return this.chain().find(query).filteredrows.length;\n    };\n    /**\n     * Rebuild idIndex\n     */\n\n\n    Collection.prototype.ensureId = function () {\n      if (this.idIndex) {\n        return;\n      }\n\n      var data = this.data,\n          i = 0;\n      var len = data.length;\n      var index = new Array(len);\n\n      for (i; i < len; i++) {\n        index[i] = data[i].$loki;\n      }\n\n      this.idIndex = index;\n    };\n    /**\n     * Rebuild idIndex async with callback - useful for background syncing with a remote server\n     */\n\n\n    Collection.prototype.ensureIdAsync = function (callback) {\n      this.async(function () {\n        this.ensureId();\n      }, callback);\n    };\n    /**\n     * Add a dynamic view to the collection\n     * @param {string} name - name of dynamic view to add\n     * @param {object=} options - options to configure dynamic view with\n     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'\n     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)\n     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n     * @returns {DynamicView} reference to the dynamic view added\n     * @memberof Collection\n     * @example\n     * var pview = users.addDynamicView('progeny');\n     * pview.applyFind({'age': {'$lte': 40}});\n     * pview.applySimpleSort('name');\n     *\n     * var results = pview.data();\n     **/\n\n\n    Collection.prototype.addDynamicView = function (name, options) {\n      var dv = new DynamicView(this, name, options);\n      this.DynamicViews.push(dv);\n      return dv;\n    };\n    /**\n     * Remove a dynamic view from the collection\n     * @param {string} name - name of dynamic view to remove\n     * @memberof Collection\n     **/\n\n\n    Collection.prototype.removeDynamicView = function (name) {\n      this.DynamicViews = this.DynamicViews.filter(function (dv) {\n        return dv.name !== name;\n      });\n    };\n    /**\n     * Look up dynamic view reference from within the collection\n     * @param {string} name - name of dynamic view to retrieve reference of\n     * @returns {DynamicView} A reference to the dynamic view with that name\n     * @memberof Collection\n     **/\n\n\n    Collection.prototype.getDynamicView = function (name) {\n      for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n        if (this.DynamicViews[idx].name === name) {\n          return this.DynamicViews[idx];\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Applies a 'mongo-like' find query object and passes all results to an update function.\n     * For filter function querying you should migrate to [updateWhere()]{@link Collection#updateWhere}.\n     *\n     * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n     * @param {function} updateFunction - update function to run against filtered documents\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.findAndUpdate = function (filterObject, updateFunction) {\n      if (typeof filterObject === \"function\") {\n        this.updateWhere(filterObject, updateFunction);\n      } else {\n        this.chain().find(filterObject).update(updateFunction);\n      }\n    };\n    /**\n     * Applies a 'mongo-like' find query object removes all documents which match that filter.\n     *\n     * @param {object} filterObject - 'mongo-like' query object\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.findAndRemove = function (filterObject) {\n      this.chain().find(filterObject).remove();\n    };\n    /**\n     * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n     * @param {(object|array)} doc - the document (or array of documents) to be inserted\n     * @param {boolean=} overrideAdaptiveIndices - (optional) if `true`, adaptive indicies will be\n     *   temporarily disabled and then fully rebuilt after batch. This will be faster for\n     *   large inserts, but slower for small/medium inserts in large collections\n     * @returns {(object|array)} document or documents inserted\n     * @memberof Collection\n     * @example\n     * users.insert({\n     *     name: 'Odin',\n     *     age: 50,\n     *     address: 'Asgard'\n     * });\n     *\n     * // alternatively, insert array of documents\n     * users.insert([{ name: 'Thor', age: 35}, { name: 'Loki', age: 30}]);\n     */\n\n\n    Collection.prototype.insert = function (doc, overrideAdaptiveIndices) {\n      if (!Array.isArray(doc)) {\n        return this.insertOne(doc);\n      } // holder to the clone of the object inserted if collections is set to clone objects\n\n\n      var obj;\n      var results = []; // if not cloning, disable adaptive binary indices for the duration of the batch insert,\n      // followed by lazy rebuild and re-enabling adaptive indices after batch insert.\n\n      var adaptiveBatchOverride = overrideAdaptiveIndices && !this.cloneObjects && this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;\n\n      if (adaptiveBatchOverride) {\n        this.adaptiveBinaryIndices = false;\n      }\n\n      try {\n        this.emit('pre-insert', doc);\n\n        for (var i = 0, len = doc.length; i < len; i++) {\n          obj = this.insertOne(doc[i], true);\n\n          if (!obj) {\n            return undefined;\n          }\n\n          results.push(obj);\n        }\n      } finally {\n        if (adaptiveBatchOverride) {\n          this.ensureAllIndexes();\n          this.adaptiveBinaryIndices = true;\n        }\n      } // at the 'batch' level, if clone option is true then emitted docs are clones\n\n\n      this.emit('insert', results); // if clone option is set, clone return values\n\n      results = this.cloneObjects ? clone(results, this.cloneMethod) : results;\n      return results.length === 1 ? results[0] : results;\n    };\n    /**\n     * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n     * @param {object} doc - the document to be inserted\n     * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n     * @returns {object} document or 'undefined' if there was a problem inserting it\n     */\n\n\n    Collection.prototype.insertOne = function (doc, bulkInsert) {\n      var err = null;\n      var returnObj;\n\n      if (typeof doc !== 'object') {\n        err = new TypeError('Document needs to be an object');\n      } else if (doc === null) {\n        err = new TypeError('Object cannot be null');\n      }\n\n      if (err !== null) {\n        this.emit('error', err);\n        throw err;\n      } // if configured to clone, do so now... otherwise just use same obj reference\n\n\n      var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n      if (!this.disableFreeze) {\n        obj = unFreeze(obj);\n      }\n\n      if (!this.disableMeta) {\n        if (typeof obj.meta === 'undefined') {\n          obj.meta = {\n            revision: 0,\n            created: 0\n          };\n        } else if (!this.disableFreeze) {\n          obj.meta = unFreeze(obj.meta);\n        }\n      } // both 'pre-insert' and 'insert' events are passed internal data reference even when cloning\n      // insert needs internal reference because that is where loki itself listens to add meta\n\n\n      if (!bulkInsert) {\n        this.emit('pre-insert', obj);\n      }\n\n      if (!this.add(obj)) {\n        return undefined;\n      } // update meta and store changes if ChangesAPI is enabled\n      // (moved from \"insert\" event listener to allow internal reference to be used)\n\n\n      if (this.disableChangesApi) {\n        this.insertMeta(obj);\n      } else {\n        this.insertMetaWithChange(obj);\n      }\n\n      if (!this.disableFreeze) {\n        deepFreeze(obj);\n      } // if cloning is enabled, emit insert event with clone of new object\n\n\n      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\n      if (!bulkInsert) {\n        this.emit('insert', returnObj);\n      }\n\n      this.addAutoUpdateObserver(returnObj);\n      return returnObj;\n    };\n    /**\n     * Empties the collection.\n     * @param {object=} options - configure clear behavior\n     * @param {bool=} [options.removeIndices=false] - whether to remove indices in addition to data\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.clear = function (options) {\n      var self = this;\n      options = options || {};\n      this.data = [];\n      this.idIndex = null;\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n      this.cachedData = null;\n      this.maxId = 0;\n      this.DynamicViews = [];\n      this.dirty = true;\n      this.constraints = {\n        unique: {},\n        exact: {}\n      }; // if removing indices entirely\n\n      if (options.removeIndices === true) {\n        this.binaryIndices = {};\n        this.uniqueNames = [];\n      } // clear indices but leave definitions in place\n      else {\n          // clear binary indices\n          var keys = Object.keys(this.binaryIndices);\n          keys.forEach(function (biname) {\n            self.binaryIndices[biname].dirty = false;\n            self.binaryIndices[biname].values = [];\n          });\n        }\n    };\n    /**\n     * Updates an object and notifies collection that the document has changed.\n     * @param {object} doc - document to update within the collection\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.update = function (doc) {\n      var adaptiveBatchOverride, k, len;\n\n      if (Array.isArray(doc)) {\n        len = doc.length; // if not cloning, disable adaptive binary indices for the duration of the batch update,\n        // followed by lazy rebuild and re-enabling adaptive indices after batch update.\n\n        adaptiveBatchOverride = !this.cloneObjects && this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;\n\n        if (adaptiveBatchOverride) {\n          this.adaptiveBinaryIndices = false;\n        }\n\n        try {\n          for (k = 0; k < len; k += 1) {\n            this.update(doc[k]);\n          }\n        } finally {\n          if (adaptiveBatchOverride) {\n            this.ensureAllIndexes();\n            this.adaptiveBinaryIndices = true;\n          }\n        }\n\n        return;\n      } // verify object is a properly formed document\n\n\n      if (!hasOwnProperty.call(doc, '$loki')) {\n        throw new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n      }\n\n      try {\n        this.startTransaction();\n        var arr = this.get(doc.$loki, true),\n            oldInternal,\n            // ref to existing obj\n        newInternal,\n            // ref to new internal obj\n        position,\n            self = this;\n\n        if (!arr) {\n          throw new Error('Trying to update a document not in collection.');\n        }\n\n        oldInternal = arr[0]; // -internal- obj ref\n\n        position = arr[1]; // position in data array\n        // if configured to clone, do so now... otherwise just use same obj reference\n\n        newInternal = this.cloneObjects || !this.disableDeltaChangesApi && this.disableFreeze ? clone(doc, this.cloneMethod) : doc;\n        this.emit('pre-update', doc);\n        this.uniqueNames.forEach(function (key) {\n          self.getUniqueIndex(key, true).update(oldInternal, newInternal);\n        }); // operate the update\n\n        this.data[position] = newInternal;\n\n        if (newInternal !== doc) {\n          this.addAutoUpdateObserver(doc);\n        } // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\n\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].evaluateDocument(position, false);\n        }\n\n        var key;\n\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var bIndices = this.binaryIndices;\n\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexUpdate(position, key);\n          }\n        } else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.idIndex[position] = newInternal.$loki; //this.flagBinaryIndexesDirty();\n\n        if (this.isIncremental) {\n          this.dirtyIds.push(newInternal.$loki);\n        }\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n        // update meta and store changes if ChangesAPI is enabled\n\n        if (this.disableChangesApi) {\n          newInternal = this.updateMeta(newInternal);\n        } else {\n          newInternal = this.updateMetaWithChange(newInternal, oldInternal);\n        }\n\n        if (!this.disableFreeze) {\n          deepFreeze(newInternal);\n        }\n\n        var returnObj; // if cloning is enabled, emit 'update' event and return with clone of new object\n\n        if (this.cloneObjects) {\n          returnObj = clone(newInternal, this.cloneMethod);\n        } else {\n          returnObj = newInternal;\n        }\n\n        this.emit('update', returnObj, oldInternal);\n        return returnObj;\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        throw err; // re-throw error so user does not think it succeeded\n      }\n    };\n    /**\n     * Add object to collection\n     */\n\n\n    Collection.prototype.add = function (obj) {\n      // if parameter isn't object exit with throw\n      if ('object' !== typeof obj) {\n        throw new TypeError('Object being added needs to be an object');\n      } // if object you are adding already has id column it is either already in the collection\n      // or the object is carrying its own 'id' property.  If it also has a meta property,\n      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\n\n      if (typeof obj.$loki !== 'undefined') {\n        throw new Error('Document is already in collection, please use update()');\n      }\n      /*\n       * try adding object to collection\n       */\n\n\n      try {\n        this.startTransaction();\n        this.maxId++;\n\n        if (isNaN(this.maxId)) {\n          this.maxId = this.data[this.data.length - 1].$loki + 1;\n        }\n\n        var newId = this.maxId;\n        obj.$loki = newId;\n\n        if (!this.disableMeta) {\n          obj.meta.version = 0;\n        }\n\n        for (var i = 0, len = this.uniqueNames.length; i < len; i++) {\n          this.getUniqueIndex(this.uniqueNames[i], true).set(obj);\n        }\n\n        if (this.idIndex) {\n          this.idIndex.push(newId);\n        }\n\n        if (this.isIncremental) {\n          this.dirtyIds.push(newId);\n        } // add the object\n\n\n        this.data.push(obj);\n        var addedPos = this.data.length - 1; // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\n        var dvlen = this.DynamicViews.length;\n\n        for (i = 0; i < dvlen; i++) {\n          this.DynamicViews[i].evaluateDocument(addedPos, true);\n        }\n\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var bIndices = this.binaryIndices;\n\n          for (var key in bIndices) {\n            this.adaptiveBinaryIndexInsert(addedPos, key);\n          }\n        } else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n\n        return this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        throw err; // re-throw error so user does not think it succeeded\n      }\n    };\n    /**\n     * Applies a filter function and passes all results to an update function.\n     *\n     * @param {function} filterFunction - filter function whose results will execute update\n     * @param {function} updateFunction - update function to run against filtered documents\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.updateWhere = function (filterFunction, updateFunction) {\n      var results = this.where(filterFunction),\n          i = 0,\n          obj;\n\n      try {\n        for (i; i < results.length; i++) {\n          obj = updateFunction(results[i]);\n          this.update(obj);\n        }\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n      }\n    };\n    /**\n     * Remove all documents matching supplied filter function.\n     * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n     * @param {function|object} query - query object to filter on\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.removeWhere = function (query) {\n      var list;\n\n      if (typeof query === 'function') {\n        list = this.data.filter(query);\n        this.remove(list);\n      } else {\n        this.chain().find(query).remove();\n      }\n    };\n\n    Collection.prototype.removeDataOnly = function () {\n      this.remove(this.data.slice());\n    };\n    /**\n     * Internal method to remove a batch of documents from the collection.\n     * @param {number[]} positions - data/idIndex positions to remove\n     */\n\n\n    Collection.prototype.removeBatchByPositions = function (positions) {\n      var len = positions.length;\n      var xo = {};\n      var dlen, didx, idx;\n      var bic = Object.keys(this.binaryIndices).length;\n      var uic = Object.keys(this.constraints.unique).length;\n      var adaptiveOverride = this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;\n      var doc,\n          self = this;\n\n      try {\n        this.startTransaction(); // create hashobject for positional removal inclusion tests...\n        // all keys defined in this hashobject represent $loki ids of the documents to remove.\n\n        this.ensureId();\n\n        for (idx = 0; idx < len; idx++) {\n          xo[this.idIndex[positions[idx]]] = true;\n        } // if we will need to notify dynamic views and/or binary indices to update themselves...\n\n\n        dlen = this.DynamicViews.length;\n\n        if (dlen > 0 || bic > 0 || uic > 0) {\n          if (dlen > 0) {\n            // notify dynamic views to remove relevant documents at data positions\n            for (didx = 0; didx < dlen; didx++) {\n              // notify dv of remove (passing batch/array of positions)\n              this.DynamicViews[didx].removeDocument(positions);\n            }\n          } // notify binary indices to update\n\n\n          if (this.adaptiveBinaryIndices && !adaptiveOverride) {\n            // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n            var key,\n                bIndices = this.binaryIndices;\n\n            for (key in bIndices) {\n              this.adaptiveBinaryIndexRemove(positions, key);\n            }\n          } else {\n            this.flagBinaryIndexesDirty();\n          }\n\n          if (uic) {\n            this.uniqueNames.forEach(function (key) {\n              var index = self.getUniqueIndex(key);\n\n              if (index) {\n                for (idx = 0; idx < len; idx++) {\n                  doc = self.data[positions[idx]];\n\n                  if (doc[key] !== null && doc[key] !== undefined) {\n                    index.remove(doc[key]);\n                  }\n                }\n              }\n            });\n          }\n        } // emit 'delete' events only of listeners are attached.\n        // since data not removed yet, in future we can emit single delete event with array...\n        // for now that might be breaking change to put in potential 1.6 or LokiDB (lokijs2) version\n\n\n        if (!this.disableChangesApi || this.events.delete.length > 1) {\n          for (idx = 0; idx < len; idx++) {\n            this.emit('delete', this.data[positions[idx]]);\n          }\n        } // remove from data[] :\n        // filter collection data for items not in inclusion hashobject\n\n\n        this.data = this.data.filter(function (obj) {\n          return !xo[obj.$loki];\n        });\n\n        if (this.isIncremental) {\n          for (idx = 0; idx < len; idx++) {\n            this.dirtyIds.push(this.idIndex[positions[idx]]);\n          }\n        } // remove from idIndex[] :\n        // filter idIndex for items not in inclusion hashobject\n\n\n        this.idIndex = this.idIndex.filter(function (id) {\n          return !xo[id];\n        });\n\n        if (this.adaptiveBinaryIndices && adaptiveOverride) {\n          this.adaptiveBinaryIndices = false;\n          this.ensureAllIndexes(true);\n          this.adaptiveBinaryIndices = true;\n        }\n\n        this.commit(); // flag collection as dirty for autosave\n\n        this.dirty = true;\n      } catch (err) {\n        this.rollback();\n\n        if (adaptiveOverride) {\n          this.adaptiveBinaryIndices = true;\n        }\n\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        return null;\n      }\n    };\n    /**\n     *  Internal method called by remove()\n     * @param {object[]|number[]} batch - array of documents or $loki ids to remove\n     */\n\n\n    Collection.prototype.removeBatch = function (batch) {\n      var len = batch.length,\n          dlen = this.data.length,\n          idx;\n      var xlt = {};\n      var posx = []; // create lookup hashobject to translate $loki id to position\n\n      for (idx = 0; idx < dlen; idx++) {\n        xlt[this.data[idx].$loki] = idx;\n      } // iterate the batch\n\n\n      for (idx = 0; idx < len; idx++) {\n        if (typeof batch[idx] === 'object') {\n          posx.push(xlt[batch[idx].$loki]);\n        } else {\n          posx.push(xlt[batch[idx]]);\n        }\n      }\n\n      this.removeBatchByPositions(posx);\n    };\n    /**\n     * Remove a document from the collection\n     * @param {object} doc - document to remove from collection\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.remove = function (doc) {\n      var frozen;\n\n      if (typeof doc === 'number') {\n        doc = this.get(doc);\n      }\n\n      if ('object' !== typeof doc) {\n        throw new Error('Parameter is not an object');\n      }\n\n      if (Array.isArray(doc)) {\n        this.removeBatch(doc);\n        return;\n      }\n\n      if (!hasOwnProperty.call(doc, '$loki')) {\n        throw new Error('Object is not a document stored in the collection');\n      }\n\n      try {\n        this.startTransaction();\n        var arr = this.get(doc.$loki, true),\n            // obj = arr[0],\n        position = arr[1];\n        var self = this;\n        this.uniqueNames.forEach(function (key) {\n          if (doc[key] !== null && typeof doc[key] !== 'undefined') {\n            var index = self.getUniqueIndex(key);\n\n            if (index) {\n              index.remove(doc[key]);\n            }\n          }\n        }); // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to remove\n\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].removeDocument(position);\n        }\n\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var key,\n              bIndices = this.binaryIndices;\n\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexRemove(position, key);\n          }\n        } else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.data.splice(position, 1);\n        this.removeAutoUpdateObserver(doc); // remove id from idIndex\n\n        this.idIndex.splice(position, 1);\n\n        if (this.isIncremental) {\n          this.dirtyIds.push(doc.$loki);\n        }\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n\n        this.emit('delete', arr[0]);\n\n        if (!this.disableFreeze) {\n          doc = unFreeze(doc);\n        }\n\n        delete doc.$loki;\n        delete doc.meta;\n\n        if (!this.disableFreeze) {\n          freeze(doc);\n        }\n\n        return doc;\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        return null;\n      }\n    };\n    /*---------------------+\n    | Finding methods     |\n    +----------------------*/\n\n    /**\n     * Get by Id - faster than other methods because of the searching algorithm\n     * @param {int} id - $loki id of document you want to retrieve\n     * @param {boolean} returnPosition - if 'true' we will return [object, position]\n     * @returns {(object|array|null)} Object reference if document was found, null if not,\n     *     or an array if 'returnPosition' was passed.\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.get = function (id, returnPosition) {\n      if (!this.idIndex) {\n        this.ensureId();\n      }\n\n      var retpos = returnPosition || false,\n          data = this.idIndex,\n          max = data.length - 1,\n          min = 0,\n          mid = min + max >> 1;\n      id = typeof id === 'number' ? id : parseInt(id, 10);\n\n      if (isNaN(id)) {\n        throw new TypeError('Passed id is not an integer');\n      }\n\n      while (data[min] < data[max]) {\n        mid = min + max >> 1;\n\n        if (data[mid] < id) {\n          min = mid + 1;\n        } else {\n          max = mid;\n        }\n      }\n\n      if (max === min && data[min] === id) {\n        if (retpos) {\n          return [this.data[min], min];\n        }\n\n        return this.data[min];\n      }\n\n      return null;\n    };\n    /**\n     * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n     *    Since multiple documents may contain the same value (which the index is sorted on),\n     *    we hone in on range and then linear scan range to find exact index array position.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n\n\n    Collection.prototype.getBinaryIndexPosition = function (dataPosition, binaryIndexName) {\n      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, true);\n      var index = this.binaryIndices[binaryIndexName].values; // i think calculateRange can probably be moved to collection\n      // as it doesn't seem to need resultset.  need to verify\n\n      var range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n      if (range[0] === 0 && range[1] === -1) {\n        // uhoh didn't find range\n        return null;\n      }\n\n      var min = range[0];\n      var max = range[1]; // narrow down the sub-segment of index values\n      // where the indexed property value exactly matches our\n      // value and then linear scan to find exact -index- position\n\n      for (var idx = min; idx <= max; idx++) {\n        if (index[idx] === dataPosition) return idx;\n      } // uhoh\n\n\n      return null;\n    };\n    /**\n     * Adaptively insert a selected item to the index.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n\n\n    Collection.prototype.adaptiveBinaryIndexInsert = function (dataPosition, binaryIndexName) {\n      var usingDotNotation = binaryIndexName.indexOf('.') !== -1;\n      var index = this.binaryIndices[binaryIndexName].values;\n      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, usingDotNotation); // If you are inserting a javascript Date value into a binary index, convert to epoch time\n\n      if (this.serializableIndices === true && val instanceof Date) {\n        this.data[dataPosition][binaryIndexName] = val.getTime();\n        val = Utils.getIn(this.data[dataPosition], binaryIndexName);\n      }\n\n      var idxPos = index.length === 0 ? 0 : this.calculateRangeStart(binaryIndexName, val, true, usingDotNotation); // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n      // doing this after adjusting dataPositions so no clash with previous item at that position.\n\n      this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n    };\n    /**\n     * Adaptively update a selected item within an index.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n\n\n    Collection.prototype.adaptiveBinaryIndexUpdate = function (dataPosition, binaryIndexName) {\n      // linear scan needed to find old position within index unless we optimize for clone scenarios later\n      // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n      var idxPos,\n          index = this.binaryIndices[binaryIndexName].values,\n          len = index.length;\n\n      for (idxPos = 0; idxPos < len; idxPos++) {\n        if (index[idxPos] === dataPosition) break;\n      } //var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\n\n      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1); //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\n      this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n    };\n    /**\n     * Adaptively remove a selected item from the index.\n     * @param {number|number[]} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n\n\n    Collection.prototype.adaptiveBinaryIndexRemove = function (dataPosition, binaryIndexName, removedFromIndexOnly) {\n      var bi = this.binaryIndices[binaryIndexName];\n      var len,\n          idx,\n          rmidx,\n          rmlen,\n          rxo = {};\n      var curr, shift, idxPos;\n\n      if (Array.isArray(dataPosition)) {\n        // when called from chained remove, and only one document in array,\n        // it will be faster to use old algorithm\n        rmlen = dataPosition.length;\n\n        if (rmlen === 1) {\n          dataPosition = dataPosition[0];\n        } // we were passed an array (batch) of documents so use this 'batch optimized' algorithm\n        else {\n            for (rmidx = 0; rmidx < rmlen; rmidx++) {\n              rxo[dataPosition[rmidx]] = true;\n            } // remove document from index (with filter function)\n\n\n            bi.values = bi.values.filter(function (di) {\n              return !rxo[di];\n            }); // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n            // in which case data positions stay the same.\n\n            if (removedFromIndexOnly === true) {\n              return;\n            }\n\n            var sortedPositions = dataPosition.slice();\n            sortedPositions.sort(function (a, b) {\n              return a - b;\n            }); // to remove holes, we need to 'shift down' the index's data array positions\n            // we need to adjust array positions -1 for each index data positions greater than removed positions\n\n            len = bi.values.length;\n\n            for (idx = 0; idx < len; idx++) {\n              curr = bi.values[idx];\n              shift = 0;\n\n              for (rmidx = 0; rmidx < rmlen && curr > sortedPositions[rmidx]; rmidx++) {\n                shift++;\n              }\n\n              bi.values[idx] -= shift;\n            } // batch processed, bail out\n\n\n            return;\n          } // not a batch so continue...\n\n      }\n\n      idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\n      if (idxPos === null) {\n        // throw new Error('unable to determine binary index position');\n        return null;\n      } // remove document from index (with splice)\n\n\n      bi.values.splice(idxPos, 1); // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n      // in which case data positions stay the same.\n\n      if (removedFromIndexOnly === true) {\n        return;\n      } // since index stores data array positions, if we remove a document\n      // we need to adjust array positions -1 for all document positions greater than removed position\n\n\n      len = bi.values.length;\n\n      for (idx = 0; idx < len; idx++) {\n        if (bi.values[idx] > dataPosition) {\n          bi.values[idx]--;\n        }\n      }\n    };\n    /**\n     * Internal method used for index maintenance and indexed searching.\n     * Calculates the beginning of an index range for a given value.\n     * For index maintainance (adaptive:true), we will return a valid index position to insert to.\n     * For querying (adaptive:false/undefined), we will :\n     *    return lower bound/index of range of that value (if found)\n     *    return next lower index position if not found (hole)\n     * If index is empty it is assumed to be handled at higher level, so\n     * this method assumes there is at least 1 document in index.\n     *\n     * @param {string} prop - name of property which has binary index\n     * @param {any} val - value to find within index\n     * @param {bool?} adaptive - if true, we will return insert position\n     */\n\n\n    Collection.prototype.calculateRangeStart = function (prop, val, adaptive, usingDotNotation) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n\n      if (index.length === 0) {\n        return -1;\n      }\n\n      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);\n      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation); // hone in on start position of value\n\n      while (min < max) {\n        mid = min + max >> 1;\n\n        if (Comparators.lt(Utils.getIn(rcd[index[mid]], prop, usingDotNotation), val, false)) {\n          min = mid + 1;\n        } else {\n          max = mid;\n        }\n      }\n\n      var lbound = min; // found it... return it\n\n      if (Comparators.aeq(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation))) {\n        return lbound;\n      } // if not in index and our value is less than the found one\n\n\n      if (Comparators.lt(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), false)) {\n        return adaptive ? lbound : lbound - 1;\n      } // not in index and our value is greater than the found one\n\n\n      return adaptive ? lbound + 1 : lbound;\n    };\n    /**\n     * Internal method used for indexed $between.  Given a prop (index name), and a value\n     * (which may or may not yet exist) this will find the final position of that upper range value.\n     */\n\n\n    Collection.prototype.calculateRangeEnd = function (prop, val, usingDotNotation) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n\n      if (index.length === 0) {\n        return -1;\n      }\n\n      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);\n      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation); // hone in on start position of value\n\n      while (min < max) {\n        mid = min + max >> 1;\n\n        if (Comparators.lt(val, Utils.getIn(rcd[index[mid]], prop, usingDotNotation), false)) {\n          max = mid;\n        } else {\n          min = mid + 1;\n        }\n      }\n\n      var ubound = max; // only eq if last element in array is our val\n\n      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation))) {\n        return ubound;\n      } // if not in index and our value is less than the found one\n\n\n      if (Comparators.gt(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), false)) {\n        return ubound + 1;\n      } // either hole or first nonmatch\n\n\n      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound - 1]], prop, usingDotNotation))) {\n        return ubound - 1;\n      } // hole, so ubound if nearest gt than the val we were looking for\n\n\n      return ubound;\n    };\n    /**\n     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n     *    this is used for collection.find() and first find filter of resultset/dynview\n     *    slightly different than get() binary search in that get() hones in on 1 value,\n     *    but we have to hone in on many (range)\n     * @param {string} op - operation, such as $eq\n     * @param {string} prop - name of property to calculate range for\n     * @param {object} val - value to use for range calculation.\n     * @returns {array} [start, end] index array positions\n     */\n\n\n    Collection.prototype.calculateRange = function (op, prop, val) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n      var lbound, lval;\n      var ubound, uval; // when no documents are in collection, return empty range condition\n\n      if (rcd.length === 0) {\n        return [0, -1];\n      }\n\n      var usingDotNotation = prop.indexOf('.') !== -1;\n      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);\n      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation); // if value falls outside of our range return [0, -1] to designate no results\n\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {\n            return [0, -1];\n          }\n\n          break;\n\n        case '$dteq':\n          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {\n            return [0, -1];\n          }\n\n          break;\n\n        case '$gt':\n          // none are within range\n          if (Comparators.gt(val, maxVal, true)) {\n            return [0, -1];\n          } // all are within range\n\n\n          if (Comparators.gt(minVal, val, false)) {\n            return [min, max];\n          }\n\n          break;\n\n        case '$gte':\n          // none are within range\n          if (Comparators.gt(val, maxVal, false)) {\n            return [0, -1];\n          } // all are within range\n\n\n          if (Comparators.gt(minVal, val, true)) {\n            return [min, max];\n          }\n\n          break;\n\n        case '$lt':\n          // none are within range\n          if (Comparators.lt(val, minVal, true)) {\n            return [0, -1];\n          } // all are within range\n\n\n          if (Comparators.lt(maxVal, val, false)) {\n            return [min, max];\n          }\n\n          break;\n\n        case '$lte':\n          // none are within range\n          if (Comparators.lt(val, minVal, false)) {\n            return [0, -1];\n          } // all are within range\n\n\n          if (Comparators.lt(maxVal, val, true)) {\n            return [min, max];\n          }\n\n          break;\n\n        case '$between':\n          // none are within range (low range is greater)\n          if (Comparators.gt(val[0], maxVal, false)) {\n            return [0, -1];\n          } // none are within range (high range lower)\n\n\n          if (Comparators.lt(val[1], minVal, false)) {\n            return [0, -1];\n          }\n\n          lbound = this.calculateRangeStart(prop, val[0], false, usingDotNotation);\n          ubound = this.calculateRangeEnd(prop, val[1], usingDotNotation);\n          if (lbound < 0) lbound++;\n          if (ubound > max) ubound--;\n          if (!Comparators.gt(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val[0], true)) lbound++;\n          if (!Comparators.lt(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val[1], true)) ubound--;\n          if (ubound < lbound) return [0, -1];\n          return [lbound, ubound];\n\n        case '$in':\n          var idxset = [],\n              segResult = []; // query each value '$eq' operator and merge the seqment results.\n\n          for (var j = 0, len = val.length; j < len; j++) {\n            var seg = this.calculateRange('$eq', prop, val[j]);\n\n            for (var i = seg[0]; i <= seg[1]; i++) {\n              if (idxset[i] === undefined) {\n                idxset[i] = true;\n                segResult.push(i);\n              }\n            }\n          }\n\n          return segResult;\n      } // determine lbound where needed\n\n\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n        case '$dteq':\n        case '$gte':\n        case '$lt':\n          lbound = this.calculateRangeStart(prop, val, false, usingDotNotation);\n          lval = Utils.getIn(rcd[index[lbound]], prop, usingDotNotation);\n          break;\n\n        default:\n          break;\n      } // determine ubound where needed\n\n\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n        case '$dteq':\n        case '$lte':\n        case '$gt':\n          ubound = this.calculateRangeEnd(prop, val, usingDotNotation);\n          uval = Utils.getIn(rcd[index[ubound]], prop, usingDotNotation);\n          break;\n\n        default:\n          break;\n      }\n\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n        case '$dteq':\n          // if hole (not found)\n          if (!Comparators.aeq(lval, val)) {\n            return [0, -1];\n          }\n\n          return [lbound, ubound];\n\n        case '$gt':\n          // if hole (not found) ub position is already greater\n          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {\n            return [ubound, max];\n          } // otherwise (found) so ubound is still equal, get next\n\n\n          return [ubound + 1, max];\n\n        case '$gte':\n          // if hole (not found) lb position marks left outside of range\n          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {\n            return [lbound + 1, max];\n          } // otherwise (found) so lb is first position where its equal\n\n\n          return [lbound, max];\n\n        case '$lt':\n          // if hole (not found) position already is less than\n          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {\n            return [min, lbound];\n          } // otherwise (found) so lb marks left inside of eq range, get previous\n\n\n          return [min, lbound - 1];\n\n        case '$lte':\n          // if hole (not found) ub position marks right outside so get previous\n          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {\n            return [min, ubound - 1];\n          } // otherwise (found) so ub is last position where its still equal\n\n\n          return [min, ubound];\n\n        default:\n          return [0, rcd.length - 1];\n      }\n    };\n    /**\n     * Retrieve doc by Unique index\n     * @param {string} field - name of uniquely indexed property to use when doing lookup\n     * @param {value} value - unique value to search for\n     * @returns {object} document matching the value passed\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.by = function (field, value) {\n      var self;\n\n      if (value === undefined) {\n        self = this;\n        return function (value) {\n          return self.by(field, value);\n        };\n      }\n\n      var result = this.getUniqueIndex(field, true).get(value);\n\n      if (!this.cloneObjects) {\n        return result;\n      } else {\n        return clone(result, this.cloneMethod);\n      }\n    };\n    /**\n     * Find one object by index property, by property equal to value\n     * @param {object} query - query object used to perform search with\n     * @returns {(object|null)} First matching document, or null if none\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.findOne = function (query) {\n      query = query || {}; // Instantiate Resultset and exec find op passing firstOnly = true param\n\n      var result = this.chain().find(query, true).data();\n\n      if (Array.isArray(result) && result.length === 0) {\n        return null;\n      } else {\n        if (!this.cloneObjects) {\n          return result[0];\n        } else {\n          return clone(result[0], this.cloneMethod);\n        }\n      }\n    };\n    /**\n     * Chain method, used for beginning a series of chained find() and/or view() operations\n     * on a collection.\n     *\n     * @param {string|array=} transform - named transform or array of transform steps\n     * @param {object=} parameters - Object containing properties representing parameters to substitute\n     * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.chain = function (transform, parameters) {\n      var rs = new Resultset(this);\n\n      if (typeof transform === 'undefined') {\n        return rs;\n      }\n\n      return rs.transform(transform, parameters);\n    };\n    /**\n     * Find method, api is similar to mongodb.\n     * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n     * @example {@tutorial Query Examples}\n     * @param {object} query - 'mongo-like' query object\n     * @returns {array} Array of matching documents\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.find = function (query) {\n      return this.chain().find(query).data();\n    };\n    /**\n     * Find object by unindexed field by property equal to value,\n     * simply iterates and returns the first element matching the query\n     */\n\n\n    Collection.prototype.findOneUnindexed = function (prop, value) {\n      var i = this.data.length,\n          doc;\n\n      while (i--) {\n        if (Utils.getIn(this.data[i], prop, true) === value) {\n          doc = this.data[i];\n          return doc;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Transaction methods\n     */\n\n    /** start the transation */\n\n\n    Collection.prototype.startTransaction = function () {\n      if (this.transactional) {\n        this.cachedData = clone(this.data, this.cloneMethod);\n        this.cachedIndex = this.idIndex;\n        this.cachedBinaryIndex = this.binaryIndices;\n        this.cachedDirtyIds = this.dirtyIds; // propagate startTransaction to dynamic views\n\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].startTransaction();\n        }\n      }\n    };\n    /** commit the transation */\n\n\n    Collection.prototype.commit = function () {\n      if (this.transactional) {\n        this.cachedData = null;\n        this.cachedIndex = null;\n        this.cachedBinaryIndex = null;\n        this.cachedDirtyIds = null; // propagate commit to dynamic views\n\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].commit();\n        }\n      }\n    };\n    /** roll back the transation */\n\n\n    Collection.prototype.rollback = function () {\n      if (this.transactional) {\n        if (this.cachedData !== null && this.cachedIndex !== null) {\n          this.data = this.cachedData;\n          this.idIndex = this.cachedIndex;\n          this.binaryIndices = this.cachedBinaryIndex;\n          this.dirtyIds = this.cachedDirtyIds;\n        } // propagate rollback to dynamic views\n\n\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].rollback();\n        }\n      }\n    }; // async executor. This is only to enable callbacks at the end of the execution.\n\n\n    Collection.prototype.async = function (fun, callback) {\n      setTimeout(function () {\n        if (typeof fun === 'function') {\n          fun();\n          callback();\n        } else {\n          throw new TypeError('Argument passed for async execution is not a function');\n        }\n      }, 0);\n    };\n    /**\n     * Query the collection by supplying a javascript filter function.\n     * @example\n     * var results = coll.where(function(obj) {\n     *   return obj.legs === 8;\n     * });\n     *\n     * @param {function} fun - filter function to run against all collection docs\n     * @returns {array} all documents which pass your filter function\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.where = function (fun) {\n      return this.chain().where(fun).data();\n    };\n    /**\n     * Map Reduce operation\n     *\n     * @param {function} mapFunction - function to use as map function\n     * @param {function} reduceFunction - function to use as reduce function\n     * @returns {data} The result of your mapReduce operation\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data.map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n    /**\n     * Join two collections on specified properties\n     *\n     * @param {array|Resultset|Collection} joinData - array of documents to 'join' to this collection\n     * @param {string} leftJoinProp - property name in collection\n     * @param {string} rightJoinProp - property name in joinData\n     * @param {function=} mapFun - (Optional) map function to use\n     * @param {object=} dataOptions - options to data() before input to your map function\n     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     * @returns {Resultset} Result of the mapping operation\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions) {\n      // logic in Resultset class\n      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions);\n    };\n    /* ------ STAGING API -------- */\n\n    /**\n     * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n     * manipulated without affecting the data in the original collection\n     */\n\n\n    Collection.prototype.stages = {};\n    /**\n     * (Staging API) create a stage and/or retrieve it\n     * @memberof Collection\n     */\n\n    Collection.prototype.getStage = function (name) {\n      if (!this.stages[name]) {\n        this.stages[name] = {};\n      }\n\n      return this.stages[name];\n    };\n    /**\n     * a collection of objects recording the changes applied through a commmitStage\n     */\n\n\n    Collection.prototype.commitLog = [];\n    /**\n     * (Staging API) create a copy of an object and insert it into a stage\n     * @memberof Collection\n     */\n\n    Collection.prototype.stage = function (stageName, obj) {\n      var copy = JSON.parse(JSON.stringify(obj));\n      this.getStage(stageName)[obj.$loki] = copy;\n      return copy;\n    };\n    /**\n     * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n     * then create a message to be inserted in the commitlog\n     * @param {string} stageName - name of stage\n     * @param {string} message\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.commitStage = function (stageName, message) {\n      var stage = this.getStage(stageName),\n          prop,\n          timestamp = new Date().getTime();\n\n      for (prop in stage) {\n        this.update(stage[prop]);\n        this.commitLog.push({\n          timestamp: timestamp,\n          message: message,\n          data: JSON.parse(JSON.stringify(stage[prop]))\n        });\n      }\n\n      this.stages[stageName] = {};\n    };\n\n    Collection.prototype.no_op = function () {\n      return;\n    };\n    /**\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.extract = function (field) {\n      var i = 0,\n          len = this.data.length,\n          isDotNotation = isDeepProperty(field),\n          result = [];\n\n      for (i; i < len; i += 1) {\n        result.push(deepProperty(this.data[i], field, isDotNotation));\n      }\n\n      return result;\n    };\n    /**\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.max = function (field) {\n      return Math.max.apply(null, this.extract(field));\n    };\n    /**\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.min = function (field) {\n      return Math.min.apply(null, this.extract(field));\n    };\n    /**\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.maxRecord = function (field) {\n      var i = 0,\n          len = this.data.length,\n          deep = isDeepProperty(field),\n          result = {\n        index: 0,\n        value: undefined\n      },\n          max;\n\n      for (i; i < len; i += 1) {\n        if (max !== undefined) {\n          if (max < deepProperty(this.data[i], field, deep)) {\n            max = deepProperty(this.data[i], field, deep);\n            result.index = this.data[i].$loki;\n          }\n        } else {\n          max = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      }\n\n      result.value = max;\n      return result;\n    };\n    /**\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.minRecord = function (field) {\n      var i = 0,\n          len = this.data.length,\n          deep = isDeepProperty(field),\n          result = {\n        index: 0,\n        value: undefined\n      },\n          min;\n\n      for (i; i < len; i += 1) {\n        if (min !== undefined) {\n          if (min > deepProperty(this.data[i], field, deep)) {\n            min = deepProperty(this.data[i], field, deep);\n            result.index = this.data[i].$loki;\n          }\n        } else {\n          min = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      }\n\n      result.value = min;\n      return result;\n    };\n    /**\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.extractNumerical = function (field) {\n      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n        return !isNaN(n);\n      });\n    };\n    /**\n     * Calculates the average numerical value of a property\n     *\n     * @param {string} field - name of property in docs to average\n     * @returns {number} average of property in all docs in the collection\n     * @memberof Collection\n     */\n\n\n    Collection.prototype.avg = function (field) {\n      return average(this.extractNumerical(field));\n    };\n    /**\n     * Calculate standard deviation of a field\n     * @memberof Collection\n     * @param {string} field\n     */\n\n\n    Collection.prototype.stdDev = function (field) {\n      return standardDeviation(this.extractNumerical(field));\n    };\n    /**\n     * @memberof Collection\n     * @param {string} field\n     */\n\n\n    Collection.prototype.mode = function (field) {\n      var dict = {},\n          data = this.extract(field);\n      data.forEach(function (obj) {\n        if (dict[obj]) {\n          dict[obj] += 1;\n        } else {\n          dict[obj] = 1;\n        }\n      });\n      var max, prop, mode;\n\n      for (prop in dict) {\n        if (max) {\n          if (max < dict[prop]) {\n            mode = prop;\n          }\n        } else {\n          mode = prop;\n          max = dict[prop];\n        }\n      }\n\n      return mode;\n    };\n    /**\n     * @memberof Collection\n     * @param {string} field - property name\n     */\n\n\n    Collection.prototype.median = function (field) {\n      var values = this.extractNumerical(field);\n      values.sort(sub);\n      var half = Math.floor(values.length / 2);\n\n      if (values.length % 2) {\n        return values[half];\n      } else {\n        return (values[half - 1] + values[half]) / 2.0;\n      }\n    };\n    /**\n     * General utils, including statistical functions\n     */\n\n\n    function isDeepProperty(field) {\n      return field.indexOf('.') !== -1;\n    }\n\n    function parseBase10(num) {\n      return parseFloat(num, 10);\n    }\n\n    function isNotUndefined(obj) {\n      return obj !== undefined;\n    }\n\n    function add(a, b) {\n      return a + b;\n    }\n\n    function sub(a, b) {\n      return a - b;\n    }\n\n    function median(values) {\n      values.sort(sub);\n      var half = Math.floor(values.length / 2);\n      return values.length % 2 ? values[half] : (values[half - 1] + values[half]) / 2.0;\n    }\n\n    function average(array) {\n      return array.reduce(add, 0) / array.length;\n    }\n\n    function standardDeviation(values) {\n      var avg = average(values);\n      var squareDiffs = values.map(function (value) {\n        var diff = value - avg;\n        var sqrDiff = diff * diff;\n        return sqrDiff;\n      });\n      var avgSquareDiff = average(squareDiffs);\n      var stdDev = Math.sqrt(avgSquareDiff);\n      return stdDev;\n    }\n\n    function deepProperty(obj, property, isDeep) {\n      if (isDeep === false) {\n        // pass without processing\n        return obj[property];\n      }\n\n      var pieces = property.split('.'),\n          root = obj;\n\n      while (pieces.length > 0) {\n        root = root[pieces.shift()];\n      }\n\n      return root;\n    }\n\n    function binarySearch(array, item, fun) {\n      var lo = 0,\n          hi = array.length,\n          compared,\n          mid;\n\n      while (lo < hi) {\n        mid = lo + hi >> 1;\n        compared = fun.apply(null, [item, array[mid]]);\n\n        if (compared === 0) {\n          return {\n            found: true,\n            index: mid\n          };\n        } else if (compared < 0) {\n          hi = mid;\n        } else {\n          lo = mid + 1;\n        }\n      }\n\n      return {\n        found: false,\n        index: hi\n      };\n    }\n\n    function BSonSort(fun) {\n      return function (array, item) {\n        return binarySearch(array, item, fun);\n      };\n    }\n\n    function KeyValueStore() {}\n\n    KeyValueStore.prototype = {\n      keys: [],\n      values: [],\n      sort: function sort(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n      },\n      setSort: function setSort(fun) {\n        this.bs = new BSonSort(fun);\n      },\n      bs: function bs() {\n        return new BSonSort(this.sort);\n      },\n      set: function set(key, value) {\n        var pos = this.bs(this.keys, key);\n\n        if (pos.found) {\n          this.values[pos.index] = value;\n        } else {\n          this.keys.splice(pos.index, 0, key);\n          this.values.splice(pos.index, 0, value);\n        }\n      },\n      get: function get(key) {\n        return this.values[binarySearch(this.keys, key, this.sort).index];\n      }\n    };\n\n    function UniqueIndex(uniqueField) {\n      this.field = uniqueField;\n      this.keyMap = Object.create(null);\n      this.lokiMap = Object.create(null);\n    }\n\n    UniqueIndex.prototype.keyMap = {};\n    UniqueIndex.prototype.lokiMap = {};\n\n    UniqueIndex.prototype.set = function (obj) {\n      var fieldValue = obj[this.field];\n\n      if (fieldValue !== null && typeof fieldValue !== 'undefined') {\n        if (this.keyMap[fieldValue]) {\n          throw new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n        } else {\n          this.keyMap[fieldValue] = obj;\n          this.lokiMap[obj.$loki] = fieldValue;\n        }\n      }\n    };\n\n    UniqueIndex.prototype.get = function (key) {\n      return this.keyMap[key];\n    };\n\n    UniqueIndex.prototype.byId = function (id) {\n      return this.keyMap[this.lokiMap[id]];\n    };\n    /**\n     * Updates a document's unique index given an updated object.\n     * @param  {Object} obj Original document object\n     * @param  {Object} doc New document object (likely the same as obj)\n     */\n\n\n    UniqueIndex.prototype.update = function (obj, doc) {\n      if (this.lokiMap[obj.$loki] !== doc[this.field]) {\n        var old = this.lokiMap[obj.$loki];\n        this.set(doc); // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\n        this.keyMap[old] = undefined;\n      } else {\n        this.keyMap[obj[this.field]] = doc;\n      }\n    };\n\n    UniqueIndex.prototype.remove = function (key) {\n      var obj = this.keyMap[key];\n\n      if (obj !== null && typeof obj !== 'undefined') {\n        // avoid using `delete`\n        this.keyMap[key] = undefined;\n        this.lokiMap[obj.$loki] = undefined;\n      } else {\n        throw new Error('Key is not in unique index: ' + this.field);\n      }\n    };\n\n    UniqueIndex.prototype.clear = function () {\n      this.keyMap = Object.create(null);\n      this.lokiMap = Object.create(null);\n    };\n\n    function ExactIndex(exactField) {\n      this.index = Object.create(null);\n      this.field = exactField;\n    } // add the value you want returned to the key in the index\n\n\n    ExactIndex.prototype = {\n      set: function add(key, val) {\n        if (this.index[key]) {\n          this.index[key].push(val);\n        } else {\n          this.index[key] = [val];\n        }\n      },\n      // remove the value from the index, if the value was the last one, remove the key\n      remove: function remove(key, val) {\n        var idxSet = this.index[key];\n\n        for (var i in idxSet) {\n          if (idxSet[i] == val) {\n            idxSet.splice(i, 1);\n          }\n        }\n\n        if (idxSet.length < 1) {\n          this.index[key] = undefined;\n        }\n      },\n      // get the values related to the key, could be more than one\n      get: function get(key) {\n        return this.index[key];\n      },\n      // clear will zap the index\n      clear: function clear(key) {\n        this.index = {};\n      }\n    };\n\n    function SortedIndex(sortedField) {\n      this.field = sortedField;\n    }\n\n    SortedIndex.prototype = {\n      keys: [],\n      values: [],\n      // set the default sort\n      sort: function sort(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n      },\n      bs: function bs() {\n        return new BSonSort(this.sort);\n      },\n      // and allow override of the default sort\n      setSort: function setSort(fun) {\n        this.bs = new BSonSort(fun);\n      },\n      // add the value you want returned  to the key in the index\n      set: function set(key, value) {\n        var pos = binarySearch(this.keys, key, this.sort);\n\n        if (pos.found) {\n          this.values[pos.index].push(value);\n        } else {\n          this.keys.splice(pos.index, 0, key);\n          this.values.splice(pos.index, 0, [value]);\n        }\n      },\n      // get all values which have a key == the given key\n      get: function get(key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n\n        if (bsr.found) {\n          return this.values[bsr.index];\n        } else {\n          return [];\n        }\n      },\n      // get all values which have a key < the given key\n      getLt: function getLt(key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        var pos = bsr.index;\n        if (bsr.found) pos--;\n        return this.getAll(key, 0, pos);\n      },\n      // get all values which have a key > the given key\n      getGt: function getGt(key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        var pos = bsr.index;\n        if (bsr.found) pos++;\n        return this.getAll(key, pos, this.keys.length);\n      },\n      // get all vals from start to end\n      getAll: function getAll(key, start, end) {\n        var results = [];\n\n        for (var i = start; i < end; i++) {\n          results = results.concat(this.values[i]);\n        }\n\n        return results;\n      },\n      // just in case someone wants to do something smart with ranges\n      getPos: function getPos(key) {\n        return binarySearch(this.keys, key, this.sort);\n      },\n      // remove the value from the index, if the value was the last one, remove the key\n      remove: function remove(key, value) {\n        var pos = binarySearch(this.keys, key, this.sort).index;\n        var idxSet = this.values[pos];\n\n        for (var i in idxSet) {\n          if (idxSet[i] == value) idxSet.splice(i, 1);\n        }\n\n        if (idxSet.length < 1) {\n          this.keys.splice(pos, 1);\n          this.values.splice(pos, 1);\n        }\n      },\n      // clear will zap the index\n      clear: function clear() {\n        this.keys = [];\n        this.values = [];\n      }\n    };\n    Loki.deepFreeze = deepFreeze;\n    Loki.freeze = freeze;\n    Loki.unFreeze = unFreeze;\n    Loki.LokiOps = LokiOps;\n    Loki.Collection = Collection;\n    Loki.DynamicView = DynamicView;\n    Loki.Resultset = Resultset;\n    Loki.KeyValueStore = KeyValueStore;\n    Loki.LokiMemoryAdapter = LokiMemoryAdapter;\n    Loki.LokiPartitioningAdapter = LokiPartitioningAdapter;\n    Loki.LokiLocalStorageAdapter = LokiLocalStorageAdapter;\n    Loki.LokiFsAdapter = LokiFsAdapter;\n    Loki.persistenceAdapters = {\n      fs: LokiFsAdapter,\n      localStorage: LokiLocalStorageAdapter\n    };\n    Loki.aeq = aeqHelper;\n    Loki.lt = ltHelper;\n    Loki.gt = gtHelper;\n    Loki.Comparators = Comparators;\n    return Loki;\n  }();\n});","map":{"version":3,"sources":["C:/Totvs/po-angular/node_modules/lokijs/src/lokijs.js"],"names":["root","factory","define","amd","exports","module","loki","hasOwnProperty","Object","prototype","deepFreeze","obj","prop","i","Array","isArray","length","freeze","isFrozen","unFreeze","clone","Utils","copyProperties","src","dest","resolveTransformObject","subObj","params","depth","pname","indexOf","substring","resolveTransformParams","transform","idx","clonedStep","resolvedTransform","push","getIn","object","path","usingDotNotation","undefined","split","Error","index","Comparators","aeq","aeqHelper","lt","ltHelper","gt","gtHelper","prop1","prop2","cv1","cv2","t1","t2","Number","toString","equal","sortHelper","desc","compoundeval","properties","obj1","obj2","res","field","val1","val2","arr","len","dotSubScan","paths","fun","value","extra","poffset","pathOffset","valueFound","element","containsCheckFn","a","b","call","doQueryOp","val","op","record","p","LokiOps","$eq","$aeq","$ne","$dteq","$gt","$gte","$lt","$lte","$jgt","$jgte","$jlt","$jlte","$between","vals","$jbetween","$in","$inSet","has","$nin","$keyin","$nkeyin","$definedin","$undefinedin","$regex","test","$containsString","$containsNone","$containsAny","checkFn","some","$contains","every","$elemMatch","item","keys","property","filter","$type","type","Date","$finite","isFinite","$size","$len","$where","$not","$and","$or","$exists","valueLevelOps","forEach","spec","indexedOps","data","method","cloneMethod","cloned","JSON","parse","stringify","jQuery","extend","create","constructor","map","assign","key","name","cloneObjectArray","objarray","result","localStorageAvailable","window","localStorage","e","LokiEventEmitter","events","asyncListeners","on","eventName","listener","event","self","currentEventName","emit","selfArgs","slice","arguments","setTimeout","apply","addListener","removeListener","listeners","splice","Loki","filename","options","collections","databaseVersion","engineVersion","autosave","autosaveInterval","autosaveHandle","throttledSaves","persistenceMethod","persistenceAdapter","throttledSavePending","throttledCallbacks","verbose","getENV","global","android","NSObject","process","document","URL","ENV","env","configureOptions","clearChanges","getIndexedAdapter","adapter","require","initialConfig","defaultPersistence","persistenceMethods","LokiFsAdapter","LokiLocalStorageAdapter","LokiMemoryAdapter","isIncremental","mode","autoload","loadDatabase","autoloadCallback","autosaveDisable","parseInt","autosaveEnable","autosaveCallback","serializationMethod","destructureDelimiter","copy","databaseCopy","clen","loadJSONObject","retainDirtyFlags","removeNonSerializable","constraints","ttl","addCollection","disableMeta","disableChangesApi","disableDeltaChangesApi","collection","Collection","lokiConsoleWrapper","console","loadCollection","getCollection","collectionName","renameCollection","oldName","newName","c","listCollections","colls","objType","count","removeCollection","tmpcol","curcol","getName","serializeReplacer","serialize","serializeDestructured","toJson","sidx","resultlen","reconstruct","dbcopy","partitioned","delimited","delimiter","partition","serializeCollection","collectionIndex","join","delim","doccount","docidx","resultlines","deserializeDestructured","destructuredSource","workarray","cdb","collIndex","collCount","lineIndex","done","currLine","currObject","deserializeCollection","pop","loadJSON","serializedDb","dbObject","coll","copyColl","j","loader","collObj","makeLoader","collOptions","inflater","proto","inflate","disableFreeze","adaptiveBinaryIndices","transactional","cloneObjects","autoupdate","changes","dirtyIds","dirty","addAutoUpdateObserver","maxId","binaryIndices","transforms","uniqueNames","DynamicViews","colldv","dv","addDynamicView","resultdata","resultsdirty","filterPipeline","sortCriteriaSimple","sortCriteria","sortFunction","sortDirty","resultset","filteredrows","filterInitialized","rematerialize","removeWhereFilters","ensureAllIndexes","close","callback","autosaveDirty","saveDatabase","generateChangesNotification","arrayOfCollectionNames","getCollName","selectedCollections","concat","getChanges","serializeChanges","collectionNamesArray","flushChanges","hashStore","asyncResponses","asyncTimeout","dbname","dbstring","saveCount","savecount","lastsave","deleteDatabase","LokiPartitioningAdapter","dbref","pageIterator","paging","pageSize","db","pageIndex","loadNextPartition","keyname","loadNextPage","dlen","isLastPage","exportDatabase","dirtyPartitions","saveNextPartition","err","shift","docIndex","saveNextPage","pageLen","cdlen","delimlen","serializedObject","pageBuilder","doneWithPartition","doneWithPage","pageSaveCallback","fs","stat","stats","isFile","readFile","encoding","readFileCallback","tmpdbname","writeFile","writeFileCallback","rename","unlink","deleteDatabaseCallback","getItem","setItem","removeItem","throttledSaveDrain","now","getTime","recursiveWait","recursiveWaitLimit","recursiveWaitLimitDuration","started","loadDatabaseInternal","cFun","loadDatabaseCallback","dbString","parseSuccess","success","saveDatabaseInternal","cachedDirty","ignoreAutosave","getLokiCopy","lokiCopy","col","exportDatabaseCallback","cached","autosaveClearFlags","saveDatabasecallback","localCallbacks","unshift","pcb","save","delay","setInterval","autosaveHandleInterval","clearInterval","Resultset","reset","toJSON","limit","qty","prepareFullDocIndex","rscopy","offset","pos","branch","parameters","step","rs","find","where","simplesort","compoundsort","sort","dataOptions","eqJoin","joinData","leftJoinKey","rightJoinKey","mapFun","mapReduce","mapFunction","reduceFunction","update","remove","comparefun","wrappedComparer","userComparer","propname","eff","targetEff","dc","frl","hasBinaryIndex","ensureIndex","values","reverse","disableIndexIntersect","useJavascriptSorting","forceIndexIntersect","fr","io","pv","n","props","findOr","expressionArray","fri","frlen","docset","idxset","origCount","ei","elen","precompileQuery","operator","RegExp","findAnd","query","firstOnly","queryObject","queryObjectOp","searchByIndex","filters","doIndexCheck","Set","t","rowIdx","segm","calculateRange","viewFunction","TypeError","k","removeMeta","forceClones","forceCloneMethod","$loki","meta","updateFunction","rcd","removeBatchByPositions","leftData","leftDataLength","rightData","rightDataLength","leftKeyisFunction","rightKeyisFunction","joinMap","chain","left","right","insert","DynamicView","rebuildPending","persistent","sortPriority","minRebuildInterval","cachedresultset","getSort","fpl","fpi","wasFrozen","ofp","applyFind","uid","branchResultset","removeFilters","filterChanged","queueSortPhase","applySort","applySimpleSort","applySortCriteria","criteria","startTransaction","commit","rollback","_indexOfFilterWithId","_addFilter","reapplyFilters","queueRebuildEvent","applyFilter","applyWhere","removeFilter","performSortPhase","suppressRebuildEvent","evaluateDocument","objIndex","isNew","ofr","oldPos","oldlen","evalResultset","newPos","removeDocument","rmidx","rmlen","rxo","fxo","adjels","drs","di","filt","idIndex","unique","exact","cachedIndex","cachedBinaryIndex","cachedData","ExactIndex","serializableIndices","age","ttlInterval","daemon","setTTL","indices","observerCallback","changedObjects","add","change","removeAutoUpdateObserver","getChangeDelta","old","getObjectDelta","oldObject","newObject","propertyNames","delta","propertyName","propertyDelta","setChangesApi","enabled","deleteCallback","createChange","warning","warn","contructor","operation","insertMeta","created","revision","updateMeta","updated","createInsertChange","createUpdateChange","insertMetaWithChange","updateMetaWithChange","objFrozen","log","error","observe","unobserve","addTransform","getTransform","setTransform","removeTransform","byExample","template","findObject","findOne","findObjects","ttlDaemonFuncGen","ttlDaemon","toRemove","daemonFilter","member","timestamp","diff","interval","indexes","force","propPath","checkAllIndexes","bIndices","results","checkIndex","randomSamplingFactor","randomSampling","valid","iter","biv","repair","Math","floor","random","getBinaryIndexValues","idxvals","getUniqueIndex","ensureUniqueIndex","UniqueIndex","set","flagBinaryIndexesDirty","flagBinaryIndexDirty","ensureId","ensureIdAsync","async","removeDynamicView","getDynamicView","findAndUpdate","filterObject","updateWhere","findAndRemove","doc","overrideAdaptiveIndices","insertOne","adaptiveBatchOverride","bulkInsert","returnObj","clear","removeIndices","biname","get","oldInternal","newInternal","position","adaptiveBinaryIndexUpdate","message","isNaN","newId","version","addedPos","dvlen","adaptiveBinaryIndexInsert","filterFunction","removeWhere","list","removeDataOnly","positions","xo","didx","bic","uic","adaptiveOverride","adaptiveBinaryIndexRemove","delete","id","removeBatch","batch","xlt","posx","frozen","returnPosition","retpos","max","min","mid","getBinaryIndexPosition","dataPosition","binaryIndexName","range","idxPos","calculateRangeStart","removedFromIndexOnly","bi","curr","sortedPositions","adaptive","minVal","maxVal","lbound","calculateRangeEnd","ubound","lval","uval","segResult","seg","by","findOneUnindexed","cachedDirtyIds","leftJoinProp","rightJoinProp","stages","getStage","commitLog","stage","stageName","commitStage","no_op","extract","isDotNotation","isDeepProperty","deepProperty","maxRecord","deep","minRecord","extractNumerical","parseBase10","avg","average","stdDev","standardDeviation","dict","median","sub","half","num","parseFloat","isNotUndefined","array","reduce","squareDiffs","sqrDiff","avgSquareDiff","sqrt","isDeep","pieces","binarySearch","lo","hi","compared","found","BSonSort","KeyValueStore","setSort","bs","uniqueField","keyMap","lokiMap","fieldValue","byId","exactField","idxSet","SortedIndex","sortedField","bsr","getLt","getAll","getGt","start","end","getPos","persistenceAdapters"],"mappings":"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","sourcesContent":["/**\n * LokiJS\n * @author Joe Minichino <joe.minichino@gmail.com>\n *\n * A lightweight document oriented javascript database\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // Browser globals\n    root.loki = factory();\n  }\n}(this, function () {\n\n  return (function () {\n    'use strict';\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    function deepFreeze(obj) {\n      var prop, i;\n      if (Array.isArray(obj)) {\n        for (i = 0; i < obj.length; i++) {\n          deepFreeze(obj[i]);\n        }\n        freeze(obj);\n      } else if (obj !== null && (typeof obj === 'object')) {\n        for (prop in obj) {\n          if (obj.hasOwnProperty(prop)) {\n            deepFreeze(obj[prop]);\n          }\n        }\n        freeze(obj);\n      }\n    }\n\n    function freeze(obj) {\n      if (!Object.isFrozen(obj)) {\n        Object.freeze(obj);\n      }\n    }\n\n    function unFreeze(obj) {\n      if (!Object.isFrozen(obj)) {\n        return obj;\n      }\n      return clone(obj, 'shallow');\n    }\n\n    var Utils = {\n      copyProperties: function (src, dest) {\n        var prop;\n        for (prop in src) {\n          dest[prop] = src[prop];\n        }\n      },\n      // used to recursively scan hierarchical transform step object for param substitution\n      resolveTransformObject: function (subObj, params, depth) {\n        var prop,\n          pname;\n\n        if (typeof depth !== 'number') {\n          depth = 0;\n        }\n\n        if (++depth >= 10) return subObj;\n\n        for (prop in subObj) {\n          if (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n            pname = subObj[prop].substring(8);\n            if (params.hasOwnProperty(pname)) {\n              subObj[prop] = params[pname];\n            }\n          } else if (typeof subObj[prop] === \"object\") {\n            subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n          }\n        }\n\n        return subObj;\n      },\n      // top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n      resolveTransformParams: function (transform, params) {\n        var idx,\n          clonedStep,\n          resolvedTransform = [];\n\n        if (typeof params === 'undefined') return transform;\n\n        // iterate all steps in the transform array\n        for (idx = 0; idx < transform.length; idx++) {\n          // clone transform so our scan/replace can operate directly on cloned transform\n          clonedStep = clone(transform[idx], \"shallow-recurse-objects\");\n          resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n        }\n\n        return resolvedTransform;\n      },\n\n      // By default (if usingDotNotation is false), looks up path in\n      // object via `object[path]`\n      //\n      // If `usingDotNotation` is true, then the path is assumed to\n      // represent a nested path. It can be in the form of an array of\n      // field names, or a period delimited string. The function will\n      // look up the value of object[path[0]], and then call\n      // result[path[1]] on the result, etc etc.\n      //\n      // If `usingDotNotation` is true, this function still supports\n      // non nested fields.\n      //\n      // `usingDotNotation` is a performance optimization. The caller\n      // may know that a path is *not* nested. In which case, this\n      // function avoids a costly string.split('.')\n      //\n      // examples:\n      // getIn({a: 1}, \"a\") => 1\n      // getIn({a: 1}, \"a\", true) => 1\n      // getIn({a: {b: 1}}, [\"a\", \"b\"], true) => 1\n      // getIn({a: {b: 1}}, \"a.b\", true) => 1\n      getIn: function (object, path, usingDotNotation) {\n        if (object == null) {\n          return undefined;\n        }\n        if (!usingDotNotation) {\n          return object[path];\n        }\n\n        if (typeof (path) === \"string\") {\n          path = path.split(\".\");\n        }\n\n        if (!Array.isArray(path)) {\n          throw new Error(\"path must be a string or array. Found \" + typeof (path));\n        }\n\n        var index = 0,\n          length = path.length;\n\n        while (object != null && index < length) {\n          object = object[path[index++]];\n        }\n        return (index && index == length) ? object : undefined;\n      }\n    };\n\n    // wrapping in object to expose to default export for potential user override.\n    // warning: overriding these methods will override behavior for all loki db instances in memory.\n    // warning: if you use binary indices these comparators should be the same for all inserts/updates/removes.\n    var Comparators = {\n      aeq: aeqHelper,\n      lt: ltHelper,\n      gt: gtHelper\n    };\n\n    /** Helper function for determining 'loki' abstract equality which is a little more abstract than ==\n     *     aeqHelper(5, '5') === true\n     *     aeqHelper(5.0, '5') === true\n     *     aeqHelper(new Date(\"1/1/2011\"), new Date(\"1/1/2011\")) === true\n     *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)\n     *     aeqHelper([1, 2, 3], [1, 3]) === false\n     *     aeqHelper([1, 2, 3], [1, 2, 3]) === true\n     *     aeqHelper(undefined, null) === true\n     */\n    function aeqHelper(prop1, prop2) {\n      var cv1, cv2, t1, t2;\n\n      if (prop1 === prop2) return true;\n\n      // 'falsy' and Boolean handling\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        // dates and NaN conditions (typed dates before serialization)\n        switch (prop1) {\n          case undefined: t1 = 1; break;\n          case null: t1 = 1; break;\n          case false: t1 = 3; break;\n          case true: t1 = 4; break;\n          case \"\": t1 = 5; break;\n          default: t1 = (prop1 === prop1) ? 9 : 0; break;\n        }\n\n        switch (prop2) {\n          case undefined: t2 = 1; break;\n          case null: t2 = 1; break;\n          case false: t2 = 3; break;\n          case true: t2 = 4; break;\n          case \"\": t2 = 5; break;\n          default: t2 = (prop2 === prop2) ? 9 : 0; break;\n        }\n\n        // one or both is edge case\n        if (t1 !== 9 || t2 !== 9) {\n          return (t1 === t2);\n        }\n      }\n\n      // Handle 'Number-like' comparisons\n      cv1 = Number(prop1);\n      cv2 = Number(prop2);\n\n      // if one or both are 'number-like'...\n      if (cv1 === cv1 || cv2 === cv2) {\n        return (cv1 === cv2);\n      }\n\n      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n\n      return (cv1 == cv2);\n    }\n\n    /** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n     *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n     *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n     *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n     */\n    function ltHelper(prop1, prop2, equal) {\n      var cv1, cv2, t1, t2;\n\n      // if one of the params is falsy or strictly true or not equal to itself\n      // 0, 0.0, \"\", NaN, null, undefined, not defined, false, true\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        switch (prop1) {\n          case undefined: t1 = 1; break;\n          case null: t1 = 1; break;\n          case false: t1 = 3; break;\n          case true: t1 = 4; break;\n          case \"\": t1 = 5; break;\n          // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null\n          default: t1 = (prop1 === prop1) ? 9 : 0; break;\n        }\n\n        switch (prop2) {\n          case undefined: t2 = 1; break;\n          case null: t2 = 1; break;\n          case false: t2 = 3; break;\n          case true: t2 = 4; break;\n          case \"\": t2 = 5; break;\n          default: t2 = (prop2 === prop2) ? 9 : 0; break;\n        }\n\n        // one or both is edge case\n        if (t1 !== 9 || t2 !== 9) {\n          return (t1 === t2) ? equal : (t1 < t2);\n        }\n      }\n\n      // if both are numbers (string encoded or not), compare as numbers\n      cv1 = Number(prop1);\n      cv2 = Number(prop2);\n\n      if (cv1 === cv1 && cv2 === cv2) {\n        if (cv1 < cv2) return true;\n        if (cv1 > cv2) return false;\n        return equal;\n      }\n\n      if (cv1 === cv1 && cv2 !== cv2) {\n        return true;\n      }\n\n      if (cv2 === cv2 && cv1 !== cv1) {\n        return false;\n      }\n\n      if (prop1 < prop2) return true;\n      if (prop1 > prop2) return false;\n      if (prop1 == prop2) return equal;\n\n      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n\n      if (cv1 < cv2) {\n        return true;\n      }\n\n      if (cv1 == cv2) {\n        return equal;\n      }\n\n      return false;\n    }\n\n    function gtHelper(prop1, prop2, equal) {\n      var cv1, cv2, t1, t2;\n\n      // 'falsy' and Boolean handling\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n        switch (prop1) {\n          case undefined: t1 = 1; break;\n          case null: t1 = 1; break;\n          case false: t1 = 3; break;\n          case true: t1 = 4; break;\n          case \"\": t1 = 5; break;\n          // NaN 0\n          default: t1 = (prop1 === prop1) ? 9 : 0; break;\n        }\n\n        switch (prop2) {\n          case undefined: t2 = 1; break;\n          case null: t2 = 1; break;\n          case false: t2 = 3; break;\n          case true: t2 = 4; break;\n          case \"\": t2 = 5; break;\n          default: t2 = (prop2 === prop2) ? 9 : 0; break;\n        }\n\n        // one or both is edge case\n        if (t1 !== 9 || t2 !== 9) {\n          return (t1 === t2) ? equal : (t1 > t2);\n        }\n      }\n\n      // if both are numbers (string encoded or not), compare as numbers\n      cv1 = Number(prop1);\n      cv2 = Number(prop2);\n      if (cv1 === cv1 && cv2 === cv2) {\n        if (cv1 > cv2) return true;\n        if (cv1 < cv2) return false;\n        return equal;\n      }\n\n      if (cv1 === cv1 && cv2 !== cv2) {\n        return false;\n      }\n\n      if (cv2 === cv2 && cv1 !== cv1) {\n        return true;\n      }\n\n      if (prop1 > prop2) return true;\n      if (prop1 < prop2) return false;\n      if (prop1 == prop2) return equal;\n\n      // not strict equal nor less than nor gt so must be dates or mixed types\n      // convert to string and use that to compare\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n\n      if (cv1 > cv2) {\n        return true;\n      }\n\n      if (cv1 == cv2) {\n        return equal;\n      }\n\n      return false;\n    }\n\n    function sortHelper(prop1, prop2, desc) {\n      if (Comparators.aeq(prop1, prop2)) return 0;\n\n      if (Comparators.lt(prop1, prop2, false)) {\n        return (desc) ? (1) : (-1);\n      }\n\n      if (Comparators.gt(prop1, prop2, false)) {\n        return (desc) ? (-1) : (1);\n      }\n\n      // not lt, not gt so implied equality-- date compatible\n      return 0;\n    }\n\n    /**\n     * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n     *\n     * @param {array} properties - array of property names, in order, by which to evaluate sort order\n     * @param {object} obj1 - first object to compare\n     * @param {object} obj2 - second object to compare\n     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n     */\n    function compoundeval(properties, obj1, obj2) {\n      var res = 0;\n      var prop, field, val1, val2, arr, path;\n      for (var i = 0, len = properties.length; i < len; i++) {\n        prop = properties[i];\n        field = prop[0];\n        if (~field.indexOf('.')) {\n          arr = field.split('.');\n          val1 = Utils.getIn(obj1, arr, true);\n          val2 = Utils.getIn(obj2, arr, true);\n        } else {\n          val1 = obj1[field];\n          val2 = obj2[field];\n        }\n        res = sortHelper(val1, val2, prop[1]);\n        if (res !== 0) {\n          return res;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * dotSubScan - helper function used for dot notation queries.\n     *\n     * @param {object} root - object to traverse\n     * @param {array} paths - array of properties to drill into\n     * @param {function} fun - evaluation function to test with\n     * @param {any} value - comparative value to also pass to (compare) fun\n     * @param {any} extra - extra arg to also pass to compare fun\n     * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n     */\n    function dotSubScan(root, paths, fun, value, extra, poffset) {\n      var pathOffset = poffset || 0;\n      var path = paths[pathOffset];\n\n      var valueFound = false;\n      var element;\n      if (typeof root === 'object' && path in root) {\n        element = root[path];\n      }\n      if (pathOffset + 1 >= paths.length) {\n        // if we have already expanded out the dot notation,\n        // then just evaluate the test function and value on the element\n        valueFound = fun(element, value, extra);\n      } else if (Array.isArray(element)) {\n        for (var index = 0, len = element.length; index < len; index += 1) {\n          valueFound = dotSubScan(element[index], paths, fun, value, extra, pathOffset + 1);\n          if (valueFound === true) {\n            break;\n          }\n        }\n      } else {\n        valueFound = dotSubScan(element, paths, fun, value, extra, pathOffset + 1);\n      }\n\n      return valueFound;\n    }\n\n    function containsCheckFn(a) {\n      if (typeof a === 'string' || Array.isArray(a)) {\n        return function (b) {\n          return a.indexOf(b) !== -1;\n        };\n      } else if (typeof a === 'object' && a !== null) {\n        return function (b) {\n          return hasOwnProperty.call(a, b);\n        };\n      }\n      return null;\n    }\n\n    function doQueryOp(val, op, record) {\n      for (var p in op) {\n        if (hasOwnProperty.call(op, p)) {\n          return LokiOps[p](val, op[p], record);\n        }\n      }\n      return false;\n    }\n\n    var LokiOps = {\n      // comparison operators\n      // a is the value in the collection\n      // b is the query value\n      $eq: function (a, b) {\n        return a === b;\n      },\n\n      // abstract/loose equality\n      $aeq: function (a, b) {\n        return a == b;\n      },\n\n      $ne: function (a, b) {\n        // ecma 5 safe test for NaN\n        if (b !== b) {\n          // ecma 5 test value is not NaN\n          return (a === a);\n        }\n\n        return a !== b;\n      },\n      // date equality / loki abstract equality test\n      $dteq: function (a, b) {\n        return Comparators.aeq(a, b);\n      },\n\n      // loki comparisons: return identical unindexed results as indexed comparisons\n      $gt: function (a, b) {\n        return Comparators.gt(a, b, false);\n      },\n\n      $gte: function (a, b) {\n        return Comparators.gt(a, b, true);\n      },\n\n      $lt: function (a, b) {\n        return Comparators.lt(a, b, false);\n      },\n\n      $lte: function (a, b) {\n        return Comparators.lt(a, b, true);\n      },\n\n      // lightweight javascript comparisons\n      $jgt: function (a, b) {\n        return a > b;\n      },\n\n      $jgte: function (a, b) {\n        return a >= b;\n      },\n\n      $jlt: function (a, b) {\n        return a < b;\n      },\n\n      $jlte: function (a, b) {\n        return a <= b;\n      },\n\n      // ex : coll.find({'orderCount': {$between: [10, 50]}});\n      $between: function (a, vals) {\n        if (a === undefined || a === null) return false;\n        return (Comparators.gt(a, vals[0], true) && Comparators.lt(a, vals[1], true));\n      },\n\n      $jbetween: function (a, vals) {\n        if (a === undefined || a === null) return false;\n        return (a >= vals[0] && a <= vals[1]);\n      },\n\n      $in: function (a, b) {\n        return b.indexOf(a) !== -1;\n      },\n\n      $inSet: function(a, b) {\n        return b.has(a);\n      },\n\n      $nin: function (a, b) {\n        return b.indexOf(a) === -1;\n      },\n\n      $keyin: function (a, b) {\n        return a in b;\n      },\n\n      $nkeyin: function (a, b) {\n        return !(a in b);\n      },\n\n      $definedin: function (a, b) {\n        return b[a] !== undefined;\n      },\n\n      $undefinedin: function (a, b) {\n        return b[a] === undefined;\n      },\n\n      $regex: function (a, b) {\n        return b.test(a);\n      },\n\n      $containsString: function (a, b) {\n        return (typeof a === 'string') && (a.indexOf(b) !== -1);\n      },\n\n      $containsNone: function (a, b) {\n        return !LokiOps.$containsAny(a, b);\n      },\n\n      $containsAny: function (a, b) {\n        var checkFn = containsCheckFn(a);\n        if (checkFn !== null) {\n          return (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n        }\n        return false;\n      },\n\n      $contains: function (a, b) {\n        var checkFn = containsCheckFn(a);\n        if (checkFn !== null) {\n          return (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n        }\n        return false;\n      },\n\n      $elemMatch: function (a, b) {\n        if (Array.isArray(a)) {\n          return a.some(function (item) {\n            return Object.keys(b).every(function (property) {\n              var filter = b[property];\n              if (!(typeof filter === 'object' && filter)) {\n                filter = { $eq: filter };\n              }\n\n              if (property.indexOf('.') !== -1) {\n                return dotSubScan(item, property.split('.'), doQueryOp, b[property], item);\n              }\n              return doQueryOp(item[property], filter, item);\n            });\n          });\n        }\n        return false;\n      },\n\n      $type: function (a, b, record) {\n        var type = typeof a;\n        if (type === 'object') {\n          if (Array.isArray(a)) {\n            type = 'array';\n          } else if (a instanceof Date) {\n            type = 'date';\n          }\n        }\n        return (typeof b !== 'object') ? (type === b) : doQueryOp(type, b, record);\n      },\n\n      $finite: function (a, b) {\n        return (b === isFinite(a));\n      },\n\n      $size: function (a, b, record) {\n        if (Array.isArray(a)) {\n          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b, record);\n        }\n        return false;\n      },\n\n      $len: function (a, b, record) {\n        if (typeof a === 'string') {\n          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b, record);\n        }\n        return false;\n      },\n\n      $where: function (a, b) {\n        return b(a) === true;\n      },\n\n      // field-level logical operators\n      // a is the value in the collection\n      // b is the nested query operation (for '$not')\n      //   or an array of nested query operations (for '$and' and '$or')\n      $not: function (a, b, record) {\n        return !doQueryOp(a, b, record);\n      },\n\n      $and: function (a, b, record) {\n        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n          if (!doQueryOp(a, b[idx], record)) {\n            return false;\n          }\n        }\n        return true;\n      },\n\n      $or: function (a, b, record) {\n        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n          if (doQueryOp(a, b[idx], record)) {\n            return true;\n          }\n        }\n        return false;\n      },\n\n      $exists: function (a, b) {\n        if (b) {\n          return a !== undefined;\n        } else {\n          return a === undefined;\n        }\n      }\n    };\n\n    // ops that can be used with { $$op: 'column-name' } syntax\n    var valueLevelOps = ['$eq', '$aeq', '$ne', '$dteq', '$gt', '$gte', '$lt', '$lte', '$jgt', '$jgte', '$jlt', '$jlte', '$type'];\n    valueLevelOps.forEach(function (op) {\n      var fun = LokiOps[op];\n      LokiOps['$' + op] = function (a, spec, record) {\n        if (typeof spec === 'string') {\n          return fun(a, record[spec]);\n        } else if (typeof spec === 'function') {\n          return fun(a, spec(record));\n        } else {\n          throw new Error('Invalid argument to $$ matcher');\n        }\n      };\n    });\n\n    // if an op is registered in this object, our 'calculateRange' can use it with our binary indices.\n    // if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.\n    // those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.\n    var indexedOps = {\n      $eq: LokiOps.$eq,\n      $aeq: true,\n      $dteq: true,\n      $gt: true,\n      $gte: true,\n      $lt: true,\n      $lte: true,\n      $in: true,\n      $between: true\n    };\n\n    function clone(data, method) {\n      if (data === null || data === undefined) {\n        return null;\n      }\n\n      var cloneMethod = method || 'parse-stringify',\n        cloned;\n\n      switch (cloneMethod) {\n        case \"parse-stringify\":\n          cloned = JSON.parse(JSON.stringify(data));\n          break;\n        case \"jquery-extend-deep\":\n          cloned = jQuery.extend(true, {}, data);\n          break;\n        case \"shallow\":\n          // more compatible method for older browsers\n          cloned = Object.create(data.constructor.prototype);\n          Object.keys(data).map(function (i) {\n            cloned[i] = data[i];\n          });\n          break;\n        case \"shallow-assign\":\n          // should be supported by newer environments/browsers\n          cloned = Object.create(data.constructor.prototype);\n          Object.assign(cloned, data);\n          break;\n        case \"shallow-recurse-objects\":\n          // shallow clone top level properties\n          cloned = clone(data, \"shallow\");\n          var keys = Object.keys(data);\n          // for each of the top level properties which are object literals, recursively shallow copy\n          keys.forEach(function (key) {\n            if (typeof data[key] === \"object\" && data[key].constructor.name === \"Object\") {\n              cloned[key] = clone(data[key], \"shallow-recurse-objects\");\n            } else if (Array.isArray(data[key])) {\n              cloned[key] = cloneObjectArray(data[key], \"shallow-recurse-objects\");\n            }\n          });\n          break;\n        default:\n          break;\n      }\n\n      return cloned;\n    }\n\n    function cloneObjectArray(objarray, method) {\n      if (method == \"parse-stringify\") {\n        return clone(objarray, method);\n      }\n      var result = [];\n      for (var i = 0, len = objarray.length; i < len; i++) {\n        result[i] = clone(objarray[i], method);\n      }\n      return result;\n    }\n\n    function localStorageAvailable() {\n      try {\n        return (window && window.localStorage !== undefined && window.localStorage !== null);\n      } catch (e) {\n        return false;\n      }\n    }\n\n\n    /**\n     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n     * constructor that inherits EventEmitter to emit events and trigger\n     * listeners that have been added to the event through the on(event, callback) method\n     *\n     * @constructor LokiEventEmitter\n     */\n    function LokiEventEmitter() { }\n\n    /**\n     * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.events = {};\n\n    /**\n     * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n     * should happen in an async fashion or not\n     * Default is false, which means events are synchronous\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.asyncListeners = false;\n\n    /**\n     * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n     * @param {function} listener - callback function of listener to attach\n     * @returns {int} the index of the callback in the array of listeners for a particular event\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.on = function (eventName, listener) {\n      var event;\n      var self = this;\n\n      if (Array.isArray(eventName)) {\n        eventName.forEach(function (currentEventName) {\n          self.on(currentEventName, listener);\n        });\n        return listener;\n      }\n\n      event = this.events[eventName];\n      if (!event) {\n        event = this.events[eventName] = [];\n      }\n      event.push(listener);\n      return listener;\n    };\n\n    /**\n     * emit(eventName, data) - emits a particular event\n     * with the option of passing optional parameters which are going to be processed by the callback\n     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n     * @param {string} eventName - the name of the event\n     * @param {object=} data - optional object passed with the event\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.emit = function (eventName) {\n      var self = this;\n      var selfArgs;\n      if (eventName && this.events[eventName]) {\n        if (this.events[eventName].length) {\n          selfArgs = Array.prototype.slice.call(arguments, 1);\n          this.events[eventName].forEach(function (listener) {\n            if (self.asyncListeners) {\n              setTimeout(function () {\n                listener.apply(self, selfArgs);\n              }, 1);\n            } else {\n              listener.apply(self, selfArgs);\n            }\n          });\n        }\n      } else {\n        throw new Error('No event ' + eventName + ' defined');\n      }\n    };\n\n    /**\n     * Alias of LokiEventEmitter.prototype.on\n     * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n     * @param {function} listener - callback function of listener to attach\n     * @returns {int} the index of the callback in the array of listeners for a particular event\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.addListener = LokiEventEmitter.prototype.on;\n\n    /**\n     * removeListener() - removes the listener at position 'index' from the event 'eventName'\n     * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n     * @param {function} listener - the listener callback function to remove from emitter\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {\n      var self = this;\n\n      if (Array.isArray(eventName)) {\n        eventName.forEach(function (currentEventName) {\n          self.removeListener(currentEventName, listener);\n        });\n\n        return;\n      }\n\n      if (this.events[eventName]) {\n        var listeners = this.events[eventName];\n        listeners.splice(listeners.indexOf(listener), 1);\n      }\n    };\n\n    /**\n     * Loki: The main database class\n     * @constructor Loki\n     * @implements LokiEventEmitter\n     * @param {string} filename - name of the file to be saved to\n     * @param {object=} options - (Optional) config options object\n     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n     * @param {boolean} [options.verbose=false] - enable console output\n     * @param {boolean} [options.autosave=false] - enables autosave\n     * @param {int} [options.autosaveInterval=5000] - time interval (in milliseconds) between saves (if dirty)\n     * @param {boolean} [options.autoload=false] - enables autoload on loki instantiation\n     * @param {function} options.autoloadCallback - user callback called after database load\n     * @param {adapter} options.adapter - an instance of a loki persistence adapter\n     * @param {string} [options.serializationMethod='normal'] - ['normal', 'pretty', 'destructured']\n     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n     * @param {boolean} [options.throttledSaves=true] - debounces multiple calls to to saveDatabase reducing number of disk I/O operations\n                                                and guaranteeing proper serialization of the calls.\n     */\n    function Loki(filename, options) {\n      this.filename = filename || 'loki.db';\n      this.collections = [];\n\n      // persist version of code which created the database to the database.\n      // could use for upgrade scenarios\n      this.databaseVersion = 1.5;\n      this.engineVersion = 1.5;\n\n      // autosave support (disabled by default)\n      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n      this.autosave = false;\n      this.autosaveInterval = 5000;\n      this.autosaveHandle = null;\n      this.throttledSaves = true;\n\n      this.options = {};\n\n      // currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n      // will not or cannot be deserialized.  You are required to configure persistence every time\n      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n      // this is optional option param, otherwise environment detection will be used\n      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n      this.persistenceMethod = null;\n\n      // retain reference to optional (non-serializable) persistenceAdapter 'instance'\n      this.persistenceAdapter = null;\n\n      // flags used to throttle saves\n      this.throttledSavePending = false;\n      this.throttledCallbacks = [];\n\n      // enable console output if verbose flag is set (disabled by default)\n      this.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\n      this.events = {\n        'init': [],\n        'loaded': [],\n        'flushChanges': [],\n        'close': [],\n        'changes': [],\n        'warning': []\n      };\n\n      var getENV = function () {\n        if (typeof global !== 'undefined' && (global.android || global.NSObject)) {\n          // If no adapter assume nativescript which needs adapter to be passed manually\n          return 'NATIVESCRIPT'; //nativescript\n        }\n\n        if (typeof window === 'undefined') {\n          return 'NODEJS';\n        }\n\n        if (typeof global !== 'undefined' && global.window && typeof process !== 'undefined') {\n          return 'NODEJS'; //node-webkit\n        }\n\n        if (typeof document !== 'undefined') {\n          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n            return 'CORDOVA';\n          }\n          return 'BROWSER';\n        }\n        return 'CORDOVA';\n      };\n\n      // refactored environment detection due to invalid detection for browser environments.\n      // if they do not specify an options.env we want to detect env rather than default to nodejs.\n      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n      //   might want to review whether we can consolidate.\n      if (options && options.hasOwnProperty('env')) {\n        this.ENV = options.env;\n      } else {\n        this.ENV = getENV();\n      }\n\n      // not sure if this is necessary now that i have refactored the line above\n      if (this.ENV === 'undefined') {\n        this.ENV = 'NODEJS';\n      }\n\n      this.configureOptions(options, true);\n\n      this.on('init', this.clearChanges);\n\n    }\n\n    // db class is an EventEmitter\n    Loki.prototype = new LokiEventEmitter();\n    Loki.prototype.constructor = Loki;\n\n    // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n    // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n    Loki.prototype.getIndexedAdapter = function () {\n      var adapter;\n\n      if (typeof require === 'function') {\n        adapter = require(\"./loki-indexed-adapter.js\");\n      }\n\n      return adapter;\n    };\n\n\n    /**\n     * Allows reconfiguring database options\n     *\n     * @param {object} options - configuration options to apply to loki db object\n     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n     * @param {boolean} options.verbose - enable console output (default is 'false')\n     * @param {boolean} options.autosave - enables autosave\n     * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n     * @param {boolean} options.autoload - enables autoload on loki instantiation\n     * @param {function} options.autoloadCallback - user callback called after database load\n     * @param {adapter} options.adapter - an instance of a loki persistence adapter\n     * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n     * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n     * @param {boolean} initialConfig - (internal) true is passed when loki ctor is invoking\n     * @memberof Loki\n     */\n    Loki.prototype.configureOptions = function (options, initialConfig) {\n      var defaultPersistence = {\n        'NODEJS': 'fs',\n        'BROWSER': 'localStorage',\n        'CORDOVA': 'localStorage',\n        'MEMORY': 'memory'\n      },\n        persistenceMethods = {\n          'fs': LokiFsAdapter,\n          'localStorage': LokiLocalStorageAdapter,\n          'memory': LokiMemoryAdapter\n        };\n\n      this.options = {};\n\n      this.persistenceMethod = null;\n      // retain reference to optional persistence adapter 'instance'\n      // currently keeping outside options because it can't be serialized\n      this.persistenceAdapter = null;\n\n      // process the options\n      if (typeof (options) !== 'undefined') {\n        this.options = options;\n\n        if (this.options.hasOwnProperty('persistenceMethod')) {\n          // check if the specified persistence method is known\n          if (typeof (persistenceMethods[options.persistenceMethod]) == 'function') {\n            this.persistenceMethod = options.persistenceMethod;\n            this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();\n          }\n          // should be throw an error here, or just fall back to defaults ??\n        }\n\n        // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n        if (this.options.hasOwnProperty('adapter')) {\n          this.persistenceMethod = 'adapter';\n          this.persistenceAdapter = options.adapter;\n          this.options.adapter = null;\n\n          // if true, will keep track of dirty ids\n          this.isIncremental = this.persistenceAdapter.mode === 'incremental';\n        }\n\n\n        // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n        if (options.autoload && initialConfig) {\n          // for autoload, let the constructor complete before firing callback\n          var self = this;\n          setTimeout(function () {\n            self.loadDatabase(options, options.autoloadCallback);\n          }, 1);\n        }\n\n        if (this.options.hasOwnProperty('autosaveInterval')) {\n          this.autosaveDisable();\n          this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n        }\n\n        if (this.options.hasOwnProperty('autosave') && this.options.autosave) {\n          this.autosaveDisable();\n          this.autosave = true;\n\n          if (this.options.hasOwnProperty('autosaveCallback')) {\n            this.autosaveEnable(options, options.autosaveCallback);\n          } else {\n            this.autosaveEnable();\n          }\n        }\n\n        if (this.options.hasOwnProperty('throttledSaves')) {\n          this.throttledSaves = this.options.throttledSaves;\n        }\n      } // end of options processing\n\n      // ensure defaults exists for options which were not set\n      if (!this.options.hasOwnProperty('serializationMethod')) {\n        this.options.serializationMethod = 'normal';\n      }\n\n      // ensure passed or default option exists\n      if (!this.options.hasOwnProperty('destructureDelimiter')) {\n        this.options.destructureDelimiter = '$<\\n';\n      }\n\n      // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n      if (this.persistenceAdapter === null) {\n        this.persistenceMethod = defaultPersistence[this.ENV];\n        if (this.persistenceMethod) {\n          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n        }\n      }\n\n    };\n\n    /**\n     * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n     *\n     * @param {object} options - apply or override collection level settings\n     * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n     * @memberof Loki\n     */\n    Loki.prototype.copy = function (options) {\n      // in case running in an environment without accurate environment detection, pass 'NA'\n      var databaseCopy = new Loki(this.filename, { env: \"NA\" });\n      var clen, idx;\n\n      options = options || {};\n\n      // currently inverting and letting loadJSONObject do most of the work\n      databaseCopy.loadJSONObject(this, { retainDirtyFlags: true });\n\n      // since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n      if (options.hasOwnProperty(\"removeNonSerializable\") && options.removeNonSerializable === true) {\n        databaseCopy.autosaveHandle = null;\n        databaseCopy.persistenceAdapter = null;\n\n        clen = databaseCopy.collections.length;\n        for (idx = 0; idx < clen; idx++) {\n          databaseCopy.collections[idx].constraints = null;\n          databaseCopy.collections[idx].ttl = null;\n        }\n      }\n\n      return databaseCopy;\n    };\n\n    /**\n     * Adds a collection to the database.\n     * @param {string} name - name of collection to add\n     * @param {object=} options - (optional) options to configure collection with.\n     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for\n     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for\n     * @param {array=} [options.indices=[]] - array property names to define binary indexes for\n     * @param {boolean} [options.asyncListeners=false] - whether listeners are called asynchronously\n     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes Api\n     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically\n     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow, 'shallow-assign'\n     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.\n     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n     * @returns {Collection} a reference to the collection which was just added\n     * @memberof Loki\n     */\n    Loki.prototype.addCollection = function (name, options) {\n      var i,\n        len = this.collections.length;\n\n      if (options && options.disableMeta === true) {\n        if (options.disableChangesApi === false) {\n          throw new Error(\"disableMeta option cannot be passed as true when disableChangesApi is passed as false\");\n        }\n        if (options.disableDeltaChangesApi === false) {\n          throw new Error(\"disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false\");\n        }\n        if (typeof options.ttl === \"number\" && options.ttl > 0) {\n          throw new Error(\"disableMeta option cannot be passed as true when ttl is enabled\");\n        }\n      }\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === name) {\n          return this.collections[i];\n        }\n      }\n\n      var collection = new Collection(name, options);\n      collection.isIncremental = this.isIncremental;\n      this.collections.push(collection);\n\n      if (this.verbose)\n        collection.lokiConsoleWrapper = console;\n\n      return collection;\n    };\n\n    Loki.prototype.loadCollection = function (collection) {\n      if (!collection.name) {\n        throw new Error('Collection must have a name property to be loaded');\n      }\n      this.collections.push(collection);\n    };\n\n    /**\n     * Retrieves reference to a collection by name.\n     * @param {string} collectionName - name of collection to look up\n     * @returns {Collection} Reference to collection in database by that name, or null if not found\n     * @memberof Loki\n     */\n    Loki.prototype.getCollection = function (collectionName) {\n      var i,\n        len = this.collections.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === collectionName) {\n          return this.collections[i];\n        }\n      }\n\n      // no such collection\n      this.emit('warning', 'collection ' + collectionName + ' not found');\n      return null;\n    };\n\n    /**\n     * Renames an existing loki collection\n     * @param {string} oldName - name of collection to rename\n     * @param {string} newName - new name of collection\n     * @returns {Collection} reference to the newly renamed collection\n     * @memberof Loki\n     */\n    Loki.prototype.renameCollection = function (oldName, newName) {\n      var c = this.getCollection(oldName);\n\n      if (c) {\n        c.name = newName;\n      }\n\n      return c;\n    };\n\n    /**\n     * Returns a list of collections in the database.\n     * @returns {object[]} array of objects containing 'name', 'type', and 'count' properties.\n     * @memberof Loki\n     */\n    Loki.prototype.listCollections = function () {\n\n      var i = this.collections.length,\n        colls = [];\n\n      while (i--) {\n        colls.push({\n          name: this.collections[i].name,\n          type: this.collections[i].objType,\n          count: this.collections[i].data.length\n        });\n      }\n      return colls;\n    };\n\n    /**\n     * Removes a collection from the database.\n     * @param {string} collectionName - name of collection to remove\n     * @memberof Loki\n     */\n    Loki.prototype.removeCollection = function (collectionName) {\n      var i,\n        len = this.collections.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === collectionName) {\n          var tmpcol = new Collection(collectionName, {});\n          var curcol = this.collections[i];\n          for (var prop in curcol) {\n            if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n              curcol[prop] = tmpcol[prop];\n            }\n          }\n          this.collections.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    Loki.prototype.getName = function () {\n      return this.name;\n    };\n\n    /**\n     * serializeReplacer - used to prevent certain properties from being serialized\n     *\n     */\n    Loki.prototype.serializeReplacer = function (key, value) {\n      switch (key) {\n        case 'autosaveHandle':\n        case 'persistenceAdapter':\n        case 'constraints':\n        case 'ttl':\n          return null;\n        case 'throttledSavePending':\n        case 'throttledCallbacks':\n          return undefined;\n        case 'lokiConsoleWrapper':\n          return null;\n        default:\n          return value;\n      }\n    };\n\n    /**\n     * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n     *\n     * @returns {string} Stringified representation of the loki database.\n     * @memberof Loki\n     */\n    Loki.prototype.serialize = function (options) {\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"serializationMethod\")) {\n        options.serializationMethod = this.options.serializationMethod;\n      }\n\n      switch (options.serializationMethod) {\n        case \"normal\": return JSON.stringify(this, this.serializeReplacer);\n        case \"pretty\": return JSON.stringify(this, this.serializeReplacer, 2);\n        case \"destructured\": return this.serializeDestructured(); // use default options\n        default: return JSON.stringify(this, this.serializeReplacer);\n      }\n    };\n\n    // alias of serialize\n    Loki.prototype.toJson = Loki.prototype.serialize;\n\n    /**\n     * Database level destructured JSON serialization routine to allow alternate serialization methods.\n     * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n     * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n     * your own structured persistence or data exchange.\n     *\n     * @param {object=} options - output format options for use externally to loki\n     * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n     * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n     * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n     * @param {string=} options.delimiter - override default delimiter\n     *\n     * @returns {string|array} A custom, restructured aggregation of independent serializations.\n     * @memberof Loki\n     */\n    Loki.prototype.serializeDestructured = function (options) {\n      var idx, sidx, result, resultlen;\n      var reconstruct = [];\n      var dbcopy;\n\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"partitioned\")) {\n        options.partitioned = false;\n      }\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"delimiter\")) {\n        options.delimiter = this.options.destructureDelimiter;\n      }\n\n      // 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n      if (options.partitioned === true && options.hasOwnProperty(\"partition\") && options.partition >= 0) {\n        return this.serializeCollection({\n          delimited: options.delimited,\n          delimiter: options.delimiter,\n          collectionIndex: options.partition\n        });\n      }\n\n      // not just an individual collection, so we will need to serialize db container via shallow copy\n      dbcopy = new Loki(this.filename);\n      dbcopy.loadJSONObject(this);\n\n      for (idx = 0; idx < dbcopy.collections.length; idx++) {\n        dbcopy.collections[idx].data = [];\n      }\n\n      // if we -only- wanted the db container portion, return it now\n      if (options.partitioned === true && options.partition === -1) {\n        // since we are deconstructing, override serializationMethod to normal for here\n        return dbcopy.serialize({\n          serializationMethod: \"normal\"\n        });\n      }\n\n      // at this point we must be deconstructing the entire database\n      // start by pushing db serialization into first array element\n      reconstruct.push(dbcopy.serialize({\n        serializationMethod: \"normal\"\n      }));\n\n      dbcopy = null;\n\n      // push collection data into subsequent elements\n      for (idx = 0; idx < this.collections.length; idx++) {\n        result = this.serializeCollection({\n          delimited: options.delimited,\n          delimiter: options.delimiter,\n          collectionIndex: idx\n        });\n\n        // NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n        if (options.partitioned === false && options.delimited === false) {\n          if (!Array.isArray(result)) {\n            throw new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n          }\n\n          // Array.concat would probably duplicate memory overhead for copying strings.\n          // Instead copy each individually, and clear old value after each copy.\n          // Hopefully this will allow g.c. to reduce memory pressure, if needed.\n          resultlen = result.length;\n\n          for (sidx = 0; sidx < resultlen; sidx++) {\n            reconstruct.push(result[sidx]);\n            result[sidx] = null;\n          }\n\n          reconstruct.push(\"\");\n        }\n        else {\n          reconstruct.push(result);\n        }\n      }\n\n      // Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n      if (options.partitioned) {\n        // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n        // useful for simple future adaptations of existing persistence adapters to save collections separately\n        if (options.delimited) {\n          return reconstruct;\n        }\n        // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n        // This format might be the most versatile for 'rolling your own' partitioned sync or save.\n        // Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n        else {\n          return reconstruct;\n        }\n      }\n      else {\n        // D : one big Delimited string { partitioned: false, delimited : true }\n        // This is the method Loki will use internally if 'destructured'.\n        // Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n        if (options.delimited) {\n          // indicate no more collections\n          reconstruct.push(\"\");\n\n          return reconstruct.join(options.delimiter);\n        }\n        // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n        // This format might be best candidate for custom synchronous syncs or saves\n        else {\n          // indicate no more collections\n          reconstruct.push(\"\");\n\n          return reconstruct;\n        }\n      }\n\n      reconstruct.push(\"\");\n\n      return reconstruct.join(delim);\n    };\n\n    /**\n     * Collection level utility method to serialize a collection in a 'destructured' format\n     *\n     * @param {object=} options - used to determine output of method\n     * @param {int} options.delimited - whether to return single delimited string or an array\n     * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n     * @param {int} options.collectionIndex -  specify which collection to serialize data for\n     *\n     * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n     * @memberof Loki\n     */\n    Loki.prototype.serializeCollection = function (options) {\n      var doccount,\n        docidx,\n        resultlines = [];\n\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"collectionIndex\")) {\n        throw new Error(\"serializeCollection called without 'collectionIndex' option\");\n      }\n\n      doccount = this.collections[options.collectionIndex].data.length;\n\n      resultlines = [];\n\n      for (docidx = 0; docidx < doccount; docidx++) {\n        resultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n      }\n\n      // D and DA\n      if (options.delimited) {\n        // indicate no more documents in collection (via empty delimited string)\n        resultlines.push(\"\");\n\n        return resultlines.join(options.delimiter);\n      }\n      else {\n        // NDAA and NDA\n        return resultlines;\n      }\n    };\n\n    /**\n     * Database level destructured JSON deserialization routine to minimize memory overhead.\n     * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n     * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n     * your own structured persistence or data exchange.\n     *\n     * @param {string|array} destructuredSource - destructured json or array to deserialize from\n     * @param {object=} options - source format options\n     * @param {bool=} [options.partitioned=false] - whether db and each collection are separate\n     * @param {int=} options.partition - can be used to deserialize only a single partition\n     * @param {bool=} [options.delimited=true] - whether subitems are delimited or subarrays\n     * @param {string=} options.delimiter - override default delimiter\n     *\n     * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n     * @memberof Loki\n     */\n    Loki.prototype.deserializeDestructured = function (destructuredSource, options) {\n      var workarray = [];\n      var len, cdb;\n      var idx, collIndex = 0, collCount, lineIndex = 1, done = false;\n      var currLine, currObject;\n\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"partitioned\")) {\n        options.partitioned = false;\n      }\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"delimiter\")) {\n        options.delimiter = this.options.destructureDelimiter;\n      }\n\n      // Partitioned\n      // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n      // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n      // -or- single partition\n      if (options.partitioned) {\n        // handle single partition\n        if (options.hasOwnProperty('partition')) {\n          // db only\n          if (options.partition === -1) {\n            cdb = JSON.parse(destructuredSource[0]);\n\n            return cdb;\n          }\n\n          // single collection, return doc array\n          return this.deserializeCollection(destructuredSource[options.partition + 1], options);\n        }\n\n        // Otherwise we are restoring an entire partitioned db\n        cdb = JSON.parse(destructuredSource[0]);\n        collCount = cdb.collections.length;\n        for (collIndex = 0; collIndex < collCount; collIndex++) {\n          // attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n          cdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n        }\n\n        return cdb;\n      }\n\n      // Non-Partitioned\n      // D : one big Delimited string { partitioned: false, delimited : true }\n      // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n      // D\n      if (options.delimited) {\n        workarray = destructuredSource.split(options.delimiter);\n        destructuredSource = null; // lower memory pressure\n        len = workarray.length;\n\n        if (len === 0) {\n          return null;\n        }\n      }\n      // NDA\n      else {\n        workarray = destructuredSource;\n      }\n\n      // first line is database and collection shells\n      cdb = JSON.parse(workarray[0]);\n      collCount = cdb.collections.length;\n      workarray[0] = null;\n\n      while (!done) {\n        currLine = workarray[lineIndex];\n\n        // empty string indicates either end of collection or end of file\n        if (workarray[lineIndex] === \"\") {\n          // if no more collections to load into, we are done\n          if (++collIndex > collCount) {\n            done = true;\n          }\n        }\n        else {\n          currObject = JSON.parse(workarray[lineIndex]);\n          cdb.collections[collIndex].data.push(currObject);\n        }\n\n        // lower memory pressure and advance iterator\n        workarray[lineIndex++] = null;\n      }\n\n      return cdb;\n    };\n\n    /**\n     * Collection level utility function to deserializes a destructured collection.\n     *\n     * @param {string|array} destructuredSource - destructured representation of collection to inflate\n     * @param {object=} options - used to describe format of destructuredSource input\n     * @param {int=} [options.delimited=false] - whether source is delimited string or an array\n     * @param {string=} options.delimiter - if delimited, this is delimiter to use (if other than default)\n     *\n     * @returns {array} an array of documents to attach to collection.data.\n     * @memberof Loki\n     */\n    Loki.prototype.deserializeCollection = function (destructuredSource, options) {\n      var workarray = [];\n      var idx, len;\n\n      options = options || {};\n\n      if (!options.hasOwnProperty(\"partitioned\")) {\n        options.partitioned = false;\n      }\n\n      if (!options.hasOwnProperty(\"delimited\")) {\n        options.delimited = true;\n      }\n\n      if (!options.hasOwnProperty(\"delimiter\")) {\n        options.delimiter = this.options.destructureDelimiter;\n      }\n\n      if (options.delimited) {\n        workarray = destructuredSource.split(options.delimiter);\n        workarray.pop();\n      }\n      else {\n        workarray = destructuredSource;\n      }\n\n      len = workarray.length;\n      for (idx = 0; idx < len; idx++) {\n        workarray[idx] = JSON.parse(workarray[idx]);\n      }\n\n      return workarray;\n    };\n\n    /**\n     * Inflates a loki database from a serialized JSON string\n     *\n     * @param {string} serializedDb - a serialized loki database string\n     * @param {object=} options - apply or override collection level settings\n     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved\n     * @memberof Loki\n     */\n    Loki.prototype.loadJSON = function (serializedDb, options) {\n      var dbObject;\n      if (serializedDb.length === 0) {\n        dbObject = {};\n      } else {\n\n        // using option defined in instantiated db not what was in serialized db\n        switch (this.options.serializationMethod) {\n          case \"normal\":\n          case \"pretty\": dbObject = JSON.parse(serializedDb); break;\n          case \"destructured\": dbObject = this.deserializeDestructured(serializedDb); break;\n          default: dbObject = JSON.parse(serializedDb); break;\n        }\n      }\n\n      this.loadJSONObject(dbObject, options);\n    };\n\n    /**\n     * Inflates a loki database from a JS object\n     *\n     * @param {object} dbObject - a serialized loki database string\n     * @param {object=} options - apply or override collection level settings\n     * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved\n     * @memberof Loki\n     */\n    Loki.prototype.loadJSONObject = function (dbObject, options) {\n      var i = 0,\n        len = dbObject.collections ? dbObject.collections.length : 0,\n        coll,\n        copyColl,\n        clen,\n        j,\n        loader,\n        collObj;\n\n      this.name = dbObject.name;\n\n      // restore save throttled boolean only if not defined in options\n      if (dbObject.hasOwnProperty('throttledSaves') && options && !options.hasOwnProperty('throttledSaves')) {\n        this.throttledSaves = dbObject.throttledSaves;\n      }\n\n      this.collections = [];\n\n      function makeLoader(coll) {\n        var collOptions = options[coll.name];\n        var inflater;\n\n        if (collOptions.proto) {\n          inflater = collOptions.inflate || Utils.copyProperties;\n\n          return function (data) {\n            var collObj = new (collOptions.proto)();\n            inflater(data, collObj);\n            return collObj;\n          };\n        }\n\n        return collOptions.inflate;\n      }\n\n      for (i; i < len; i += 1) {\n        coll = dbObject.collections[i];\n\n        copyColl = this.addCollection(coll.name, {\n          disableChangesApi: coll.disableChangesApi,\n          disableDeltaChangesApi: coll.disableDeltaChangesApi,\n          disableMeta: coll.disableMeta,\n          disableFreeze: coll.hasOwnProperty('disableFreeze') ? coll.disableFreeze : true\n        });\n\n        copyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? (coll.adaptiveBinaryIndices === true) : false;\n        copyColl.transactional = coll.transactional;\n        copyColl.asyncListeners = coll.asyncListeners;\n        copyColl.cloneObjects = coll.cloneObjects;\n        copyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n        copyColl.autoupdate = coll.autoupdate;\n        copyColl.changes = coll.changes;\n        copyColl.dirtyIds = coll.dirtyIds || [];\n\n        if (options && options.retainDirtyFlags === true) {\n          copyColl.dirty = coll.dirty;\n        }\n        else {\n          copyColl.dirty = false;\n        }\n\n        // load each element individually\n        clen = coll.data.length;\n        j = 0;\n        if (options && options.hasOwnProperty(coll.name)) {\n          loader = makeLoader(coll);\n\n          for (j; j < clen; j++) {\n            collObj = loader(coll.data[j]);\n            copyColl.data[j] = collObj;\n            copyColl.addAutoUpdateObserver(collObj);\n            if (!copyColl.disableFreeze) {\n              deepFreeze(copyColl.data[j]);\n            }\n          }\n        } else {\n\n          for (j; j < clen; j++) {\n            copyColl.data[j] = coll.data[j];\n            copyColl.addAutoUpdateObserver(copyColl.data[j]);\n            if (!copyColl.disableFreeze) {\n              deepFreeze(copyColl.data[j]);\n            }\n          }\n        }\n\n        copyColl.maxId = (typeof coll.maxId === 'undefined') ? 0 : coll.maxId;\n        if (typeof (coll.binaryIndices) !== 'undefined') {\n          copyColl.binaryIndices = coll.binaryIndices;\n        }\n        if (typeof coll.transforms !== 'undefined') {\n          copyColl.transforms = coll.transforms;\n        }\n\n        // regenerate unique indexes\n        copyColl.uniqueNames = [];\n        if (coll.hasOwnProperty(\"uniqueNames\")) {\n          copyColl.uniqueNames = coll.uniqueNames;\n        }\n\n        // in case they are loading a database created before we added dynamic views, handle undefined\n        if (typeof (coll.DynamicViews) === 'undefined') continue;\n\n        // reinflate DynamicViews and attached Resultsets\n        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n          var colldv = coll.DynamicViews[idx];\n\n          var dv = copyColl.addDynamicView(colldv.name, colldv.options);\n          dv.resultdata = colldv.resultdata;\n          dv.resultsdirty = colldv.resultsdirty;\n          dv.filterPipeline = colldv.filterPipeline;\n          dv.sortCriteriaSimple = colldv.sortCriteriaSimple;\n          dv.sortCriteria = colldv.sortCriteria;\n          dv.sortFunction = null;\n          dv.sortDirty = colldv.sortDirty;\n          if (!copyColl.disableFreeze) {\n            deepFreeze(dv.filterPipeline);\n            if (dv.sortCriteriaSimple) {\n              deepFreeze(dv.sortCriteriaSimple);\n            } else if (dv.sortCriteria) {\n              deepFreeze(dv.sortCriteria);\n            }\n          }\n          dv.resultset.filteredrows = colldv.resultset.filteredrows;\n          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n          dv.rematerialize({\n            removeWhereFilters: true\n          });\n        }\n\n        // Upgrade Logic for binary index refactoring at version 1.5\n        if (dbObject.databaseVersion < 1.5) {\n          // rebuild all indices\n          copyColl.ensureAllIndexes(true);\n          copyColl.dirty = true;\n        }\n      }\n    };\n\n    /**\n     * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n     * Does not actually destroy the db.\n     *\n     * @param {function=} callback - (Optional) if supplied will be registered with close event before emitting.\n     * @memberof Loki\n     */\n    Loki.prototype.close = function (callback) {\n      // for autosave scenarios, we will let close perform final save (if dirty)\n      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n      if (this.autosave) {\n        this.autosaveDisable();\n        if (this.autosaveDirty()) {\n          this.saveDatabase(callback);\n          callback = undefined;\n        }\n      }\n\n      if (callback) {\n        this.on('close', callback);\n      }\n      this.emit('close');\n    };\n\n    /**-------------------------+\n    | Changes API               |\n    +--------------------------*/\n\n    /**\n     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n     */\n\n    /**\n     * (Changes API) : takes all the changes stored in each\n     * collection and creates a single array for the entire database. If an array of names\n     * of collections is passed then only the included collections will be tracked.\n     *\n     * @param {array=} optional array of collection names. No arg means all collections are processed.\n     * @returns {array} array of changes\n     * @see private method createChange() in Collection\n     * @memberof Loki\n     */\n    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {\n      function getCollName(coll) {\n        return coll.name;\n      }\n      var changes = [],\n        selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n      this.collections.forEach(function (coll) {\n        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n          changes = changes.concat(coll.getChanges());\n        }\n      });\n      return changes;\n    };\n\n    /**\n     * (Changes API) - stringify changes for network transmission\n     * @returns {string} string representation of the changes\n     * @memberof Loki\n     */\n    Loki.prototype.serializeChanges = function (collectionNamesArray) {\n      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n    };\n\n    /**\n     * (Changes API) : clears all the changes in all collections.\n     * @memberof Loki\n     */\n    Loki.prototype.clearChanges = function () {\n      this.collections.forEach(function (coll) {\n        if (coll.flushChanges) {\n          coll.flushChanges();\n        }\n      });\n    };\n\n    /*------------------+\n    | PERSISTENCE       |\n    -------------------*/\n\n    /** there are two build in persistence adapters for internal use\n     * fs             for use in Nodejs type environments\n     * localStorage   for use in browser environment\n     * defined as helper classes here so its easy and clean to use\n     */\n\n    /**\n     * In in-memory persistence adapter for an in-memory database.\n     * This simple 'key/value' adapter is intended for unit testing and diagnostics.\n     *\n     * @param {object=} options - memory adapter options\n     * @param {boolean} [options.asyncResponses=false] - whether callbacks are invoked asynchronously\n     * @param {int} [options.asyncTimeout=50] - timeout in ms to queue callbacks\n     * @constructor LokiMemoryAdapter\n     */\n    function LokiMemoryAdapter(options) {\n      this.hashStore = {};\n      this.options = options || {};\n\n      if (!this.options.hasOwnProperty('asyncResponses')) {\n        this.options.asyncResponses = false;\n      }\n\n      if (!this.options.hasOwnProperty('asyncTimeout')) {\n        this.options.asyncTimeout = 50; // 50 ms default\n      }\n    }\n\n    /**\n     * Loads a serialized database from its in-memory store.\n     * (Loki persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - adapter callback to return load result to caller\n     * @memberof LokiMemoryAdapter\n     */\n    LokiMemoryAdapter.prototype.loadDatabase = function (dbname, callback) {\n      var self = this;\n\n      if (this.options.asyncResponses) {\n        setTimeout(function () {\n          if (self.hashStore.hasOwnProperty(dbname)) {\n            callback(self.hashStore[dbname].value);\n          }\n          else {\n            // database doesn't exist, return falsy\n            callback(null);\n          }\n        }, this.options.asyncTimeout);\n      }\n      else {\n        if (this.hashStore.hasOwnProperty(dbname)) {\n          // database doesn't exist, return falsy\n          callback(this.hashStore[dbname].value);\n        }\n        else {\n          callback(null);\n        }\n      }\n    };\n\n    /**\n     * Saves a serialized database to its in-memory store.\n     * (Loki persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - adapter callback to return load result to caller\n     * @memberof LokiMemoryAdapter\n     */\n    LokiMemoryAdapter.prototype.saveDatabase = function (dbname, dbstring, callback) {\n      var self = this;\n      var saveCount;\n\n      if (this.options.asyncResponses) {\n        setTimeout(function () {\n          saveCount = (self.hashStore.hasOwnProperty(dbname) ? self.hashStore[dbname].savecount : 0);\n\n          self.hashStore[dbname] = {\n            savecount: saveCount + 1,\n            lastsave: new Date(),\n            value: dbstring\n          };\n\n          callback();\n        }, this.options.asyncTimeout);\n      }\n      else {\n        saveCount = (this.hashStore.hasOwnProperty(dbname) ? this.hashStore[dbname].savecount : 0);\n\n        this.hashStore[dbname] = {\n          savecount: saveCount + 1,\n          lastsave: new Date(),\n          value: dbstring\n        };\n\n        callback();\n      }\n    };\n\n    /**\n     * Deletes a database from its in-memory store.\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - function to call when done\n     * @memberof LokiMemoryAdapter\n     */\n    LokiMemoryAdapter.prototype.deleteDatabase = function (dbname, callback) {\n      if (this.hashStore.hasOwnProperty(dbname)) {\n        delete this.hashStore[dbname];\n      }\n\n      if (typeof callback === \"function\") {\n        callback();\n      }\n    };\n\n    /**\n     * An adapter for adapters.  Converts a non reference mode adapter into a reference mode adapter\n     * which can perform destructuring and partioning.  Each collection will be stored in its own key/save and\n     * only dirty collections will be saved.  If you  turn on paging with default page size of 25megs and save\n     * a 75 meg collection it should use up roughly 3 save slots (key/value pairs sent to inner adapter).\n     * A dirty collection that spans three pages will save all three pages again\n     * Paging mode was added mainly because Chrome has issues saving 'too large' of a string within a\n     * single indexeddb row.  If a single document update causes the collection to be flagged as dirty, all\n     * of that collection's pages will be written on next save.\n     *\n     * @param {object} adapter - reference to a 'non-reference' mode loki adapter instance.\n     * @param {object=} options - configuration options for partitioning and paging\n     * @param {bool} options.paging - (default: false) set to true to enable paging collection data.\n     * @param {int} options.pageSize - (default : 25MB) you can use this to limit size of strings passed to inner adapter.\n     * @param {string} options.delimiter - allows you to override the default delimeter\n     * @constructor LokiPartitioningAdapter\n     */\n    function LokiPartitioningAdapter(adapter, options) {\n      this.mode = \"reference\";\n      this.adapter = null;\n      this.options = options || {};\n      this.dbref = null;\n      this.dbname = \"\";\n      this.pageIterator = {};\n\n      // verify user passed an appropriate adapter\n      if (adapter) {\n        if (adapter.mode === \"reference\") {\n          throw new Error(\"LokiPartitioningAdapter cannot be instantiated with a reference mode adapter\");\n        }\n        else {\n          this.adapter = adapter;\n        }\n      }\n      else {\n        throw new Error(\"LokiPartitioningAdapter requires a (non-reference mode) adapter on construction\");\n      }\n\n      // set collection paging defaults\n      if (!this.options.hasOwnProperty(\"paging\")) {\n        this.options.paging = false;\n      }\n\n      // default to page size of 25 megs (can be up to your largest serialized object size larger than this)\n      if (!this.options.hasOwnProperty(\"pageSize\")) {\n        this.options.pageSize = 25 * 1024 * 1024;\n      }\n\n      if (!this.options.hasOwnProperty(\"delimiter\")) {\n        this.options.delimiter = '$<\\n';\n      }\n    }\n\n    /**\n     * Loads a database which was partitioned into several key/value saves.\n     * (Loki persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {function} callback - adapter callback to return load result to caller\n     * @memberof LokiPartitioningAdapter\n     */\n    LokiPartitioningAdapter.prototype.loadDatabase = function (dbname, callback) {\n      var self = this;\n      this.dbname = dbname;\n      this.dbref = new Loki(dbname);\n\n      // load the db container (without data)\n      this.adapter.loadDatabase(dbname, function (result) {\n        // empty database condition is for inner adapter return null/undefined/falsy\n        if (!result) {\n          // partition 0 not found so new database, no need to try to load other partitions.\n          // return same falsy result to loadDatabase to signify no database exists (yet)\n          callback(result);\n          return;\n        }\n\n        if (typeof result !== \"string\") {\n          callback(new Error(\"LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()\"));\n        }\n\n        // I will want to use loki destructuring helper methods so i will inflate into typed instance\n        var db = JSON.parse(result);\n        self.dbref.loadJSONObject(db);\n        db = null;\n\n        var clen = self.dbref.collections.length;\n\n        if (self.dbref.collections.length === 0) {\n          callback(self.dbref);\n          return;\n        }\n\n        self.pageIterator = {\n          collection: 0,\n          pageIndex: 0\n        };\n\n        self.loadNextPartition(0, function () {\n          callback(self.dbref);\n        });\n      });\n    };\n\n    /**\n     * Used to sequentially load each collection partition, one at a time.\n     *\n     * @param {int} partition - ordinal collection position to load next\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n    LokiPartitioningAdapter.prototype.loadNextPartition = function (partition, callback) {\n      var keyname = this.dbname + \".\" + partition;\n      var self = this;\n\n      if (this.options.paging === true) {\n        this.pageIterator.pageIndex = 0;\n        this.loadNextPage(callback);\n        return;\n      }\n\n      this.adapter.loadDatabase(keyname, function (result) {\n        var data = self.dbref.deserializeCollection(result, { delimited: true, collectionIndex: partition });\n        self.dbref.collections[partition].data = data;\n\n        if (++partition < self.dbref.collections.length) {\n          self.loadNextPartition(partition, callback);\n        }\n        else {\n          callback();\n        }\n      });\n    };\n\n    /**\n     * Used to sequentially load the next page of collection partition, one at a time.\n     *\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n    LokiPartitioningAdapter.prototype.loadNextPage = function (callback) {\n      // calculate name for next saved page in sequence\n      var keyname = this.dbname + \".\" + this.pageIterator.collection + \".\" + this.pageIterator.pageIndex;\n      var self = this;\n\n      // load whatever page is next in sequence\n      this.adapter.loadDatabase(keyname, function (result) {\n        var data = result.split(self.options.delimiter);\n        result = \"\"; // free up memory now that we have split it into array\n        var dlen = data.length;\n        var idx;\n\n        // detect if last page by presence of final empty string element and remove it if so\n        var isLastPage = (data[dlen - 1] === \"\");\n        if (isLastPage) {\n          data.pop();\n          dlen = data.length;\n          // empty collections are just a delimiter meaning two blank items\n          if (data[dlen - 1] === \"\" && dlen === 1) {\n            data.pop();\n            dlen = data.length;\n          }\n        }\n\n        // convert stringified array elements to object instances and push to collection data\n        for (idx = 0; idx < dlen; idx++) {\n          self.dbref.collections[self.pageIterator.collection].data.push(JSON.parse(data[idx]));\n          data[idx] = null;\n        }\n        data = [];\n\n        // if last page, we are done with this partition\n        if (isLastPage) {\n\n          // if there are more partitions, kick off next partition load\n          if (++self.pageIterator.collection < self.dbref.collections.length) {\n            self.loadNextPartition(self.pageIterator.collection, callback);\n          }\n          else {\n            callback();\n          }\n        }\n        else {\n          self.pageIterator.pageIndex++;\n          self.loadNextPage(callback);\n        }\n      });\n    };\n\n    /**\n     * Saves a database by partioning into separate key/value saves.\n     * (Loki 'reference mode' persistence adapter interface function)\n     *\n     * @param {string} dbname - name of the database (filename/keyname)\n     * @param {object} dbref - reference to database which we will partition and save.\n     * @param {function} callback - adapter callback to return load result to caller\n     *\n     * @memberof LokiPartitioningAdapter\n     */\n    LokiPartitioningAdapter.prototype.exportDatabase = function (dbname, dbref, callback) {\n      var self = this;\n      var idx, clen = dbref.collections.length;\n\n      this.dbref = dbref;\n      this.dbname = dbname;\n\n      // queue up dirty partitions to be saved\n      this.dirtyPartitions = [-1];\n      for (idx = 0; idx < clen; idx++) {\n        if (dbref.collections[idx].dirty) {\n          this.dirtyPartitions.push(idx);\n        }\n      }\n\n      this.saveNextPartition(function (err) {\n        callback(err);\n      });\n    };\n\n    /**\n     * Helper method used internally to save each dirty collection, one at a time.\n     *\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n    LokiPartitioningAdapter.prototype.saveNextPartition = function (callback) {\n      var self = this;\n      var partition = this.dirtyPartitions.shift();\n      var keyname = this.dbname + ((partition === -1) ? \"\" : (\".\" + partition));\n\n      // if we are doing paging and this is collection partition\n      if (this.options.paging && partition !== -1) {\n        this.pageIterator = {\n          collection: partition,\n          docIndex: 0,\n          pageIndex: 0\n        };\n\n        // since saveNextPage recursively calls itself until done, our callback means this whole paged partition is finished\n        this.saveNextPage(function (err) {\n          if (self.dirtyPartitions.length === 0) {\n            callback(err);\n          }\n          else {\n            self.saveNextPartition(callback);\n          }\n        });\n        return;\n      }\n\n      // otherwise this is 'non-paged' partioning...\n      var result = this.dbref.serializeDestructured({\n        partitioned: true,\n        delimited: true,\n        partition: partition\n      });\n\n      this.adapter.saveDatabase(keyname, result, function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        if (self.dirtyPartitions.length === 0) {\n          callback(null);\n        }\n        else {\n          self.saveNextPartition(callback);\n        }\n      });\n    };\n\n    /**\n     * Helper method used internally to generate and save the next page of the current (dirty) partition.\n     *\n     * @param {function} callback - adapter callback to return load result to caller\n     */\n    LokiPartitioningAdapter.prototype.saveNextPage = function (callback) {\n      var self = this;\n      var coll = this.dbref.collections[this.pageIterator.collection];\n      var keyname = this.dbname + \".\" + this.pageIterator.collection + \".\" + this.pageIterator.pageIndex;\n      var pageLen = 0,\n        cdlen = coll.data.length,\n        delimlen = this.options.delimiter.length;\n      var serializedObject = \"\",\n        pageBuilder = \"\";\n      var doneWithPartition = false,\n        doneWithPage = false;\n\n      var pageSaveCallback = function (err) {\n        pageBuilder = \"\";\n\n        if (err) {\n          callback(err);\n        }\n\n        // update meta properties then continue process by invoking callback\n        if (doneWithPartition) {\n          callback(null);\n        }\n        else {\n          self.pageIterator.pageIndex++;\n          self.saveNextPage(callback);\n        }\n      };\n\n      if (coll.data.length === 0) {\n        doneWithPartition = true;\n      }\n\n      while (true) {\n        if (!doneWithPartition) {\n          // serialize object\n          serializedObject = JSON.stringify(coll.data[this.pageIterator.docIndex]);\n          pageBuilder += serializedObject;\n          pageLen += serializedObject.length;\n\n          // if no more documents in collection to add, we are done with partition\n          if (++this.pageIterator.docIndex >= cdlen) doneWithPartition = true;\n        }\n        // if our current page is bigger than defined pageSize, we are done with page\n        if (pageLen >= this.options.pageSize) doneWithPage = true;\n\n        // if not done with current page, need delimiter before next item\n        // if done with partition we also want a delmiter to indicate 'end of pages' final empty row\n        if (!doneWithPage || doneWithPartition) {\n          pageBuilder += this.options.delimiter;\n          pageLen += delimlen;\n        }\n\n        // if we are done with page save it and pass off to next recursive call or callback\n        if (doneWithPartition || doneWithPage) {\n          this.adapter.saveDatabase(keyname, pageBuilder, pageSaveCallback);\n          return;\n        }\n      }\n    };\n\n    /**\n     * A loki persistence adapter which persists using node fs module\n     * @constructor LokiFsAdapter\n     */\n    function LokiFsAdapter() {\n      try {\n        this.fs = require('fs');\n      } catch (e) {\n        this.fs = null;\n      }\n    }\n\n    /**\n     * loadDatabase() - Load data from file, will throw an error if the file does not exist\n     * @param {string} dbname - the filename of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiFsAdapter\n     */\n    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {\n      var self = this;\n\n      this.fs.stat(dbname, function (err, stats) {\n        if (!err && stats.isFile()) {\n          self.fs.readFile(dbname, {\n            encoding: 'utf8'\n          }, function readFileCallback(err, data) {\n            if (err) {\n              callback(new Error(err));\n            } else {\n              callback(data);\n            }\n          });\n        }\n        else {\n          callback(null);\n        }\n      });\n    };\n\n    /**\n     * saveDatabase() - save data to file, will throw an error if the file can't be saved\n     * might want to expand this to avoid dataloss on partial save\n     * @param {string} dbname - the filename of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiFsAdapter\n     */\n    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {\n      var self = this;\n      var tmpdbname = dbname + '~';\n      this.fs.writeFile(tmpdbname, dbstring, function writeFileCallback(err) {\n        if (err) {\n          callback(new Error(err));\n        } else {\n          self.fs.rename(tmpdbname, dbname, callback);\n        }\n      });\n    };\n\n    /**\n     * deleteDatabase() - delete the database file, will throw an error if the\n     * file can't be deleted\n     * @param {string} dbname - the filename of the database to delete\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiFsAdapter\n     */\n    LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {\n      this.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n        if (err) {\n          callback(new Error(err));\n        } else {\n          callback();\n        }\n      });\n    };\n\n\n    /**\n     * A loki persistence adapter which persists to web browser's local storage object\n     * @constructor LokiLocalStorageAdapter\n     */\n    function LokiLocalStorageAdapter() { }\n\n    /**\n     * loadDatabase() - Load data from localstorage\n     * @param {string} dbname - the name of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiLocalStorageAdapter\n     */\n    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {\n      if (localStorageAvailable()) {\n        callback(localStorage.getItem(dbname));\n      } else {\n        callback(new Error('localStorage is not available'));\n      }\n    };\n\n    /**\n     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n     * might want to expand this to avoid dataloss on partial save\n     * @param {string} dbname - the filename of the database to load\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiLocalStorageAdapter\n     */\n    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {\n      if (localStorageAvailable()) {\n        localStorage.setItem(dbname, dbstring);\n        callback(null);\n      } else {\n        callback(new Error('localStorage is not available'));\n      }\n    };\n\n    /**\n     * deleteDatabase() - delete the database from localstorage, will throw an error if it\n     * can't be deleted\n     * @param {string} dbname - the filename of the database to delete\n     * @param {function} callback - the callback to handle the result\n     * @memberof LokiLocalStorageAdapter\n     */\n    LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {\n      if (localStorageAvailable()) {\n        localStorage.removeItem(dbname);\n        callback(null);\n      } else {\n        callback(new Error('localStorage is not available'));\n      }\n    };\n\n    /**\n     * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.\n     *\n     * @param {function} callback - callback to fire when save queue is drained, it is passed a sucess parameter value\n     * @param {object=} options - configuration options\n     * @param {boolean} options.recursiveWait - (default: true) if after queue is drained, another save was kicked off, wait for it\n     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n     * @memberof Loki\n     */\n    Loki.prototype.throttledSaveDrain = function (callback, options) {\n      var self = this;\n      var now = (new Date()).getTime();\n\n      if (!this.throttledSaves) {\n        callback(true);\n      }\n\n      options = options || {};\n      if (!options.hasOwnProperty('recursiveWait')) {\n        options.recursiveWait = true;\n      }\n      if (!options.hasOwnProperty('recursiveWaitLimit')) {\n        options.recursiveWaitLimit = false;\n      }\n      if (!options.hasOwnProperty('recursiveWaitLimitDuration')) {\n        options.recursiveWaitLimitDuration = 2000;\n      }\n      if (!options.hasOwnProperty('started')) {\n        options.started = (new Date()).getTime();\n      }\n\n      // if save is pending\n      if (this.throttledSaves && this.throttledSavePending) {\n        // if we want to wait until we are in a state where there are no pending saves at all\n        if (options.recursiveWait) {\n          // queue the following meta callback for when it completes\n          this.throttledCallbacks.push(function () {\n            // if there is now another save pending...\n            if (self.throttledSavePending) {\n              // if we wish to wait only so long and we have exceeded limit of our waiting, callback with false success value\n              if (options.recursiveWaitLimit && (now - options.started > options.recursiveWaitLimitDuration)) {\n                callback(false);\n                return;\n              }\n              // it must be ok to wait on next queue drain\n              self.throttledSaveDrain(callback, options);\n              return;\n            }\n            // no pending saves so callback with true success\n            else {\n              callback(true);\n              return;\n            }\n          });\n        }\n        // just notify when current queue is depleted\n        else {\n          this.throttledCallbacks.push(callback);\n          return;\n        }\n      }\n      // no save pending, just callback\n      else {\n        callback(true);\n      }\n    };\n\n    /**\n     * Internal load logic, decoupled from throttling/contention logic\n     *\n     * @param {object} options - not currently used (remove or allow overrides?)\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     */\n    Loki.prototype.loadDatabaseInternal = function (options, callback) {\n      var cFun = callback || function (err, data) {\n        if (err) {\n          throw err;\n        }\n      },\n        self = this;\n\n      // the persistenceAdapter should be present if all is ok, but check to be sure.\n      if (this.persistenceAdapter !== null) {\n\n        this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {\n          if (typeof (dbString) === 'string') {\n            var parseSuccess = false;\n            try {\n              self.loadJSON(dbString, options || {});\n              parseSuccess = true;\n            } catch (err) {\n              cFun(err);\n            }\n            if (parseSuccess) {\n              cFun(null);\n              self.emit('loaded', 'database ' + self.filename + ' loaded');\n            }\n          } else {\n            // falsy result means new database\n            if (!dbString) {\n              cFun(null);\n              self.emit('loaded', 'empty database ' + self.filename + ' loaded');\n              return;\n            }\n\n            // instanceof error means load faulted\n            if (dbString instanceof Error) {\n              cFun(dbString);\n              return;\n            }\n\n            // if adapter has returned an js object (other than null or error) attempt to load from JSON object\n            if (typeof (dbString) === \"object\") {\n              self.loadJSONObject(dbString, options || {});\n              cFun(null); // return null on success\n              self.emit('loaded', 'database ' + self.filename + ' loaded');\n              return;\n            }\n\n            cFun(\"unexpected adapter response : \" + dbString);\n          }\n        });\n\n      } else {\n        cFun(new Error('persistenceAdapter not configured'));\n      }\n    };\n\n    /**\n     * Handles manually loading from file system, local storage, or adapter (such as indexeddb)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *    To avoid contention with any throttledSaves, we will drain the save queue first.\n     *\n     * If you are configured with autosave, you do not need to call this method yourself.\n     *\n     * @param {object} options - if throttling saves and loads, this controls how we drain save queue before loading\n     * @param {boolean} options.recursiveWait - (default: true) wait recursively until no saves are queued\n     * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n     * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     * @memberof Loki\n     * @example\n     * db.loadDatabase({}, function(err) {\n     *   if (err) {\n     *     console.log(\"error : \" + err);\n     *   }\n     *   else {\n     *     console.log(\"database loaded.\");\n     *   }\n     * });\n     */\n    Loki.prototype.loadDatabase = function (options, callback) {\n      var self = this;\n\n      // if throttling disabled, just call internal\n      if (!this.throttledSaves) {\n        this.loadDatabaseInternal(options, callback);\n        return;\n      }\n\n      // try to drain any pending saves in the queue to lock it for loading\n      this.throttledSaveDrain(function (success) {\n        if (success) {\n          // pause/throttle saving until loading is done\n          self.throttledSavePending = true;\n\n          self.loadDatabaseInternal(options, function (err) {\n            // now that we are finished loading, if no saves were throttled, disable flag\n            if (self.throttledCallbacks.length === 0) {\n              self.throttledSavePending = false;\n            }\n            // if saves requests came in while loading, kick off new save to kick off resume saves\n            else {\n              self.saveDatabase();\n            }\n\n            if (typeof callback === 'function') {\n              callback(err);\n            }\n          });\n          return;\n        }\n        else {\n          if (typeof callback === 'function') {\n            callback(new Error(\"Unable to pause save throttling long enough to read database\"));\n          }\n        }\n      }, options);\n    };\n\n    /**\n     * Internal save logic, decoupled from save throttling logic\n     */\n    Loki.prototype.saveDatabaseInternal = function (callback) {\n      var cFun = callback || function (err) {\n        if (err) {\n          throw err;\n        }\n        return;\n      };\n      var self = this;\n\n      // the persistenceAdapter should be present if all is ok, but check to be sure.\n      if (!this.persistenceAdapter) {\n        cFun(new Error('persistenceAdapter not configured'));\n        return;\n      }\n\n      // run incremental, reference, or normal mode adapters, depending on what's available\n      if (this.persistenceAdapter.mode === \"incremental\") {\n        var cachedDirty;\n        // ignore autosave until we copy loki (only then we can clear dirty flags,\n        // but if we don't do it now, autosave will be triggered a lot unnecessarily)\n        this.ignoreAutosave = true;\n        this.persistenceAdapter.saveDatabase(\n          this.filename,\n          function getLokiCopy() {\n            self.ignoreAutosave = false;\n            if (cachedDirty) {\n              cFun(new Error('adapter error - getLokiCopy called more than once'));\n              return;\n            }\n            var lokiCopy = self.copy({ removeNonSerializable: true });\n\n            // remember and clear dirty ids -- we must do it before the save so that if\n            // and update occurs between here and callback, it will get saved later\n            cachedDirty = self.collections.map(function (collection) {\n              return [collection.dirty, collection.dirtyIds];\n            });\n            self.collections.forEach(function (col) {\n              col.dirty = false;\n              col.dirtyIds = [];\n            });\n            return lokiCopy;\n          },\n          function exportDatabaseCallback(err) {\n            self.ignoreAutosave = false;\n            if (err && cachedDirty) {\n              // roll back dirty IDs to be saved later\n              self.collections.forEach(function (col, i) {\n                var cached = cachedDirty[i];\n                col.dirty = col.dirty || cached[0];\n                col.dirtyIds = col.dirtyIds.concat(cached[1]);\n              });\n            }\n            cFun(err);\n          });\n      } else if (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n        // TODO: dirty should be cleared here\n        // filename may seem redundant but loadDatabase will need to expect this same filename\n        this.persistenceAdapter.exportDatabase(this.filename, this.copy({ removeNonSerializable: true }), function exportDatabaseCallback(err) {\n          self.autosaveClearFlags();\n          cFun(err);\n        });\n      }\n      // otherwise just pass the serialized database to adapter\n      else {\n        // persistenceAdapter might be asynchronous, so we must clear `dirty` immediately\n        // or autosave won't work if an update occurs between here and the callback\n        // TODO: This should be stored and rolled back in case of DB save failure\n        this.autosaveClearFlags();\n        this.persistenceAdapter.saveDatabase(this.filename, this.serialize(), function saveDatabasecallback(err) {\n          cFun(err);\n        });\n      }\n    };\n\n    /**\n     * Handles manually saving to file system, local storage, or adapter (such as indexeddb)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *\n     * If you are configured with autosave, you do not need to call this method yourself.\n     *\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     * @memberof Loki\n     * @example\n     * db.saveDatabase(function(err) {\n     *   if (err) {\n     *     console.log(\"error : \" + err);\n     *   }\n     *   else {\n     *     console.log(\"database saved.\");\n     *   }\n     * });\n     */\n    Loki.prototype.saveDatabase = function (callback) {\n      if (!this.throttledSaves) {\n        this.saveDatabaseInternal(callback);\n        return;\n      }\n\n      if (this.throttledSavePending) {\n        this.throttledCallbacks.push(callback);\n        return;\n      }\n\n      var localCallbacks = this.throttledCallbacks;\n      this.throttledCallbacks = [];\n      localCallbacks.unshift(callback);\n      this.throttledSavePending = true;\n\n      var self = this;\n      this.saveDatabaseInternal(function (err) {\n        self.throttledSavePending = false;\n        localCallbacks.forEach(function (pcb) {\n          if (typeof pcb === 'function') {\n            // Queue the callbacks so we first finish this method execution\n            setTimeout(function () {\n              pcb(err);\n            }, 1);\n          }\n        });\n\n        // since this is called async, future requests may have come in, if so.. kick off next save\n        if (self.throttledCallbacks.length > 0) {\n          self.saveDatabase();\n        }\n      });\n    };\n\n    // alias\n    Loki.prototype.save = Loki.prototype.saveDatabase;\n\n    /**\n     * Handles deleting a database from file system, local\n     *    storage, or adapter (indexeddb)\n     *    This method utilizes loki configuration options (if provided) to determine which\n     *    persistence method to use, or environment detection (if configuration was not provided).\n     *\n     * @param {function=} callback - (Optional) user supplied async callback / error handler\n     * @memberof Loki\n     */\n    Loki.prototype.deleteDatabase = function (options, callback) {\n      var cFun = callback || function (err, data) {\n        if (err) {\n          throw err;\n        }\n      };\n\n      // we aren't even using options, so we will support syntax where\n      // callback is passed as first and only argument\n      if (typeof options === 'function' && !callback) {\n        cFun = options;\n      }\n\n      // the persistenceAdapter should be present if all is ok, but check to be sure.\n      if (this.persistenceAdapter !== null) {\n        this.persistenceAdapter.deleteDatabase(this.filename, function deleteDatabaseCallback(err) {\n          cFun(err);\n        });\n      } else {\n        cFun(new Error('persistenceAdapter not configured'));\n      }\n    };\n\n    /**\n     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n     *\n     * @returns {boolean} - true if database has changed since last autosave, false if not.\n     */\n    Loki.prototype.autosaveDirty = function () {\n      for (var idx = 0; idx < this.collections.length; idx++) {\n        if (this.collections[idx].dirty) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    /**\n     * autosaveClearFlags - resets dirty flags on all collections.\n     *    Called from saveDatabase() after db is saved.\n     *\n     */\n    Loki.prototype.autosaveClearFlags = function () {\n      for (var idx = 0; idx < this.collections.length; idx++) {\n        this.collections[idx].dirty = false;\n      }\n    };\n\n    /**\n     * autosaveEnable - begin a javascript interval to periodically save the database.\n     *\n     * @param {object} options - not currently used (remove or allow overrides?)\n     * @param {function=} callback - (Optional) user supplied async callback\n     */\n    Loki.prototype.autosaveEnable = function (options, callback) {\n      this.autosave = true;\n\n      var delay = 5000,\n        self = this;\n\n      if (typeof (this.autosaveInterval) !== 'undefined' && this.autosaveInterval !== null) {\n        delay = this.autosaveInterval;\n      }\n\n      this.autosaveHandle = setInterval(function autosaveHandleInterval() {\n        // use of dirty flag will need to be hierarchical since mods are done at collection level with no visibility of 'db'\n        // so next step will be to implement collection level dirty flags set on insert/update/remove\n        // along with loki level isdirty() function which iterates all collections to see if any are dirty\n\n        if (self.autosaveDirty() && !self.ignoreAutosave) {\n          self.saveDatabase(callback);\n        }\n      }, delay);\n    };\n\n    /**\n     * autosaveDisable - stop the autosave interval timer.\n     *\n     */\n    Loki.prototype.autosaveDisable = function () {\n      if (typeof (this.autosaveHandle) !== 'undefined' && this.autosaveHandle !== null) {\n        clearInterval(this.autosaveHandle);\n        this.autosaveHandle = null;\n      }\n    };\n\n\n    /**\n     * Resultset class allowing chainable queries.  Intended to be instanced internally.\n     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n     *\n     * @example\n     *    mycollection.chain()\n     *      .find({ 'doors' : 4 })\n     *      .where(function(obj) { return obj.name === 'Toyota' })\n     *      .data();\n     *\n     * @constructor Resultset\n     * @param {Collection} collection - The collection which this Resultset will query against.\n     */\n    function Resultset(collection, options) {\n      options = options || {};\n\n      // retain reference to collection we are querying against\n      this.collection = collection;\n      this.filteredrows = [];\n      this.filterInitialized = false;\n\n      return this;\n    }\n\n    /**\n     * reset() - Reset the resultset to its initial state.\n     *\n     * @returns {Resultset} Reference to this resultset, for future chain operations.\n     */\n    Resultset.prototype.reset = function () {\n      if (this.filteredrows.length > 0) {\n        this.filteredrows = [];\n      }\n      this.filterInitialized = false;\n      return this;\n    };\n\n    /**\n     * toJSON() - Override of toJSON to avoid circular references\n     *\n     */\n    Resultset.prototype.toJSON = function () {\n      var copy = this.copy();\n      copy.collection = null;\n      return copy;\n    };\n\n    /**\n     * Allows you to limit the number of documents passed to next chain operation.\n     *    A resultset copy() is made to avoid altering original resultset.\n     *\n     * @param {int} qty - The number of documents to return.\n     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n     * @memberof Resultset\n     * // find the two oldest users\n     * var result = users.chain().simplesort(\"age\", true).limit(2).data();\n     */\n    Resultset.prototype.limit = function (qty) {\n      // if this has no filters applied, we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var rscopy = new Resultset(this.collection);\n      rscopy.filteredrows = this.filteredrows.slice(0, qty);\n      rscopy.filterInitialized = true;\n      return rscopy;\n    };\n\n    /**\n     * Used for skipping 'pos' number of documents in the resultset.\n     *\n     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n     * @memberof Resultset\n     * // find everyone but the two oldest users\n     * var result = users.chain().simplesort(\"age\", true).offset(2).data();\n     */\n    Resultset.prototype.offset = function (pos) {\n      // if this has no filters applied, we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var rscopy = new Resultset(this.collection);\n      rscopy.filteredrows = this.filteredrows.slice(pos);\n      rscopy.filterInitialized = true;\n      return rscopy;\n    };\n\n    /**\n     * copy() - To support reuse of resultset in branched query situations.\n     *\n     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n     * @memberof Resultset\n     */\n    Resultset.prototype.copy = function () {\n      var result = new Resultset(this.collection);\n\n      if (this.filteredrows.length > 0) {\n        result.filteredrows = this.filteredrows.slice();\n      }\n      result.filterInitialized = this.filterInitialized;\n\n      return result;\n    };\n\n    /**\n     * Alias of copy()\n     * @memberof Resultset\n     */\n    Resultset.prototype.branch = Resultset.prototype.copy;\n\n    /**\n     * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n     *\n     * @param transform {(string|array)} - name of collection transform or raw transform array\n     * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n     * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n     * @memberof Resultset\n     * @example\n     * users.addTransform('CountryFilter', [\n     *   {\n     *     type: 'find',\n     *     value: {\n     *       'country': { $eq: '[%lktxp]Country' }\n     *     }\n     *   },\n     *   {\n     *     type: 'simplesort',\n     *     property: 'age',\n     *     options: { desc: false}\n     *   }\n     * ]);\n     * var results = users.chain().transform(\"CountryFilter\", { Country: 'fr' }).data();\n     */\n    Resultset.prototype.transform = function (transform, parameters) {\n      var idx,\n        step,\n        rs = this;\n\n      // if transform is name, then do lookup first\n      if (typeof transform === 'string') {\n        if (this.collection.transforms.hasOwnProperty(transform)) {\n          transform = this.collection.transforms[transform];\n        }\n      }\n\n      // either they passed in raw transform array or we looked it up, so process\n      if (typeof transform !== 'object' || !Array.isArray(transform)) {\n        throw new Error(\"Invalid transform\");\n      }\n\n      if (typeof parameters !== 'undefined') {\n        transform = Utils.resolveTransformParams(transform, parameters);\n      }\n\n      for (idx = 0; idx < transform.length; idx++) {\n        step = transform[idx];\n\n        switch (step.type) {\n          case \"find\":\n            rs.find(step.value);\n            break;\n          case \"where\":\n            rs.where(step.value);\n            break;\n          case \"simplesort\":\n            rs.simplesort(step.property, step.desc || step.options);\n            break;\n          case \"compoundsort\":\n            rs.compoundsort(step.value);\n            break;\n          case \"sort\":\n            rs.sort(step.value);\n            break;\n          case \"limit\":\n            rs = rs.limit(step.value);\n            break; // limit makes copy so update reference\n          case \"offset\":\n            rs = rs.offset(step.value);\n            break; // offset makes copy so update reference\n          case \"map\":\n            rs = rs.map(step.value, step.dataOptions);\n            break;\n          case \"eqJoin\":\n            rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun, step.dataOptions);\n            break;\n          // following cases break chain by returning array data so make any of these last in transform steps\n          case \"mapReduce\":\n            rs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n            break;\n          // following cases update documents in current filtered resultset (use carefully)\n          case \"update\":\n            rs.update(step.value);\n            break;\n          case \"remove\":\n            rs.remove();\n            break;\n          default:\n            break;\n        }\n      }\n\n      return rs;\n    };\n\n    /**\n     * User supplied compare function is provided two documents to compare. (chainable)\n     * @example\n     *    rslt.sort(function(obj1, obj2) {\n     *      if (obj1.name === obj2.name) return 0;\n     *      if (obj1.name > obj2.name) return 1;\n     *      if (obj1.name < obj2.name) return -1;\n     *    });\n     *\n     * @param {function} comparefun - A javascript compare function used for sorting.\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     */\n    Resultset.prototype.sort = function (comparefun) {\n      // if this has no filters applied, just we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var wrappedComparer =\n        (function (userComparer, data) {\n          return function (a, b) {\n            return userComparer(data[a], data[b]);\n          };\n        })(comparefun, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n\n      return this;\n    };\n\n    /**\n     * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n     *    Sorting based on the same lt/gt helper functions used for binary indices.\n     *\n     * @param {string} propname - name of property to sort by.\n     * @param {object|bool=} options - boolean to specify if isdescending, or options object\n     * @param {boolean} [options.desc=false] - whether to sort descending\n     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.\n     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).\n     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     * @example\n     * var results = users.chain().simplesort('age').data();\n     */\n    Resultset.prototype.simplesort = function (propname, options) {\n      var eff,\n        targetEff = 10,\n        dc = this.collection.data.length,\n        frl = this.filteredrows.length,\n        hasBinaryIndex = this.collection.binaryIndices.hasOwnProperty(propname);\n\n      if (typeof (options) === 'undefined' || options === false) {\n        options = { desc: false };\n      }\n      if (options === true) {\n        options = { desc: true };\n      }\n\n      // if nothing in filtered rows array...\n      if (frl === 0) {\n        // if the filter is initialized to be empty resultset, do nothing\n        if (this.filterInitialized) {\n          return this;\n        }\n\n        // otherwise no filters applied implies all documents, so we need to populate filteredrows first\n\n        // if we have a binary index, we can just use that instead of sorting (again)\n        if (this.collection.binaryIndices.hasOwnProperty(propname)) {\n          // make sure index is up-to-date\n          this.collection.ensureIndex(propname);\n          // copy index values into filteredrows\n          this.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\n          if (options.desc) {\n            this.filteredrows.reverse();\n          }\n\n          // we are done, return this (resultset) for further chain ops\n          return this;\n        }\n        // otherwise initialize array for sort below\n        else {\n          // build full document index (to be sorted subsequently)\n          this.filteredrows = this.collection.prepareFullDocIndex();\n        }\n      }\n      // otherwise we had results to begin with, see if we qualify for index intercept optimization\n      else {\n\n        // If already filtered, but we want to leverage binary index on sort.\n        // This will use custom array intection algorithm.\n        if (!options.disableIndexIntersect && hasBinaryIndex) {\n\n          // calculate filter efficiency\n          eff = dc / frl;\n\n          // when javascript sort fallback is enabled, you generally need more than ~17% of total docs in resultset\n          // before array intersect is determined to be the faster algorithm, otherwise leave at 10% for loki sort.\n          if (options.useJavascriptSorting) {\n            targetEff = 6;\n          }\n\n          // anything more than ratio of 10:1 (total documents/current results) should use old sort code path\n          // So we will only use array intersection if you have more than 10% of total docs in your current resultset.\n          if (eff <= targetEff || options.forceIndexIntersect) {\n            var idx, fr = this.filteredrows;\n            var io = {};\n            // set up hashobject for simple 'inclusion test' with existing (filtered) results\n            for (idx = 0; idx < frl; idx++) {\n              io[fr[idx]] = true;\n            }\n            // grab full sorted binary index array\n            var pv = this.collection.binaryIndices[propname].values;\n\n            // filter by existing results\n            this.filteredrows = pv.filter(function (n) { return io[n]; });\n\n            if (options.desc) {\n              this.filteredrows.reverse();\n            }\n\n            return this;\n          }\n        }\n      }\n\n      // at this point, we will not be able to leverage binary index so we will have to do an array sort\n\n      // if we have opted to use simplified javascript comparison function...\n      if (options.useJavascriptSorting) {\n        return this.sort(function (obj1, obj2) {\n          if (obj1[propname] === obj2[propname]) return 0;\n          if (obj1[propname] > obj2[propname]) return 1;\n          if (obj1[propname] < obj2[propname]) return -1;\n        });\n      }\n\n      // otherwise use loki sort which will return same results if column is indexed or not\n      var wrappedComparer =\n        (function (prop, desc, data) {\n          var val1, val2, arr;\n          return function (a, b) {\n            if (~prop.indexOf('.')) {\n              arr = prop.split('.');\n              val1 = Utils.getIn(data[a], arr, true);\n              val2 = Utils.getIn(data[b], arr, true);\n            } else {\n              val1 = data[a][prop];\n              val2 = data[b][prop];\n            }\n            return sortHelper(val1, val2, desc);\n          };\n        })(propname, options.desc, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n\n      return this;\n    };\n\n    /**\n     * Allows sorting a resultset based on multiple columns.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * rs.compoundsort(['age', 'name']);\n     * // to sort by age (ascending) and then by name (descending)\n     * rs.compoundsort(['age', ['name', true]]);\n     *\n     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     */\n    Resultset.prototype.compoundsort = function (properties) {\n      if (properties.length === 0) {\n        throw new Error(\"Invalid call to compoundsort, need at least one property\");\n      }\n\n      var prop;\n      if (properties.length === 1) {\n        prop = properties[0];\n        if (Array.isArray(prop)) {\n          return this.simplesort(prop[0], prop[1]);\n        }\n        return this.simplesort(prop, false);\n      }\n\n      // unify the structure of 'properties' to avoid checking it repeatedly while sorting\n      for (var i = 0, len = properties.length; i < len; i += 1) {\n        prop = properties[i];\n        if (!Array.isArray(prop)) {\n          properties[i] = [prop, false];\n        }\n      }\n\n      // if this has no filters applied, just we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var wrappedComparer =\n        (function (props, data) {\n          return function (a, b) {\n            return compoundeval(props, data[a], data[b]);\n          };\n        })(properties, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n\n      return this;\n    };\n\n    /**\n     * findOr() - oversee the operation of OR'ed query expressions.\n     *    OR'ed expression evaluation runs each expression individually against the full collection,\n     *    and finally does a set OR on each expression's results.\n     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n     *\n     * @param {array} expressionArray - array of expressions\n     * @returns {Resultset} this resultset for further chain ops.\n     */\n    Resultset.prototype.findOr = function (expressionArray) {\n      var fr = null,\n        fri = 0,\n        frlen = 0,\n        docset = [],\n        idxset = [],\n        idx = 0,\n        origCount = this.count();\n\n      // If filter is already initialized, then we query against only those items already in filter.\n      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n      for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n        // we need to branch existing query to run each filter separately and combine results\n        fr = this.branch().find(expressionArray[ei]).filteredrows;\n        frlen = fr.length;\n\n        // add any document 'hits'\n        for (fri = 0; fri < frlen; fri++) {\n          idx = fr[fri];\n          if (idxset[idx] === undefined) {\n            idxset[idx] = true;\n            docset.push(idx);\n          }\n        }\n      }\n\n      this.filteredrows = docset;\n      this.filterInitialized = true;\n\n      return this;\n    };\n    Resultset.prototype.$or = Resultset.prototype.findOr;\n\n    // precompile recursively\n    function precompileQuery(operator, value) {\n      // for regex ops, precompile\n      if (operator === '$regex') {\n        if (Array.isArray(value)) {\n          value = new RegExp(value[0], value[1]);\n        } else if (!(value instanceof RegExp)) {\n          value = new RegExp(value);\n        }\n      }\n      else if (typeof value === 'object') {\n        for (var key in value) {\n          if (key === '$regex' || typeof value[key] === 'object') {\n            value[key] = precompileQuery(key, value[key]);\n          }\n        }\n      }\n\n      return value;\n    }\n\n    /**\n     * findAnd() - oversee the operation of AND'ed query expressions.\n     *    AND'ed expression evaluation runs each expression progressively against the full collection,\n     *    internally utilizing existing chained resultset functionality.\n     *    Only the first filter can utilize a binary index.\n     *\n     * @param {array} expressionArray - array of expressions\n     * @returns {Resultset} this resultset for further chain ops.\n     */\n    Resultset.prototype.findAnd = function (expressionArray) {\n      // we have already implementing method chaining in this (our Resultset class)\n      // so lets just progressively apply user supplied and filters\n      for (var i = 0, len = expressionArray.length; i < len; i++) {\n        if (this.count() === 0) {\n          return this;\n        }\n        this.find(expressionArray[i]);\n      }\n      return this;\n    };\n    Resultset.prototype.$and = Resultset.prototype.findAnd;\n\n    /**\n     * Used for querying via a mongo-style query object.\n     *\n     * @param {object} query - A mongo-style query object used for filtering current results.\n     * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * var over30 = users.chain().find({ age: { $gte: 30 } }).data();\n     */\n    Resultset.prototype.find = function (query, firstOnly) {\n      if (this.collection.data.length === 0) {\n        this.filteredrows = [];\n        this.filterInitialized = true;\n        return this;\n      }\n\n      var queryObject = query || 'getAll',\n        p,\n        property,\n        queryObjectOp,\n        obj,\n        operator,\n        value,\n        key,\n        searchByIndex = false,\n        result = [],\n        filters = [],\n        index = null;\n\n      // flag if this was invoked via findOne()\n      firstOnly = firstOnly || false;\n\n      if (typeof queryObject === 'object') {\n        for (p in queryObject) {\n          obj = {};\n          obj[p] = queryObject[p];\n          filters.push(obj);\n\n          if (hasOwnProperty.call(queryObject, p)) {\n            property = p;\n            queryObjectOp = queryObject[p];\n          }\n        }\n        // if more than one expression in single query object,\n        // convert implicit $and to explicit $and\n        if (filters.length > 1) {\n          return this.find({ '$and': filters }, firstOnly);\n        }\n      }\n\n      // apply no filters if they want all\n      if (!property || queryObject === 'getAll') {\n        if (firstOnly) {\n          if (this.filterInitialized) {\n            this.filteredrows = this.filteredrows.slice(0, 1);\n          } else {\n            this.filteredrows = (this.collection.data.length > 0) ? [0] : [];\n            this.filterInitialized = true;\n          }\n        }\n\n        return this;\n      }\n\n      // injecting $and and $or expression tree evaluation here.\n      if (property === '$and' || property === '$or') {\n        this[property](queryObjectOp);\n\n        // for chained find with firstonly,\n        if (firstOnly && this.filteredrows.length > 1) {\n          this.filteredrows = this.filteredrows.slice(0, 1);\n        }\n\n        return this;\n      }\n\n      // see if query object is in shorthand mode (assuming eq operator)\n      if (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {\n        operator = '$eq';\n        value = queryObjectOp;\n      } else if (typeof queryObjectOp === 'object') {\n        for (key in queryObjectOp) {\n          if (hasOwnProperty.call(queryObjectOp, key)) {\n            operator = key;\n            value = queryObjectOp[key];\n            break;\n          }\n        }\n      } else {\n        throw new Error('Do not know what you want to do.');\n      }\n\n      if (operator === '$regex' || typeof value === 'object') {\n        value = precompileQuery(operator, value);\n      }\n\n      // if user is deep querying the object such as find('name.first': 'odin')\n      var usingDotNotation = (property.indexOf('.') !== -1);\n\n      // if an index exists for the property being queried against, use it\n      // for now only enabling where it is the first filter applied and prop is indexed\n      var doIndexCheck = !this.filterInitialized;\n\n      if (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator]) {\n        // this is where our lazy index rebuilding will take place\n        // basically we will leave all indexes dirty until we need them\n        // so here we will rebuild only the index tied to this property\n        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n        if (this.collection.adaptiveBinaryIndices !== true) {\n          this.collection.ensureIndex(property);\n        }\n\n        searchByIndex = true;\n        index = this.collection.binaryIndices[property];\n      }\n\n      // opportunistically speed up $in searches from O(n*m) to O(n*log m)\n      if (!searchByIndex && operator === '$in' && Array.isArray(value) && typeof Set !== 'undefined') {\n        value = new Set(value);\n        operator = '$inSet';\n      }\n\n      // the comparison function\n      var fun = LokiOps[operator];\n\n      // \"shortcut\" for collection data\n      var t = this.collection.data;\n      // filter data length\n      var i = 0,\n        len = 0;\n\n      // Query executed differently depending on :\n      //    - whether the property being queried has an index defined\n      //    - if chained, we handle first pass differently for initial filteredrows[] population\n      //\n      // For performance reasons, each case has its own if block to minimize in-loop calculations\n\n      var filter, rowIdx = 0, record;\n\n      // If the filteredrows[] is already initialized, use it\n      if (this.filterInitialized) {\n        filter = this.filteredrows;\n        len = filter.length;\n\n        // currently supporting dot notation for non-indexed conditions only\n        if (usingDotNotation) {\n          property = property.split('.');\n          for (i = 0; i < len; i++) {\n            rowIdx = filter[i];\n            record = t[rowIdx];\n            if (dotSubScan(record, property, fun, value, record)) {\n              result.push(rowIdx);\n              if (firstOnly) {\n                this.filteredrows = result;\n                return this;\n              }\n            }\n          }\n        } else {\n          for (i = 0; i < len; i++) {\n            rowIdx = filter[i];\n            record = t[rowIdx];\n            if (fun(record[property], value, record)) {\n              result.push(rowIdx);\n              if (firstOnly) {\n                this.filteredrows = result;\n                return this;\n              }\n            }\n          }\n        }\n      }\n      // first chained query so work against data[] but put results in filteredrows\n      else {\n        // if not searching by index\n        if (!searchByIndex) {\n          len = t.length;\n\n          if (usingDotNotation) {\n            property = property.split('.');\n            for (i = 0; i < len; i++) {\n              record = t[i];\n              if (dotSubScan(record, property, fun, value, record)) {\n                result.push(i);\n                if (firstOnly) {\n                  this.filteredrows = result;\n                  this.filterInitialized = true;\n                  return this;\n                }\n              }\n            }\n          } else {\n            for (i = 0; i < len; i++) {\n              record = t[i];\n              if (fun(record[property], value, record)) {\n                result.push(i);\n                if (firstOnly) {\n                  this.filteredrows = result;\n                  this.filterInitialized = true;\n                  return this;\n                }\n              }\n            }\n          }\n        } else {\n          // search by index\n          var segm = this.collection.calculateRange(operator, property, value);\n\n          if (operator !== '$in') {\n            for (i = segm[0]; i <= segm[1]; i++) {\n              if (indexedOps[operator] !== true) {\n                // must be a function, implying 2nd phase filtering of results from calculateRange\n                if (indexedOps[operator](Utils.getIn(t[index.values[i]], property, usingDotNotation), value)) {\n                  result.push(index.values[i]);\n                  if (firstOnly) {\n                    this.filteredrows = result;\n                    this.filterInitialized = true;\n                    return this;\n                  }\n                }\n              }\n              else {\n                result.push(index.values[i]);\n                if (firstOnly) {\n                  this.filteredrows = result;\n                  this.filterInitialized = true;\n                  return this;\n                }\n              }\n            }\n          } else {\n            for (i = 0, len = segm.length; i < len; i++) {\n              result.push(index.values[segm[i]]);\n              if (firstOnly) {\n                this.filteredrows = result;\n                this.filterInitialized = true;\n                return this;\n              }\n            }\n          }\n        }\n\n      }\n\n      this.filteredrows = result;\n      this.filterInitialized = true; // next time work against filteredrows[]\n      return this;\n    };\n\n\n    /**\n     * where() - Used for filtering via a javascript filter function.\n     *\n     * @param {function} fun - A javascript function used for filtering current results by.\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * var over30 = users.chain().where(function(obj) { return obj.age >= 30; }.data();\n     */\n    Resultset.prototype.where = function (fun) {\n      var viewFunction,\n        result = [];\n\n      if ('function' === typeof fun) {\n        viewFunction = fun;\n      } else {\n        throw new TypeError('Argument is not a stored view or a function');\n      }\n      try {\n        // If the filteredrows[] is already initialized, use it\n        if (this.filterInitialized) {\n          var j = this.filteredrows.length;\n\n          while (j--) {\n            if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n              result.push(this.filteredrows[j]);\n            }\n          }\n\n          this.filteredrows = result;\n\n          return this;\n        }\n        // otherwise this is initial chained op, work against data, push into filteredrows[]\n        else {\n          var k = this.collection.data.length;\n\n          while (k--) {\n            if (viewFunction(this.collection.data[k]) === true) {\n              result.push(k);\n            }\n          }\n\n          this.filteredrows = result;\n          this.filterInitialized = true;\n\n          return this;\n        }\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    /**\n     * count() - returns the number of documents in the resultset.\n     *\n     * @returns {number} The number of documents in the resultset.\n     * @memberof Resultset\n     * @example\n     * var over30Count = users.chain().find({ age: { $gte: 30 } }).count();\n     */\n    Resultset.prototype.count = function () {\n      if (this.filterInitialized) {\n        return this.filteredrows.length;\n      }\n      return this.collection.count();\n    };\n\n    /**\n     * Terminates the chain and returns array of filtered documents\n     *\n     * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n     *        the collection is not configured for clone object.\n     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents\n     *\n     * @returns {array} Array of documents in the resultset\n     * @memberof Resultset\n     * @example\n     * var resutls = users.chain().find({ age: 34 }).data();\n     */\n    Resultset.prototype.data = function (options) {\n      var result = [],\n        data = this.collection.data,\n        obj,\n        len,\n        i,\n        method;\n\n      options = options || {};\n\n      // if user opts to strip meta, then force clones and use 'shallow' if 'force' options are not present\n      if (options.removeMeta && !options.forceClones) {\n        options.forceClones = true;\n        options.forceCloneMethod = options.forceCloneMethod || 'shallow';\n      }\n\n      // if collection has delta changes active, then force clones and use 'parse-stringify' for effective change tracking of nested objects\n      // if collection is immutable freeze and unFreeze takes care of cloning\n      if (!this.collection.disableDeltaChangesApi && this.collection.disableFreeze) {\n        options.forceClones = true;\n        options.forceCloneMethod = 'parse-stringify';\n      }\n\n      // if this has no filters applied, just return collection.data\n      if (!this.filterInitialized) {\n        if (this.filteredrows.length === 0) {\n          // determine whether we need to clone objects or not\n          if (this.collection.cloneObjects || options.forceClones) {\n            len = data.length;\n            method = options.forceCloneMethod || this.collection.cloneMethod;\n            for (i = 0; i < len; i++) {\n              obj = clone(data[i], method);\n              if (options.removeMeta) {\n                delete obj.$loki;\n                delete obj.meta;\n              }\n              result.push(obj);\n            }\n            return result;\n          }\n          // otherwise we are not cloning so return sliced array with same object references\n          else {\n            return data.slice();\n          }\n        } else {\n          // filteredrows must have been set manually, so use it\n          this.filterInitialized = true;\n        }\n      }\n\n      var fr = this.filteredrows;\n      len = fr.length;\n\n      if (this.collection.cloneObjects || options.forceClones) {\n        method = options.forceCloneMethod || this.collection.cloneMethod;\n        for (i = 0; i < len; i++) {\n          obj = clone(data[fr[i]], method);\n          if (options.removeMeta) {\n            delete obj.$loki;\n            delete obj.meta;\n          }\n          result.push(obj);\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          result.push(data[fr[i]]);\n        }\n      }\n      return result;\n    };\n\n    /**\n     * Used to run an update operation on all documents currently in the resultset.\n     *\n     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * users.chain().find({ country: 'de' }).update(function(user) {\n     *   user.phoneFormat = \"+49 AAAA BBBBBB\";\n     * });\n     */\n    Resultset.prototype.update = function (updateFunction) {\n\n      if (typeof (updateFunction) !== \"function\") {\n        throw new TypeError('Argument is not a function');\n      }\n\n      // if this has no filters applied, we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var obj, len = this.filteredrows.length,\n        rcd = this.collection.data;\n\n      // pass in each document object currently in resultset to user supplied updateFunction\n      for (var idx = 0; idx < len; idx++) {\n        // if we have cloning option specified or are doing differential delta changes, clone object first\n        if (!this.disableFreeze || this.collection.cloneObjects || !this.collection.disableDeltaChangesApi) {\n          obj = clone(rcd[this.filteredrows[idx]], this.collection.cloneMethod);\n          updateFunction(obj);\n          this.collection.update(obj);\n        }\n        else {\n          // no need to clone, so just perform update on collection data object instance\n          updateFunction(rcd[this.filteredrows[idx]]);\n          this.collection.update(rcd[this.filteredrows[idx]]);\n        }\n      }\n\n      return this;\n    };\n\n    /**\n     * Removes all document objects which are currently in resultset from collection (as well as resultset)\n     *\n     * @returns {Resultset} this (empty) resultset for further chain ops.\n     * @memberof Resultset\n     * @example\n     * // remove users inactive since 1/1/2001\n     * users.chain().find({ lastActive: { $lte: new Date(\"1/1/2001\").getTime() } }).remove();\n     */\n    Resultset.prototype.remove = function () {\n\n      // if this has no filters applied, we need to populate filteredrows first\n      if (!this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      this.collection.removeBatchByPositions(this.filteredrows);\n\n      this.filteredrows = [];\n\n      return this;\n    };\n\n    /**\n     * data transformation via user supplied functions\n     *\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns {value} The output of your reduceFunction\n     * @memberof Resultset\n     * @example\n     * var db = new loki(\"order.db\");\n     * var orders = db.addCollection(\"orders\");\n     * orders.insert([{ qty: 4, unitCost: 100.00 }, { qty: 10, unitCost: 999.99 }, { qty: 2, unitCost: 49.99 }]);\n     *\n     * function mapfun (obj) { return obj.qty*obj.unitCost };\n     * function reducefun(array) {\n     *   var grandTotal=0;\n     *   array.forEach(function(orderTotal) { grandTotal += orderTotal; });\n     *   return grandTotal;\n     * }\n     * var grandOrderTotal = orders.chain().mapReduce(mapfun, reducefun);\n     * console.log(grandOrderTotal);\n     */\n    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data().map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    /**\n     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n     * @param {Array|Resultset|Collection} joinData - Data array to join to.\n     * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n     * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n     * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n     * @param {object=} dataOptions - options to data() before input to your map function\n     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n     * @memberof Resultset\n     * @example\n     * var db = new loki('sandbox.db');\n     *\n     * var products = db.addCollection('products');\n     * var orders = db.addCollection('orders');\n     *\n     * products.insert({ productId: \"100234\", name: \"flywheel energy storage\", unitCost: 19999.99 });\n     * products.insert({ productId: \"140491\", name: \"300F super capacitor\", unitCost: 129.99 });\n     * products.insert({ productId: \"271941\", name: \"fuel cell\", unitCost: 3999.99 });\n     * products.insert({ productId: \"174592\", name: \"390V 3AH lithium bank\", unitCost: 4999.99 });\n     *\n     * orders.insert({ orderDate : new Date(\"12/1/2017\").getTime(), prodId: \"174592\", qty: 2, customerId: 2 });\n     * orders.insert({ orderDate : new Date(\"4/15/2016\").getTime(), prodId: \"271941\", qty: 1, customerId: 1 });\n     * orders.insert({ orderDate : new Date(\"3/12/2017\").getTime(), prodId: \"140491\", qty: 4, customerId: 4 });\n     * orders.insert({ orderDate : new Date(\"7/31/2017\").getTime(), prodId: \"100234\", qty: 7, customerId: 3 });\n     * orders.insert({ orderDate : new Date(\"8/3/2016\").getTime(), prodId: \"174592\", qty: 3, customerId: 5 });\n     *\n     * var mapfun = function(left, right) {\n     *   return {\n     *     orderId: left.$loki,\n     *     orderDate: new Date(left.orderDate) + '',\n     *     customerId: left.customerId,\n     *     qty: left.qty,\n     *     productId: left.prodId,\n     *     prodName: right.name,\n     *     prodCost: right.unitCost,\n     *     orderTotal: +((right.unitCost * left.qty).toFixed(2))\n     *   };\n     * };\n     *\n     * // join orders with relevant product info via eqJoin\n     * var orderSummary = orders.chain().eqJoin(products, \"prodId\", \"productId\", mapfun).data();\n     *\n     * console.log(orderSummary);\n     */\n    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun, dataOptions) {\n\n      var leftData = [],\n        leftDataLength,\n        rightData = [],\n        rightDataLength,\n        key,\n        result = [],\n        leftKeyisFunction = typeof leftJoinKey === 'function',\n        rightKeyisFunction = typeof rightJoinKey === 'function',\n        joinMap = {};\n\n      //get the left data\n      leftData = this.data(dataOptions);\n      leftDataLength = leftData.length;\n\n      //get the right data\n      if (joinData instanceof Collection) {\n        rightData = joinData.chain().data(dataOptions);\n      } else if (joinData instanceof Resultset) {\n        rightData = joinData.data(dataOptions);\n      } else if (Array.isArray(joinData)) {\n        rightData = joinData;\n      } else {\n        throw new TypeError('joinData needs to be an array or result set');\n      }\n      rightDataLength = rightData.length;\n\n      //construct a lookup table\n\n      for (var i = 0; i < rightDataLength; i++) {\n        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n        joinMap[key] = rightData[i];\n      }\n\n      if (!mapFun) {\n        mapFun = function (left, right) {\n          return {\n            left: left,\n            right: right\n          };\n        };\n      }\n\n      //Run map function over each object in the resultset\n      for (var j = 0; j < leftDataLength; j++) {\n        key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n        result.push(mapFun(leftData[j], joinMap[key] || {}));\n      }\n\n      //return return a new resultset with no filters\n      this.collection = new Collection('joinData');\n      this.collection.insert(result);\n      this.filteredrows = [];\n      this.filterInitialized = false;\n\n      return this;\n    };\n\n    /**\n     * Applies a map function into a new collection for further chaining.\n     * @param {function} mapFun - javascript map function\n     * @param {object=} dataOptions - options to data() before input to your map function\n     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     * @memberof Resultset\n     * @example\n     * var orders.chain().find({ productId: 32 }).map(function(obj) {\n     *   return {\n     *     orderId: $loki,\n     *     productId: productId,\n     *     quantity: qty\n     *   };\n     * });\n     */\n    Resultset.prototype.map = function (mapFun, dataOptions) {\n      var data = this.data(dataOptions).map(mapFun);\n      //return return a new resultset with no filters\n      this.collection = new Collection('mappedData');\n      this.collection.insert(data);\n      this.filteredrows = [];\n      this.filterInitialized = false;\n\n      return this;\n    };\n\n    /**\n     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n     *\n     * @example\n     * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n     * mydv.applyFind({ 'doors' : 4 });\n     * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n     * var results = mydv.data();\n     *\n     * @constructor DynamicView\n     * @implements LokiEventEmitter\n     * @param {Collection} collection - A reference to the collection to work against\n     * @param {string} name - The name of this dynamic view\n     * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'\n     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)\n     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n     * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n     */\n    function DynamicView(collection, name, options) {\n      this.collection = collection;\n      this.name = name;\n      this.rebuildPending = false;\n      this.options = options || {};\n\n      if (!this.options.hasOwnProperty('persistent')) {\n        this.options.persistent = false;\n      }\n\n      // 'persistentSortPriority':\n      // 'passive' will defer the sort phase until they call data(). (most efficient overall)\n      // 'active' will sort async whenever next idle. (prioritizes read speeds)\n      if (!this.options.hasOwnProperty('sortPriority')) {\n        this.options.sortPriority = 'passive';\n      }\n\n      if (!this.options.hasOwnProperty('minRebuildInterval')) {\n        this.options.minRebuildInterval = 1;\n      }\n\n      this.resultset = new Resultset(collection);\n      this.resultdata = [];\n      this.resultsdirty = false;\n\n      this.cachedresultset = null;\n\n      // keep ordered filter pipeline\n      this.filterPipeline = [];\n      if (!this.collection.disableFreeze) {\n        Object.freeze(this.filterPipeline);\n      }\n\n      // sorting member variables\n      // we only support one active search, applied using applySort() or applySimpleSort()\n      this.sortFunction = null;\n      this.sortCriteria = null;\n      this.sortCriteriaSimple = null;\n      this.sortDirty = false;\n\n      // for now just have 1 event for when we finally rebuilt lazy view\n      // once we refactor transactions, i will tie in certain transactional events\n\n      this.events = {\n        'rebuild': [],\n        'filter': [],\n        'sort': []\n      };\n    }\n\n    DynamicView.prototype = new LokiEventEmitter();\n    DynamicView.prototype.constructor = DynamicView;\n\n    /**\n     * getSort() - used to get the current sort\n     *\n     * @returns function (sortFunction) or array (sortCriteria) or object (sortCriteriaSimple)\n     */\n    DynamicView.prototype.getSort = function () {\n      return this.sortFunction || this.sortCriteria || this.sortCriteriaSimple;\n    };\n\n    /**\n     * rematerialize() - internally used immediately after deserialization (loading)\n     *    This will clear out and reapply filterPipeline ops, recreating the view.\n     *    Since where filters do not persist correctly, this method allows\n     *    restoring the view to state where user can re-apply those where filters.\n     *\n     * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n     * @returns {DynamicView} This dynamic view for further chained ops.\n     * @memberof DynamicView\n     * @fires DynamicView.rebuild\n     */\n    DynamicView.prototype.rematerialize = function (options) {\n      var fpl,\n        fpi,\n        idx;\n\n      options = options || {};\n\n      this.resultdata = [];\n      this.resultsdirty = true;\n      this.resultset = new Resultset(this.collection);\n\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.sortDirty = true;\n      }\n\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n      if (options.hasOwnProperty('removeWhereFilters')) {\n        // for each view see if it had any where filters applied... since they don't\n        // serialize those functions lets remove those invalid filters\n        if (wasFrozen) {\n          this.filterPipeline = this.filterPipeline.slice();\n        }\n        fpl = this.filterPipeline.length;\n        fpi = fpl;\n        while (fpi--) {\n          if (this.filterPipeline[fpi].type === 'where') {\n            if (fpi !== this.filterPipeline.length - 1) {\n              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n            }\n            this.filterPipeline.length--;\n          }\n        }\n      }\n\n      // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n      var ofp = this.filterPipeline;\n      this.filterPipeline = [];\n\n      // now re-apply 'find' filterPipeline ops\n      fpl = ofp.length;\n      for (idx = 0; idx < fpl; idx++) {\n        this.applyFind(ofp[idx].val, ofp[idx].uid);\n      }\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n\n      // during creation of unit tests, i will remove this forced refresh and leave lazy\n      this.data();\n\n      // emit rebuild event in case user wants to be notified\n      this.emit('rebuild', this);\n\n      return this;\n    };\n\n    /**\n     * branchResultset() - Makes a copy of the internal resultset for branched queries.\n     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n     *    so your branched query should be immediately resolved and not held for future evaluation.\n     *\n     * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n     * @param {object=} parameters - optional parameters (if optional transform requires them)\n     * @returns {Resultset} A copy of the internal resultset for branched queries.\n     * @memberof DynamicView\n     * @example\n     * var db = new loki('test');\n     * var coll = db.addCollection('mydocs');\n     * var dv = coll.addDynamicView('myview');\n     * var tx = [\n     *   {\n     *     type: 'offset',\n     *     value: '[%lktxp]pageStart'\n     *   },\n     *   {\n     *     type: 'limit',\n     *     value: '[%lktxp]pageSize'\n     *   }\n     * ];\n     * coll.addTransform('viewPaging', tx);\n     *\n     * // add some records\n     *\n     * var results = dv.branchResultset('viewPaging', { pageStart: 10, pageSize: 10 }).data();\n     */\n    DynamicView.prototype.branchResultset = function (transform, parameters) {\n      var rs = this.resultset.branch();\n\n      if (typeof transform === 'undefined') {\n        return rs;\n      }\n\n      return rs.transform(transform, parameters);\n    };\n\n    /**\n     * toJSON() - Override of toJSON to avoid circular references\n     *\n     */\n    DynamicView.prototype.toJSON = function () {\n      var copy = new DynamicView(this.collection, this.name, this.options);\n      copy.resultset = this.resultset;\n      copy.resultdata = []; // let's not save data (copy) to minimize size\n      copy.resultsdirty = true;\n      copy.filterPipeline = this.filterPipeline;\n      copy.sortFunction = this.sortFunction;\n      copy.sortCriteria = this.sortCriteria;\n      copy.sortCriteriaSimple = this.sortCriteriaSimple || null;\n      copy.sortDirty = this.sortDirty;\n\n      // avoid circular reference, reapply in db.loadJSON()\n      copy.collection = null;\n\n      return copy;\n    };\n\n    /**\n     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n     *     Existing options should be retained.\n     * @param {object=} options - configure removeFilter behavior\n     * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.removeFilters = function (options) {\n      options = options || {};\n\n      this.rebuildPending = false;\n      this.resultset.reset();\n      this.resultdata = [];\n      this.resultsdirty = true;\n\n      this.cachedresultset = null;\n\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n      var filterChanged = this.filterPipeline.length > 0;\n      // keep ordered filter pipeline\n      this.filterPipeline = [];\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n\n      // sorting member variables\n      // we only support one active search, applied using applySort() or applySimpleSort()\n      this.sortFunction = null;\n      this.sortCriteria = null;\n      this.sortCriteriaSimple = null;\n      this.sortDirty = false;\n\n      if (options.queueSortPhase === true) {\n        this.queueSortPhase();\n      }\n\n      if (filterChanged) {\n        this.emit('filter');\n      }\n    };\n\n    /**\n     * applySort() - Used to apply a sort to the dynamic view\n     * @example\n     * dv.applySort(function(obj1, obj2) {\n     *   if (obj1.name === obj2.name) return 0;\n     *   if (obj1.name > obj2.name) return 1;\n     *   if (obj1.name < obj2.name) return -1;\n     * });\n     *\n     * @param {function} comparefun - a javascript compare function used for sorting\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applySort = function (comparefun) {\n      this.sortFunction = comparefun;\n      this.sortCriteria = null;\n      this.sortCriteriaSimple = null;\n\n      this.queueSortPhase();\n      this.emit('sort');\n\n      return this;\n    };\n\n    /**\n     * applySimpleSort() - Used to specify a property used for view translation.\n     * @example\n     * dv.applySimpleSort(\"name\");\n     *\n     * @param {string} propname - Name of property by which to sort.\n     * @param {object|boolean=} options - boolean for sort descending or options object\n     * @param {boolean} [options.desc=false] - whether we should sort descending.\n     * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.\n     * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).\n     * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applySimpleSort = function (propname, options) {\n      this.sortCriteriaSimple = { propname: propname, options: options || false };\n      if (!this.collection.disableFreeze) {\n        deepFreeze(this.sortCriteriaSimple);\n      }\n      this.sortCriteria = null;\n      this.sortFunction = null;\n\n      this.queueSortPhase();\n      this.emit('sort');\n\n      return this;\n    };\n\n    /**\n     * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * dv.applySortCriteria(['age', 'name']);\n     * // to sort by age (ascending) and then by name (descending)\n     * dv.applySortCriteria(['age', ['name', true]);\n     * // to sort by age (descending) and then by name (descending)\n     * dv.applySortCriteria(['age', true], ['name', true]);\n     *\n     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applySortCriteria = function (criteria) {\n      this.sortCriteria = criteria;\n      if (!this.collection.disableFreeze) {\n        deepFreeze(this.sortCriteria);\n      }\n      this.sortCriteriaSimple = null;\n      this.sortFunction = null;\n\n      this.queueSortPhase();\n      this.emit('sort');\n      return this;\n    };\n\n    /**\n     * startTransaction() - marks the beginning of a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.startTransaction = function () {\n      this.cachedresultset = this.resultset.copy();\n\n      return this;\n    };\n\n    /**\n     * commit() - commits a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.commit = function () {\n      this.cachedresultset = null;\n\n      return this;\n    };\n\n    /**\n     * rollback() - rolls back a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.rollback = function () {\n      this.resultset = this.cachedresultset;\n\n      if (this.options.persistent) {\n        // for now just rebuild the persistent dynamic view data in this worst case scenario\n        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n        this.resultdata = this.resultset.data();\n\n        this.emit('rebuild', this);\n      }\n\n      return this;\n    };\n\n\n    /**\n     * Implementation detail.\n     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n     *\n     * @param {(string|number)} uid - The unique ID of the filter.\n     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n     */\n    DynamicView.prototype._indexOfFilterWithId = function (uid) {\n      if (typeof uid === 'string' || typeof uid === 'number') {\n        for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n          if (uid === this.filterPipeline[idx].uid) {\n            return idx;\n          }\n        }\n      }\n      return -1;\n    };\n\n    /**\n     * Implementation detail.\n     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n     *\n     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n     */\n    DynamicView.prototype._addFilter = function (filter) {\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n      if (wasFrozen) {\n        this.filterPipeline = this.filterPipeline.slice();\n      }\n      if (!this.collection.disableFreeze) {\n        deepFreeze(filter);\n      }\n      this.filterPipeline.push(filter);\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n      this.resultset[filter.type](filter.val);\n    };\n\n    /**\n     * reapplyFilters() - Reapply all the filters in the current pipeline.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.reapplyFilters = function () {\n      this.resultset.reset();\n\n      this.cachedresultset = null;\n      if (this.options.persistent) {\n        this.resultdata = [];\n        this.resultsdirty = true;\n      }\n\n      var filters = this.filterPipeline;\n      var wasFrozen = Object.isFrozen(filters);\n      this.filterPipeline = [];\n\n      for (var idx = 0, len = filters.length; idx < len; idx += 1) {\n        this._addFilter(filters[idx]);\n      }\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n      this.emit('filter');\n      return this;\n    };\n\n    /**\n     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n     *\n     * @param {object} filter - A filter object to add to the pipeline.\n     *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applyFilter = function (filter) {\n      var idx = this._indexOfFilterWithId(filter.uid);\n      if (idx >= 0) {\n        var wasFrozen = Object.isFrozen(this.filterPipeline);\n        if (wasFrozen) {\n          this.filterPipeline = this.filterPipeline.slice();\n        }\n        this.filterPipeline[idx] = filter;\n        if (wasFrozen) {\n          freeze(filter);\n          Object.freeze(this.filterPipeline);\n        }\n        return this.reapplyFilters();\n      }\n\n      this.cachedresultset = null;\n      if (this.options.persistent) {\n        this.resultdata = [];\n        this.resultsdirty = true;\n      }\n\n      this._addFilter(filter);\n\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      this.emit('filter');\n      return this;\n    };\n\n    /**\n     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n     *\n     * @param {object} query - A mongo-style query object to apply to pipeline\n     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applyFind = function (query, uid) {\n      this.applyFilter({\n        type: 'find',\n        val: query,\n        uid: uid\n      });\n      return this;\n    };\n\n    /**\n     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n     *\n     * @param {function} fun - A javascript filter function to apply to pipeline\n     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applyWhere = function (fun, uid) {\n      this.applyFilter({\n        type: 'where',\n        val: fun,\n        uid: uid\n      });\n      return this;\n    };\n\n    /**\n     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n     *\n     * @param {(string|number)} uid - The unique ID of the filter to be removed.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.removeFilter = function (uid) {\n      var idx = this._indexOfFilterWithId(uid);\n      if (idx < 0) {\n        throw new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n      }\n      var wasFrozen = Object.isFrozen(this.filterPipeline);\n      if (wasFrozen) {\n        this.filterPipeline = this.filterPipeline.slice();\n      }\n      this.filterPipeline.splice(idx, 1);\n      if (wasFrozen) {\n        Object.freeze(this.filterPipeline);\n      }\n      this.reapplyFilters();\n      return this;\n    };\n\n    /**\n     * count() - returns the number of documents representing the current DynamicView contents.\n     *\n     * @returns {number} The number of documents representing the current DynamicView contents.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.count = function () {\n      // in order to be accurate we will pay the minimum cost (and not alter dv state management)\n      // recurring resultset data resolutions should know internally its already up to date.\n      // for persistent data this will not update resultdata nor fire rebuild event.\n      if (this.resultsdirty) {\n        this.resultdata = this.resultset.data();\n      }\n\n      return this.resultset.count();\n    };\n\n    /**\n     * data() - resolves and pending filtering and sorting, then returns document array as result.\n     *\n     * @param {object=} options - optional parameters to pass to resultset.data() if non-persistent\n     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n     *        the collection is not configured for clone object.\n     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n     * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents\n     * @returns {array} An array of documents representing the current DynamicView contents.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.data = function (options) {\n      // using final sort phase as 'catch all' for a few use cases which require full rebuild\n      if (this.sortDirty || this.resultsdirty) {\n        this.performSortPhase({\n          suppressRebuildEvent: true\n        });\n      }\n      return (this.options.persistent) ? (this.resultdata) : (this.resultset.data(options));\n    };\n\n    /**\n     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n     *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n     */\n    DynamicView.prototype.queueRebuildEvent = function () {\n      if (this.rebuildPending) {\n        return;\n      }\n      this.rebuildPending = true;\n\n      var self = this;\n      setTimeout(function () {\n        if (self.rebuildPending) {\n          self.rebuildPending = false;\n          self.emit('rebuild', self);\n        }\n      }, this.options.minRebuildInterval);\n    };\n\n    /**\n     * queueSortPhase : If the view is sorted we will throttle sorting to either :\n     *    (1) passive - when the user calls data(), or\n     *    (2) active - once they stop updating and yield js thread control\n     */\n    DynamicView.prototype.queueSortPhase = function () {\n      // already queued? exit without queuing again\n      if (this.sortDirty) {\n        return;\n      }\n      this.sortDirty = true;\n\n      var self = this;\n      if (this.options.sortPriority === \"active\") {\n        // active sorting... once they are done and yield js thread, run async performSortPhase()\n        setTimeout(function () {\n          self.performSortPhase();\n        }, this.options.minRebuildInterval);\n      } else {\n        // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n        // potentially notify user that data has changed.\n        this.queueRebuildEvent();\n      }\n    };\n\n    /**\n     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n     *\n     */\n    DynamicView.prototype.performSortPhase = function (options) {\n      // async call to this may have been pre-empted by synchronous call to data before async could fire\n      if (!this.sortDirty && !this.resultsdirty) {\n        return;\n      }\n\n      options = options || {};\n\n      if (this.sortDirty) {\n        if (this.sortFunction) {\n          this.resultset.sort(this.sortFunction);\n        } else if (this.sortCriteria) {\n          this.resultset.compoundsort(this.sortCriteria);\n        } else if (this.sortCriteriaSimple) {\n          this.resultset.simplesort(this.sortCriteriaSimple.propname, this.sortCriteriaSimple.options);\n        }\n\n        this.sortDirty = false;\n      }\n\n      if (this.options.persistent) {\n        // persistent view, rebuild local resultdata array\n        this.resultdata = this.resultset.data();\n        this.resultsdirty = false;\n      }\n\n      if (!options.suppressRebuildEvent) {\n        this.emit('rebuild', this);\n      }\n    };\n\n    /**\n     * evaluateDocument() - internal method for (re)evaluating document inclusion.\n     *    Called by : collection.insert() and collection.update().\n     *\n     * @param {int} objIndex - index of document to (re)run through filter pipeline.\n     * @param {bool} isNew - true if the document was just added to the collection.\n     */\n    DynamicView.prototype.evaluateDocument = function (objIndex, isNew) {\n      // if no filter applied yet, the result 'set' should remain 'everything'\n      if (!this.resultset.filterInitialized) {\n        if (this.options.persistent) {\n          this.resultdata = this.resultset.data();\n        }\n        // need to re-sort to sort new document\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n        return;\n      }\n\n      var ofr = this.resultset.filteredrows;\n      var oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n      var oldlen = ofr.length;\n\n      // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n      var evalResultset = new Resultset(this.collection);\n      evalResultset.filteredrows = [objIndex];\n      evalResultset.filterInitialized = true;\n      var filter;\n      for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n        filter = this.filterPipeline[idx];\n        evalResultset[filter.type](filter.val);\n      }\n\n      // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n      var newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n      // wasn't in old, shouldn't be now... do nothing\n      if (oldPos === -1 && newPos === -1) return;\n\n      // wasn't in resultset, should be now... add\n      if (oldPos === -1 && newPos !== -1) {\n        ofr.push(objIndex);\n\n        if (this.options.persistent) {\n          this.resultdata.push(this.collection.data[objIndex]);\n        }\n\n        // need to re-sort to sort new document\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n\n      // was in resultset, shouldn't be now... delete\n      if (oldPos !== -1 && newPos === -1) {\n        if (oldPos < oldlen - 1) {\n          ofr.splice(oldPos, 1);\n\n          if (this.options.persistent) {\n            this.resultdata.splice(oldPos, 1);\n          }\n        } else {\n          ofr.length = oldlen - 1;\n\n          if (this.options.persistent) {\n            this.resultdata.length = oldlen - 1;\n          }\n        }\n\n        // in case changes to data altered a sort column\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n\n      // was in resultset, should still be now... (update persistent only?)\n      if (oldPos !== -1 && newPos !== -1) {\n        if (this.options.persistent) {\n          // in case document changed, replace persistent view data with the latest collection.data document\n          this.resultdata[oldPos] = this.collection.data[objIndex];\n        }\n\n        // in case changes to data altered a sort column\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n    };\n\n    /**\n     * removeDocument() - internal function called on collection.delete()\n     * @param {number|number[]} objIndex - index of document to (re)run through filter pipeline.\n     */\n    DynamicView.prototype.removeDocument = function (objIndex) {\n      var idx, rmidx, rmlen, rxo = {}, fxo = {};\n      var adjels = [];\n      var drs = this.resultset;\n      var fr = this.resultset.filteredrows;\n      var frlen = fr.length;\n\n      // if no filter applied yet, the result 'set' should remain 'everything'\n      if (!this.resultset.filterInitialized) {\n        if (this.options.persistent) {\n          this.resultdata = this.resultset.data();\n        }\n        // in case changes to data altered a sort column\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n        return;\n      }\n\n      // if passed single index, wrap in array\n      if (!Array.isArray(objIndex)) {\n        objIndex = [objIndex];\n      }\n\n      rmlen = objIndex.length;\n      // create intersection object of data indices to remove\n      for (rmidx = 0; rmidx < rmlen; rmidx++) {\n        rxo[objIndex[rmidx]] = true;\n      }\n\n      // pivot remove data indices into remove filteredrows indices and dump in hashobject\n      for (idx = 0; idx < frlen; idx++) {\n        if (rxo[fr[idx]]) fxo[idx] = true;\n      }\n\n      // if any of the removed items were in our filteredrows...\n      if (Object.keys(fxo).length > 0) {\n        // remove them from filtered rows\n        this.resultset.filteredrows = this.resultset.filteredrows.filter(function (di, idx) { return !fxo[idx]; });\n        // if persistent...\n        if (this.options.persistent) {\n          // remove from resultdata\n          this.resultdata = this.resultdata.filter(function (obj, idx) { return !fxo[idx]; });\n        }\n\n        // and queue sorts\n        if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n      }\n\n      // to remove holes, we need to 'shift down' indices, this filter function finds number of positions to shift\n      var filt = function (idx) { return function (di) { return di < drs.filteredrows[idx]; }; };\n\n      frlen = drs.filteredrows.length;\n      for (idx = 0; idx < frlen; idx++) {\n        // grab subset of removed elements where data index is less than current filtered row data index;\n        // use this to determine how many positions iterated remaining data index needs to be 'shifted down'\n        adjels = objIndex.filter(filt(idx));\n        drs.filteredrows[idx] -= adjels.length;\n      }\n    };\n\n    /**\n     * mapReduce() - data transformation via user supplied functions\n     *\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns The output of your reduceFunction\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data().map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n\n\n    /**\n     * Collection class that handles documents of same type\n     * @constructor Collection\n     * @implements LokiEventEmitter\n     * @param {string} name - collection name\n     * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n     * @param {array=} [options.unique=[]] - array of property names to define unique constraints for\n     * @param {array=} [options.exact=[]] - array of property names to define exact constraints for\n     * @param {array=} [options.indices=[]] - array property names to define binary indexes for\n     * @param {boolean} [options.adaptiveBinaryIndices=true] - collection indices will be actively rebuilt rather than lazily\n     * @param {boolean} [options.asyncListeners=false] - whether listeners are invoked asynchronously\n     * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n     * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes API\n     * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n     * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically\n     * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n     * @param {boolean} [options.serializableIndices=true[]] - converts date values on binary indexed properties to epoch time\n     * @param {boolean} [options.disableFreeze=true] - when false all docs are frozen\n     * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n     * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.\n     * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n     * @see {@link Loki#addCollection} for normal creation of collections\n     */\n    function Collection(name, options) {\n      // the name of the collection\n\n      this.name = name;\n      // the data held by the collection\n      this.data = [];\n      this.idIndex = null; // position->$loki index (built lazily)\n      this.binaryIndices = {}; // user defined indexes\n      this.constraints = {\n        unique: {},\n        exact: {}\n      };\n\n      // unique contraints contain duplicate object references, so they are not persisted.\n      // we will keep track of properties which have unique contraint applied here, and regenerate lazily\n      this.uniqueNames = [];\n\n      // transforms will be used to store frequently used query chains as a series of steps\n      // which itself can be stored along with the database.\n      this.transforms = {};\n\n      // the object type of the collection\n      this.objType = name;\n\n      // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n      // defaulting to true since this is called from addCollection and adding a collection should trigger save\n      this.dirty = true;\n\n      // private holders for cached data\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n      this.cachedData = null;\n      var self = this;\n\n      /* OPTIONS */\n      options = options || {};\n\n      // exact match and unique constraints\n      if (options.hasOwnProperty('unique')) {\n        if (!Array.isArray(options.unique)) {\n          options.unique = [options.unique];\n        }\n        // save names; actual index is built lazily\n        options.unique.forEach(function (prop) {\n          self.uniqueNames.push(prop);\n        });\n      }\n\n      if (options.hasOwnProperty('exact')) {\n        options.exact.forEach(function (prop) {\n          self.constraints.exact[prop] = new ExactIndex(prop);\n        });\n      }\n\n      // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n      // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n      this.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\n      // is collection transactional\n      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\n      // options to clone objects when inserting them\n      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\n      // default clone method (if enabled) is parse-stringify\n      this.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\n      // option to make event listeners async, default is sync\n      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\n      // if set to true we will not maintain a meta property for a document\n      this.disableMeta = options.hasOwnProperty('disableMeta') ? options.disableMeta : false;\n\n      // disable track changes\n      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\n      // disable delta update object style on changes\n      this.disableDeltaChangesApi = options.hasOwnProperty('disableDeltaChangesApi') ? options.disableDeltaChangesApi : true;\n      if (this.disableChangesApi) { this.disableDeltaChangesApi = true; }\n\n      // option to observe objects and update them automatically, ignored if Object.observe is not supported\n      this.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\n      // by default, if you insert a document into a collection with binary indices, if those indexed properties contain\n      // a DateTime we will convert to epoch time format so that (across serializations) its value position will be the\n      // same 'after' serialization as it was 'before'.\n      this.serializableIndices = options.hasOwnProperty('serializableIndices') ? options.serializableIndices : true;\n\n      // option to deep freeze all documents\n      this.disableFreeze = options.hasOwnProperty('disableFreeze') ? options.disableFreeze : true;\n\n      //option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n      this.ttl = {\n        age: null,\n        ttlInterval: null,\n        daemon: null\n      };\n      this.setTTL(options.ttl || -1, options.ttlInterval);\n\n      // currentMaxId - change manually at your own peril!\n      this.maxId = 0;\n\n      this.DynamicViews = [];\n\n      // events\n      this.events = {\n        'insert': [],\n        'update': [],\n        'pre-insert': [],\n        'pre-update': [],\n        'close': [],\n        'flushbuffer': [],\n        'error': [],\n        'delete': [],\n        'warning': []\n      };\n\n      // changes are tracked by collection and aggregated by the db\n      this.changes = [];\n\n      // lightweight changes tracking (loki IDs only) for optimized db saving\n      this.dirtyIds = [];\n\n      // initialize optional user-supplied indices array ['age', 'lname', 'zip']\n      var indices = [];\n      if (options && options.indices) {\n        if (Object.prototype.toString.call(options.indices) === '[object Array]') {\n          indices = options.indices;\n        } else if (typeof options.indices === 'string') {\n          indices = [options.indices];\n        } else {\n          throw new TypeError('Indices needs to be a string or an array of strings');\n        }\n      }\n\n      for (var idx = 0; idx < indices.length; idx++) {\n        this.ensureIndex(indices[idx]);\n      }\n\n      function observerCallback(changes) {\n\n        var changedObjects = typeof Set === 'function' ? new Set() : [];\n\n        if (!changedObjects.add)\n          changedObjects.add = function (object) {\n            if (this.indexOf(object) === -1)\n              this.push(object);\n            return this;\n          };\n\n        changes.forEach(function (change) {\n          changedObjects.add(change.object);\n        });\n\n        changedObjects.forEach(function (object) {\n          if (!hasOwnProperty.call(object, '$loki'))\n            return self.removeAutoUpdateObserver(object);\n          try {\n            self.update(object);\n          } catch (err) { }\n        });\n      }\n\n      this.observerCallback = observerCallback;\n\n      //Compare changed object (which is a forced clone) with existing object and return the delta\n      function getChangeDelta(obj, old) {\n        if (old) {\n          return getObjectDelta(old, obj);\n        }\n        else {\n          return JSON.parse(JSON.stringify(obj));\n        }\n      }\n\n      this.getChangeDelta = getChangeDelta;\n\n      function getObjectDelta(oldObject, newObject) {\n        var propertyNames = newObject !== null && typeof newObject === 'object' ? Object.keys(newObject) : null;\n        if (propertyNames && propertyNames.length && ['string', 'boolean', 'number'].indexOf(typeof (newObject)) < 0) {\n          var delta = {};\n          for (var i = 0; i < propertyNames.length; i++) {\n            var propertyName = propertyNames[i];\n            if (newObject.hasOwnProperty(propertyName)) {\n              if (!oldObject.hasOwnProperty(propertyName) || self.uniqueNames.indexOf(propertyName) >= 0 || propertyName == '$loki' || propertyName == 'meta') {\n                delta[propertyName] = newObject[propertyName];\n              }\n              else {\n                var propertyDelta = getObjectDelta(oldObject[propertyName], newObject[propertyName]);\n                if (typeof propertyDelta !== \"undefined\" && propertyDelta != {}) {\n                  delta[propertyName] = propertyDelta;\n                }\n              }\n            }\n          }\n          return Object.keys(delta).length === 0 ? undefined : delta;\n        }\n        else {\n          return oldObject === newObject ? undefined : newObject;\n        }\n      }\n\n      this.getObjectDelta = getObjectDelta;\n\n      // clear all the changes\n      function flushChanges() {\n        self.changes = [];\n      }\n\n      this.getChanges = function () {\n        return self.changes;\n      };\n\n      this.flushChanges = flushChanges;\n\n      this.setChangesApi = function (enabled) {\n        self.disableChangesApi = !enabled;\n        if (!enabled) { self.disableDeltaChangesApi = false; }\n      };\n\n      this.on('delete', function deleteCallback(obj) {\n        if (!self.disableChangesApi) {\n          self.createChange(self.name, 'R', obj);\n        }\n      });\n\n      this.on('warning', function (warning) {\n        self.lokiConsoleWrapper.warn(warning);\n      });\n      // for de-serialization purposes\n      flushChanges();\n    }\n\n    Collection.prototype = new LokiEventEmitter();\n    Collection.prototype.contructor = Collection;\n\n    /*\n      * For ChangeAPI default to clone entire object, for delta changes create object with only differences (+ $loki and meta)\n      */\n    Collection.prototype.createChange = function (name, op, obj, old) {\n      this.changes.push({\n        name: name,\n        operation: op,\n        obj: op == 'U' && !this.disableDeltaChangesApi ? this.getChangeDelta(obj, old) : JSON.parse(JSON.stringify(obj))\n      });\n    };\n\n    Collection.prototype.insertMeta = function (obj) {\n      var len, idx;\n\n      if (this.disableMeta || !obj) {\n        return;\n      }\n\n      // if batch insert\n      if (Array.isArray(obj)) {\n        len = obj.length;\n\n        for (idx = 0; idx < len; idx++) {\n          if (!obj[idx].hasOwnProperty('meta')) {\n            obj[idx].meta = {};\n          }\n\n          obj[idx].meta.created = (new Date()).getTime();\n          obj[idx].meta.revision = 0;\n        }\n\n        return;\n      }\n\n      // single object\n      if (!obj.meta) {\n        obj.meta = {};\n      }\n\n      obj.meta.created = (new Date()).getTime();\n      obj.meta.revision = 0;\n    };\n\n    Collection.prototype.updateMeta = function (obj) {\n      if (this.disableMeta || !obj) {\n        return obj;\n      }\n      if (!this.disableFreeze) {\n        obj = unFreeze(obj);\n        obj.meta = unFreeze(obj.meta);\n      }\n      obj.meta.updated = (new Date()).getTime();\n      obj.meta.revision += 1;\n      return obj;\n    };\n\n    Collection.prototype.createInsertChange = function (obj) {\n      this.createChange(this.name, 'I', obj);\n    };\n\n    Collection.prototype.createUpdateChange = function (obj, old) {\n      this.createChange(this.name, 'U', obj, old);\n    };\n\n    Collection.prototype.insertMetaWithChange = function (obj) {\n      this.insertMeta(obj);\n      this.createInsertChange(obj);\n    };\n\n    Collection.prototype.updateMetaWithChange = function (obj, old, objFrozen) {\n      obj = this.updateMeta(obj, objFrozen);\n      this.createUpdateChange(obj, old);\n      return obj;\n    };\n\n    Collection.prototype.lokiConsoleWrapper = {\n      log: function () { },\n      warn: function () { },\n      error: function () { },\n    };\n\n    Collection.prototype.addAutoUpdateObserver = function (object) {\n      if (!this.autoupdate || typeof Object.observe !== 'function')\n        return;\n\n      Object.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n    };\n\n    Collection.prototype.removeAutoUpdateObserver = function (object) {\n      if (!this.autoupdate || typeof Object.observe !== 'function')\n        return;\n\n      Object.unobserve(object, this.observerCallback);\n    };\n\n    /**\n     * Adds a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {array} transform - an array of transformation 'step' objects to save into the collection\n     * @memberof Collection\n     * @example\n     * users.addTransform('progeny', [\n     *   {\n     *     type: 'find',\n     *     value: {\n     *       'age': {'$lte': 40}\n     *     }\n     *   }\n     * ]);\n     *\n     * var results = users.chain('progeny').data();\n     */\n    Collection.prototype.addTransform = function (name, transform) {\n      if (this.transforms.hasOwnProperty(name)) {\n        throw new Error(\"a transform by that name already exists\");\n      }\n\n      this.transforms[name] = transform;\n    };\n\n    /**\n     * Retrieves a named transform from the collection.\n     * @param {string} name - name of the transform to lookup.\n     * @memberof Collection\n     */\n    Collection.prototype.getTransform = function (name) {\n      return this.transforms[name];\n    };\n\n    /**\n     * Updates a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {object} transform - a transformation object to save into collection\n     * @memberof Collection\n     */\n    Collection.prototype.setTransform = function (name, transform) {\n      this.transforms[name] = transform;\n    };\n\n    /**\n     * Removes a named collection transform from the collection\n     * @param {string} name - name of collection transform to remove\n     * @memberof Collection\n     */\n    Collection.prototype.removeTransform = function (name) {\n      delete this.transforms[name];\n    };\n\n    Collection.prototype.byExample = function (template) {\n      var k, obj, query;\n      query = [];\n      for (k in template) {\n        if (!template.hasOwnProperty(k)) continue;\n        query.push((\n          obj = {},\n          obj[k] = template[k],\n          obj\n        ));\n      }\n      return {\n        '$and': query\n      };\n    };\n\n    Collection.prototype.findObject = function (template) {\n      return this.findOne(this.byExample(template));\n    };\n\n    Collection.prototype.findObjects = function (template) {\n      return this.find(this.byExample(template));\n    };\n\n    /*----------------------------+\n    | TTL daemon                  |\n    +----------------------------*/\n    Collection.prototype.ttlDaemonFuncGen = function () {\n      var collection = this;\n      var age = this.ttl.age;\n      return function ttlDaemon() {\n        var now = Date.now();\n        var toRemove = collection.chain().where(function daemonFilter(member) {\n          var timestamp = member.meta.updated || member.meta.created;\n          var diff = now - timestamp;\n          return age < diff;\n        });\n        toRemove.remove();\n      };\n    };\n\n    /**\n     * Updates or applies collection TTL settings.\n     * @param {int} age - age (in ms) to expire document from collection\n     * @param {int} interval - time (in ms) to clear collection of aged documents.\n     * @memberof Collection\n     */\n    Collection.prototype.setTTL = function (age, interval) {\n      if (age < 0) {\n        clearInterval(this.ttl.daemon);\n      } else {\n        this.ttl.age = age;\n        this.ttl.ttlInterval = interval;\n        this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n      }\n    };\n\n    /*----------------------------+\n    | INDEXING                    |\n    +----------------------------*/\n\n    /**\n     * create a row filter that covers all documents in the collection\n     */\n    Collection.prototype.prepareFullDocIndex = function () {\n      var len = this.data.length;\n      var indexes = new Array(len);\n      for (var i = 0; i < len; i += 1) {\n        indexes[i] = i;\n      }\n      return indexes;\n    };\n\n    /**\n     * Will allow reconfiguring certain collection options.\n     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n     * @memberof Collection\n     */\n    Collection.prototype.configureOptions = function (options) {\n      options = options || {};\n\n      if (options.hasOwnProperty('adaptiveBinaryIndices')) {\n        this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n        // if switching to adaptive binary indices, make sure none are 'dirty'\n        if (this.adaptiveBinaryIndices) {\n          this.ensureAllIndexes();\n        }\n      }\n    };\n\n    /**\n     * Ensure binary index on a certain field\n     * @param {string} property - name of property to create binary index on\n     * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n     * @memberof Collection\n     */\n    Collection.prototype.ensureIndex = function (property, force) {\n      // optional parameter to force rebuild whether flagged as dirty or not\n      if (typeof (force) === 'undefined') {\n        force = false;\n      }\n\n      if (property === null || property === undefined) {\n        throw new Error('Attempting to set index without an associated property');\n      }\n\n      if (this.binaryIndices[property] && !force) {\n        if (!this.binaryIndices[property].dirty) return;\n      }\n\n      // if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n      if (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {\n        return;\n      }\n\n      var index = {\n        'name': property,\n        'dirty': true,\n        'values': this.prepareFullDocIndex()\n      };\n      this.binaryIndices[property] = index;\n\n      var wrappedComparer =\n        (function (prop, data) {\n          var val1, val2;\n          var propPath = ~prop.indexOf('.') ? prop.split('.') : false;\n          return function (a, b) {\n            if (propPath) {\n              val1 = Utils.getIn(data[a], propPath, true);\n              val2 = Utils.getIn(data[b], propPath, true);\n            } else {\n              val1 = data[a][prop];\n              val2 = data[b][prop];\n            }\n\n            if (val1 !== val2) {\n              if (Comparators.lt(val1, val2, false)) return -1;\n              if (Comparators.gt(val1, val2, false)) return 1;\n            }\n            return 0;\n          };\n        })(property, this.data);\n\n      index.values.sort(wrappedComparer);\n      index.dirty = false;\n\n      this.dirty = true; // for autosave scenarios\n    };\n\n    /**\n     * Perform checks to determine validity/consistency of all binary indices\n     * @param {object=} options - optional configuration object\n     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used\n     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample\n     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered\n     * @returns {string[]} array of index names where problems were found.\n     * @memberof Collection\n     * @example\n     * // check all indices on a collection, returns array of invalid index names\n     * var result = coll.checkAllIndexes({ repair: true, randomSampling: true, randomSamplingFactor: 0.15 });\n     * if (result.length > 0) {\n     *   results.forEach(function(name) {\n     *     console.log('problem encountered with index : ' + name);\n     *   });\n     * }\n     */\n    Collection.prototype.checkAllIndexes = function (options) {\n      var key, bIndices = this.binaryIndices;\n      var results = [], result;\n\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          result = this.checkIndex(key, options);\n          if (!result) {\n            results.push(key);\n          }\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * Perform checks to determine validity/consistency of a binary index\n     * @param {string} property - name of the binary-indexed property to check\n     * @param {object=} options - optional configuration object\n     * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used\n     * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample\n     * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered\n     * @returns {boolean} whether the index was found to be valid (before optional correcting).\n     * @memberof Collection\n     * @example\n     * // full test\n     * var valid = coll.checkIndex('name');\n     * // full test with repair (if issues found)\n     * valid = coll.checkIndex('name', { repair: true });\n     * // random sampling (default is 10% of total document count)\n     * valid = coll.checkIndex('name', { randomSampling: true });\n     * // random sampling (sample 20% of total document count)\n     * valid = coll.checkIndex('name', { randomSampling: true, randomSamplingFactor: 0.20 });\n     * // random sampling (implied boolean)\n     * valid = coll.checkIndex('name', { randomSamplingFactor: 0.20 });\n     * // random sampling with repair (if issues found)\n     * valid = coll.checkIndex('name', { repair: true, randomSampling: true });\n     */\n    Collection.prototype.checkIndex = function (property, options) {\n      options = options || {};\n      // if 'randomSamplingFactor' specified but not 'randomSampling', assume true\n      if (options.randomSamplingFactor && options.randomSampling !== false) {\n        options.randomSampling = true;\n      }\n      options.randomSamplingFactor = options.randomSamplingFactor || 0.1;\n      if (options.randomSamplingFactor < 0 || options.randomSamplingFactor > 1) {\n        options.randomSamplingFactor = 0.1;\n      }\n\n      var valid = true, idx, iter, pos, len, biv;\n\n      // make sure we are passed a valid binary index name\n      if (!this.binaryIndices.hasOwnProperty(property)) {\n        throw new Error(\"called checkIndex on property without an index: \" + property);\n      }\n\n      // if lazy indexing, rebuild only if flagged as dirty\n      if (!this.adaptiveBinaryIndices) {\n        this.ensureIndex(property);\n      }\n\n      biv = this.binaryIndices[property].values;\n      len = biv.length;\n\n      // if the index has an incorrect number of values\n      if (len !== this.data.length) {\n        if (options.repair) {\n          this.ensureIndex(property, true);\n        }\n        return false;\n      }\n\n      if (len === 0) {\n        return true;\n      }\n\n      var usingDotNotation = (property.indexOf('.') !== -1);\n\n      if (len === 1) {\n        valid = (biv[0] === 0);\n      }\n      else {\n        if (options.randomSampling) {\n          // validate first and last\n          if (!LokiOps.$lte(Utils.getIn(this.data[biv[0]], property, usingDotNotation),\n            Utils.getIn(this.data[biv[1]], property, usingDotNotation))) {\n            valid = false;\n          }\n          if (!LokiOps.$lte(Utils.getIn(this.data[biv[len - 2]], property, usingDotNotation),\n            Utils.getIn(this.data[biv[len - 1]], property, usingDotNotation))) {\n            valid = false;\n          }\n\n          // if first and last positions are sorted correctly with their nearest neighbor,\n          // continue onto random sampling phase...\n          if (valid) {\n            // # random samplings = total count * sampling factor\n            iter = Math.floor((len - 1) * options.randomSamplingFactor);\n\n            // for each random sampling, validate that the binary index is sequenced properly\n            // with next higher value.\n            for (idx = 0; idx < iter - 1; idx++) {\n              // calculate random position\n              pos = Math.floor(Math.random() * (len - 1));\n              if (!LokiOps.$lte(Utils.getIn(this.data[biv[pos]], property, usingDotNotation),\n                Utils.getIn(this.data[biv[pos + 1]], property, usingDotNotation))) {\n                valid = false;\n                break;\n              }\n            }\n          }\n        }\n        else {\n          // validate that the binary index is sequenced properly\n          for (idx = 0; idx < len - 1; idx++) {\n            if (!LokiOps.$lte(Utils.getIn(this.data[biv[idx]], property, usingDotNotation),\n              Utils.getIn(this.data[biv[idx + 1]], property, usingDotNotation))) {\n              valid = false;\n              break;\n            }\n          }\n        }\n      }\n\n      // if incorrectly sequenced and we are to fix problems, rebuild index\n      if (!valid && options.repair) {\n        this.ensureIndex(property, true);\n      }\n\n      return valid;\n    };\n\n    Collection.prototype.getBinaryIndexValues = function (property) {\n      var idx, idxvals = this.binaryIndices[property].values;\n      var result = [];\n\n      for (idx = 0; idx < idxvals.length; idx++) {\n        result.push(Utils.getIn(this.data[idxvals[idx]], property, true));\n      }\n\n      return result;\n    };\n\n    /**\n     * Returns a named unique index\n     * @param {string} field - indexed field name\n     * @param {boolean} force - if `true`, will rebuild index; otherwise, function may return null\n     */\n    Collection.prototype.getUniqueIndex = function (field, force) {\n      var index = this.constraints.unique[field];\n      if (!index && force) {\n        return this.ensureUniqueIndex(field);\n      }\n      return index;\n    };\n\n    Collection.prototype.ensureUniqueIndex = function (field) {\n      var index = this.constraints.unique[field];\n      if (!index) {\n        // keep track of new unique index for regenerate after database (re)load.\n        if (this.uniqueNames.indexOf(field) == -1) {\n          this.uniqueNames.push(field);\n        }\n      }\n\n      // if index already existed, (re)loading it will likely cause collisions, rebuild always\n      this.constraints.unique[field] = index = new UniqueIndex(field);\n      this.data.forEach(function (obj) {\n        index.set(obj);\n      });\n      return index;\n    };\n\n    /**\n     * Ensure all binary indices\n     * @param {boolean} force - whether to force rebuild of existing lazy binary indices\n     * @memberof Collection\n     */\n    Collection.prototype.ensureAllIndexes = function (force) {\n      var key, bIndices = this.binaryIndices;\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          this.ensureIndex(key, force);\n        }\n      }\n    };\n\n    /**\n     * Internal method used to flag all lazy index as dirty\n     */\n    Collection.prototype.flagBinaryIndexesDirty = function () {\n      var key, bIndices = this.binaryIndices;\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          bIndices[key].dirty = true;\n        }\n      }\n    };\n\n    /**\n     * Internal method used to flag a lazy index as dirty\n     */\n    Collection.prototype.flagBinaryIndexDirty = function (index) {\n      if (this.binaryIndices[index])\n        this.binaryIndices[index].dirty = true;\n    };\n\n    /**\n     * Quickly determine number of documents in collection (or query)\n     * @param {object=} query - (optional) query object to count results of\n     * @returns {number} number of documents in the collection\n     * @memberof Collection\n     */\n    Collection.prototype.count = function (query) {\n      if (!query) {\n        return this.data.length;\n      }\n\n      return this.chain().find(query).filteredrows.length;\n    };\n\n    /**\n     * Rebuild idIndex\n     */\n    Collection.prototype.ensureId = function () {\n      if (this.idIndex) {\n        return;\n      }\n      var data = this.data,\n        i = 0;\n      var len = data.length;\n      var index = new Array(len);\n      for (i; i < len; i++) {\n        index[i] = data[i].$loki;\n      }\n      this.idIndex = index;\n    };\n\n    /**\n     * Rebuild idIndex async with callback - useful for background syncing with a remote server\n     */\n    Collection.prototype.ensureIdAsync = function (callback) {\n      this.async(function () {\n        this.ensureId();\n      }, callback);\n    };\n\n    /**\n     * Add a dynamic view to the collection\n     * @param {string} name - name of dynamic view to add\n     * @param {object=} options - options to configure dynamic view with\n     * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'\n     * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)\n     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n     * @returns {DynamicView} reference to the dynamic view added\n     * @memberof Collection\n     * @example\n     * var pview = users.addDynamicView('progeny');\n     * pview.applyFind({'age': {'$lte': 40}});\n     * pview.applySimpleSort('name');\n     *\n     * var results = pview.data();\n     **/\n\n    Collection.prototype.addDynamicView = function (name, options) {\n      var dv = new DynamicView(this, name, options);\n      this.DynamicViews.push(dv);\n\n      return dv;\n    };\n\n    /**\n     * Remove a dynamic view from the collection\n     * @param {string} name - name of dynamic view to remove\n     * @memberof Collection\n     **/\n    Collection.prototype.removeDynamicView = function (name) {\n      this.DynamicViews =\n        this.DynamicViews.filter(function (dv) { return dv.name !== name; });\n    };\n\n    /**\n     * Look up dynamic view reference from within the collection\n     * @param {string} name - name of dynamic view to retrieve reference of\n     * @returns {DynamicView} A reference to the dynamic view with that name\n     * @memberof Collection\n     **/\n    Collection.prototype.getDynamicView = function (name) {\n      for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n        if (this.DynamicViews[idx].name === name) {\n          return this.DynamicViews[idx];\n        }\n      }\n\n      return null;\n    };\n\n    /**\n     * Applies a 'mongo-like' find query object and passes all results to an update function.\n     * For filter function querying you should migrate to [updateWhere()]{@link Collection#updateWhere}.\n     *\n     * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n     * @param {function} updateFunction - update function to run against filtered documents\n     * @memberof Collection\n     */\n    Collection.prototype.findAndUpdate = function (filterObject, updateFunction) {\n      if (typeof (filterObject) === \"function\") {\n        this.updateWhere(filterObject, updateFunction);\n      }\n      else {\n        this.chain().find(filterObject).update(updateFunction);\n      }\n    };\n\n    /**\n     * Applies a 'mongo-like' find query object removes all documents which match that filter.\n     *\n     * @param {object} filterObject - 'mongo-like' query object\n     * @memberof Collection\n     */\n    Collection.prototype.findAndRemove = function (filterObject) {\n      this.chain().find(filterObject).remove();\n    };\n\n    /**\n     * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n     * @param {(object|array)} doc - the document (or array of documents) to be inserted\n     * @param {boolean=} overrideAdaptiveIndices - (optional) if `true`, adaptive indicies will be\n     *   temporarily disabled and then fully rebuilt after batch. This will be faster for\n     *   large inserts, but slower for small/medium inserts in large collections\n     * @returns {(object|array)} document or documents inserted\n     * @memberof Collection\n     * @example\n     * users.insert({\n     *     name: 'Odin',\n     *     age: 50,\n     *     address: 'Asgard'\n     * });\n     *\n     * // alternatively, insert array of documents\n     * users.insert([{ name: 'Thor', age: 35}, { name: 'Loki', age: 30}]);\n     */\n    Collection.prototype.insert = function (doc, overrideAdaptiveIndices) {\n      if (!Array.isArray(doc)) {\n        return this.insertOne(doc);\n      }\n\n      // holder to the clone of the object inserted if collections is set to clone objects\n      var obj;\n      var results = [];\n\n      // if not cloning, disable adaptive binary indices for the duration of the batch insert,\n      // followed by lazy rebuild and re-enabling adaptive indices after batch insert.\n      var adaptiveBatchOverride = overrideAdaptiveIndices && !this.cloneObjects &&\n        this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;\n\n      if (adaptiveBatchOverride) {\n        this.adaptiveBinaryIndices = false;\n      }\n\n      try {\n        this.emit('pre-insert', doc);\n        for (var i = 0, len = doc.length; i < len; i++) {\n          obj = this.insertOne(doc[i], true);\n          if (!obj) {\n            return undefined;\n          }\n          results.push(obj);\n        }\n      } finally {\n        if (adaptiveBatchOverride) {\n          this.ensureAllIndexes();\n          this.adaptiveBinaryIndices = true;\n        }\n      }\n\n      // at the 'batch' level, if clone option is true then emitted docs are clones\n      this.emit('insert', results);\n\n      // if clone option is set, clone return values\n      results = this.cloneObjects ? clone(results, this.cloneMethod) : results;\n\n      return results.length === 1 ? results[0] : results;\n    };\n\n    /**\n     * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n     * @param {object} doc - the document to be inserted\n     * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n     * @returns {object} document or 'undefined' if there was a problem inserting it\n     */\n    Collection.prototype.insertOne = function (doc, bulkInsert) {\n      var err = null;\n      var returnObj;\n\n      if (typeof doc !== 'object') {\n        err = new TypeError('Document needs to be an object');\n      } else if (doc === null) {\n        err = new TypeError('Object cannot be null');\n      }\n\n      if (err !== null) {\n        this.emit('error', err);\n        throw err;\n      }\n\n      // if configured to clone, do so now... otherwise just use same obj reference\n      var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n      if (!this.disableFreeze) {\n        obj = unFreeze(obj);\n      }\n\n      if (!this.disableMeta) {\n        if (typeof obj.meta === 'undefined') {\n          obj.meta = {\n            revision: 0,\n            created: 0\n          };\n        } else if (!this.disableFreeze) {\n          obj.meta = unFreeze(obj.meta);\n        }\n      }\n\n      // both 'pre-insert' and 'insert' events are passed internal data reference even when cloning\n      // insert needs internal reference because that is where loki itself listens to add meta\n      if (!bulkInsert) {\n        this.emit('pre-insert', obj);\n      }\n      if (!this.add(obj)) {\n        return undefined;\n      }\n\n      // update meta and store changes if ChangesAPI is enabled\n      // (moved from \"insert\" event listener to allow internal reference to be used)\n      if (this.disableChangesApi) {\n        this.insertMeta(obj);\n      } else {\n        this.insertMetaWithChange(obj);\n      }\n\n      if (!this.disableFreeze) {\n        deepFreeze(obj);\n      }\n\n      // if cloning is enabled, emit insert event with clone of new object\n      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\n      if (!bulkInsert) {\n        this.emit('insert', returnObj);\n      }\n\n      this.addAutoUpdateObserver(returnObj);\n\n      return returnObj;\n    };\n\n    /**\n     * Empties the collection.\n     * @param {object=} options - configure clear behavior\n     * @param {bool=} [options.removeIndices=false] - whether to remove indices in addition to data\n     * @memberof Collection\n     */\n    Collection.prototype.clear = function (options) {\n      var self = this;\n\n      options = options || {};\n\n      this.data = [];\n      this.idIndex = null;\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n      this.cachedData = null;\n      this.maxId = 0;\n      this.DynamicViews = [];\n      this.dirty = true;\n      this.constraints = {\n        unique: {},\n        exact: {}\n      };\n\n      // if removing indices entirely\n      if (options.removeIndices === true) {\n        this.binaryIndices = {};\n        this.uniqueNames = [];\n      }\n      // clear indices but leave definitions in place\n      else {\n        // clear binary indices\n        var keys = Object.keys(this.binaryIndices);\n        keys.forEach(function (biname) {\n          self.binaryIndices[biname].dirty = false;\n          self.binaryIndices[biname].values = [];\n        });\n      }\n    };\n\n    /**\n     * Updates an object and notifies collection that the document has changed.\n     * @param {object} doc - document to update within the collection\n     * @memberof Collection\n     */\n    Collection.prototype.update = function (doc) {\n      var adaptiveBatchOverride, k, len;\n\n      if (Array.isArray(doc)) {\n        len = doc.length;\n\n        // if not cloning, disable adaptive binary indices for the duration of the batch update,\n        // followed by lazy rebuild and re-enabling adaptive indices after batch update.\n        adaptiveBatchOverride = !this.cloneObjects &&\n          this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;\n\n        if (adaptiveBatchOverride) {\n          this.adaptiveBinaryIndices = false;\n        }\n\n        try {\n          for (k = 0; k < len; k += 1) {\n            this.update(doc[k]);\n          }\n        }\n        finally {\n          if (adaptiveBatchOverride) {\n            this.ensureAllIndexes();\n            this.adaptiveBinaryIndices = true;\n          }\n        }\n\n        return;\n      }\n\n      // verify object is a properly formed document\n      if (!hasOwnProperty.call(doc, '$loki')) {\n        throw new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n      }\n      try {\n        this.startTransaction();\n        var arr = this.get(doc.$loki, true),\n          oldInternal,   // ref to existing obj\n          newInternal, // ref to new internal obj\n          position,\n          self = this;\n\n        if (!arr) {\n          throw new Error('Trying to update a document not in collection.');\n        }\n\n        oldInternal = arr[0]; // -internal- obj ref\n        position = arr[1]; // position in data array\n\n        // if configured to clone, do so now... otherwise just use same obj reference\n        newInternal = this.cloneObjects || (!this.disableDeltaChangesApi && this.disableFreeze) ? clone(doc, this.cloneMethod) : doc;\n\n        this.emit('pre-update', doc);\n\n        this.uniqueNames.forEach(function (key) {\n          self.getUniqueIndex(key, true).update(oldInternal, newInternal);\n        });\n\n        // operate the update\n        this.data[position] = newInternal;\n\n        if (newInternal !== doc) {\n          this.addAutoUpdateObserver(doc);\n        }\n\n        // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].evaluateDocument(position, false);\n        }\n\n        var key;\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var bIndices = this.binaryIndices;\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexUpdate(position, key);\n          }\n        }\n        else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.idIndex[position] = newInternal.$loki;\n        //this.flagBinaryIndexesDirty();\n\n        if (this.isIncremental) {\n          this.dirtyIds.push(newInternal.$loki);\n        }\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n\n        // update meta and store changes if ChangesAPI is enabled\n        if (this.disableChangesApi) {\n          newInternal = this.updateMeta(newInternal);\n        } else {\n          newInternal = this.updateMetaWithChange(newInternal, oldInternal);\n        }\n\n        if (!this.disableFreeze) {\n          deepFreeze(newInternal);\n        }\n\n        var returnObj;\n\n        // if cloning is enabled, emit 'update' event and return with clone of new object\n        if (this.cloneObjects) {\n          returnObj = clone(newInternal, this.cloneMethod);\n        }\n        else {\n          returnObj = newInternal;\n        }\n\n        this.emit('update', returnObj, oldInternal);\n        return returnObj;\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        throw (err); // re-throw error so user does not think it succeeded\n      }\n    };\n\n    /**\n     * Add object to collection\n     */\n    Collection.prototype.add = function (obj) {\n      // if parameter isn't object exit with throw\n      if ('object' !== typeof obj) {\n        throw new TypeError('Object being added needs to be an object');\n      }\n      // if object you are adding already has id column it is either already in the collection\n      // or the object is carrying its own 'id' property.  If it also has a meta property,\n      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n      if (typeof (obj.$loki) !== 'undefined') {\n        throw new Error('Document is already in collection, please use update()');\n      }\n\n      /*\n       * try adding object to collection\n       */\n      try {\n        this.startTransaction();\n        this.maxId++;\n\n        if (isNaN(this.maxId)) {\n          this.maxId = (this.data[this.data.length - 1].$loki + 1);\n        }\n\n        var newId = this.maxId;\n        obj.$loki = newId;\n\n        if (!this.disableMeta) {\n          obj.meta.version = 0;\n        }\n\n        for (var i = 0, len = this.uniqueNames.length; i < len; i ++) {\n          this.getUniqueIndex(this.uniqueNames[i], true).set(obj);\n        }\n\n        if (this.idIndex) {\n          this.idIndex.push(newId);\n        }\n\n        if (this.isIncremental) {\n          this.dirtyIds.push(newId);\n        }\n\n        // add the object\n        this.data.push(obj);\n\n        var addedPos = this.data.length - 1;\n\n        // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n        var dvlen = this.DynamicViews.length;\n        for (i = 0; i < dvlen; i++) {\n          this.DynamicViews[i].evaluateDocument(addedPos, true);\n        }\n\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var bIndices = this.binaryIndices;\n          for (var key in bIndices) {\n            this.adaptiveBinaryIndexInsert(addedPos, key);\n          }\n        }\n        else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n\n        return (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        throw (err); // re-throw error so user does not think it succeeded\n      }\n    };\n\n    /**\n     * Applies a filter function and passes all results to an update function.\n     *\n     * @param {function} filterFunction - filter function whose results will execute update\n     * @param {function} updateFunction - update function to run against filtered documents\n     * @memberof Collection\n     */\n    Collection.prototype.updateWhere = function (filterFunction, updateFunction) {\n      var results = this.where(filterFunction),\n        i = 0,\n        obj;\n      try {\n        for (i; i < results.length; i++) {\n          obj = updateFunction(results[i]);\n          this.update(obj);\n        }\n\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n      }\n    };\n\n    /**\n     * Remove all documents matching supplied filter function.\n     * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n     * @param {function|object} query - query object to filter on\n     * @memberof Collection\n     */\n    Collection.prototype.removeWhere = function (query) {\n      var list;\n      if (typeof query === 'function') {\n        list = this.data.filter(query);\n        this.remove(list);\n      } else {\n        this.chain().find(query).remove();\n      }\n    };\n\n    Collection.prototype.removeDataOnly = function () {\n      this.remove(this.data.slice());\n    };\n\n    /**\n     * Internal method to remove a batch of documents from the collection.\n     * @param {number[]} positions - data/idIndex positions to remove\n     */\n    Collection.prototype.removeBatchByPositions = function (positions) {\n      var len = positions.length;\n      var xo = {};\n      var dlen, didx, idx;\n      var bic = Object.keys(this.binaryIndices).length;\n      var uic = Object.keys(this.constraints.unique).length;\n      var adaptiveOverride = this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;\n      var doc, self = this;\n\n      try {\n        this.startTransaction();\n\n        // create hashobject for positional removal inclusion tests...\n        // all keys defined in this hashobject represent $loki ids of the documents to remove.\n        this.ensureId();\n        for (idx = 0; idx < len; idx++) {\n          xo[this.idIndex[positions[idx]]] = true;\n        }\n\n        // if we will need to notify dynamic views and/or binary indices to update themselves...\n        dlen = this.DynamicViews.length;\n        if ((dlen > 0) || (bic > 0) || (uic > 0)) {\n          if (dlen > 0) {\n            // notify dynamic views to remove relevant documents at data positions\n            for (didx = 0; didx < dlen; didx++) {\n              // notify dv of remove (passing batch/array of positions)\n              this.DynamicViews[didx].removeDocument(positions);\n            }\n          }\n\n          // notify binary indices to update\n          if (this.adaptiveBinaryIndices && !adaptiveOverride) {\n            // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n            var key, bIndices = this.binaryIndices;\n\n            for (key in bIndices) {\n              this.adaptiveBinaryIndexRemove(positions, key);\n            }\n          }\n          else {\n            this.flagBinaryIndexesDirty();\n          }\n\n          if (uic) {\n            this.uniqueNames.forEach(function (key) {\n              var index = self.getUniqueIndex(key);\n              if (index) {\n                for (idx = 0; idx < len; idx++) {\n                  doc = self.data[positions[idx]];\n                  if (doc[key] !== null && doc[key] !== undefined) {\n                    index.remove(doc[key]);\n                  }\n                }\n              }\n            });\n          }\n        }\n\n        // emit 'delete' events only of listeners are attached.\n        // since data not removed yet, in future we can emit single delete event with array...\n        // for now that might be breaking change to put in potential 1.6 or LokiDB (lokijs2) version\n        if (!this.disableChangesApi || this.events.delete.length > 1) {\n          for (idx = 0; idx < len; idx++) {\n            this.emit('delete', this.data[positions[idx]]);\n          }\n        }\n\n        // remove from data[] :\n        // filter collection data for items not in inclusion hashobject\n        this.data = this.data.filter(function (obj) {\n          return !xo[obj.$loki];\n        });\n\n        if (this.isIncremental) {\n          for(idx=0; idx < len; idx++) {\n            this.dirtyIds.push(this.idIndex[positions[idx]]);\n          }\n        }\n\n        // remove from idIndex[] :\n        // filter idIndex for items not in inclusion hashobject\n        this.idIndex = this.idIndex.filter(function (id) {\n          return !xo[id];\n        });\n\n        if (this.adaptiveBinaryIndices && adaptiveOverride) {\n          this.adaptiveBinaryIndices = false;\n          this.ensureAllIndexes(true);\n          this.adaptiveBinaryIndices = true;\n        }\n\n        this.commit();\n\n        // flag collection as dirty for autosave\n        this.dirty = true;\n      }\n      catch (err) {\n        this.rollback();\n        if (adaptiveOverride) {\n          this.adaptiveBinaryIndices = true;\n        }\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        return null;\n      }\n    };\n\n    /**\n     *  Internal method called by remove()\n     * @param {object[]|number[]} batch - array of documents or $loki ids to remove\n     */\n    Collection.prototype.removeBatch = function (batch) {\n      var len = batch.length,\n        dlen = this.data.length,\n        idx;\n      var xlt = {};\n      var posx = [];\n\n      // create lookup hashobject to translate $loki id to position\n      for (idx = 0; idx < dlen; idx++) {\n        xlt[this.data[idx].$loki] = idx;\n      }\n\n      // iterate the batch\n      for (idx = 0; idx < len; idx++) {\n        if (typeof (batch[idx]) === 'object') {\n          posx.push(xlt[batch[idx].$loki]);\n        }\n        else {\n          posx.push(xlt[batch[idx]]);\n        }\n      }\n\n      this.removeBatchByPositions(posx);\n    };\n\n    /**\n     * Remove a document from the collection\n     * @param {object} doc - document to remove from collection\n     * @memberof Collection\n     */\n    Collection.prototype.remove = function (doc) {\n      var frozen;\n\n      if (typeof doc === 'number') {\n        doc = this.get(doc);\n      }\n\n      if ('object' !== typeof doc) {\n        throw new Error('Parameter is not an object');\n      }\n      if (Array.isArray(doc)) {\n        this.removeBatch(doc);\n        return;\n      }\n\n      if (!hasOwnProperty.call(doc, '$loki')) {\n        throw new Error('Object is not a document stored in the collection');\n      }\n\n      try {\n        this.startTransaction();\n        var arr = this.get(doc.$loki, true),\n          // obj = arr[0],\n          position = arr[1];\n        var self = this;\n        this.uniqueNames.forEach(function (key) {\n          if (doc[key] !== null && typeof doc[key] !== 'undefined') {\n            var index = self.getUniqueIndex(key);\n            if (index) {\n              index.remove(doc[key]);\n            }\n          }\n        });\n        // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to remove\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].removeDocument(position);\n        }\n\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var key, bIndices = this.binaryIndices;\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexRemove(position, key);\n          }\n        }\n        else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.data.splice(position, 1);\n        this.removeAutoUpdateObserver(doc);\n\n        // remove id from idIndex\n        this.idIndex.splice(position, 1);\n\n        if (this.isIncremental) {\n          this.dirtyIds.push(doc.$loki);\n        }\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n        this.emit('delete', arr[0]);\n\n        if (!this.disableFreeze) {\n          doc = unFreeze(doc);\n        }\n        delete doc.$loki;\n        delete doc.meta;\n        if (!this.disableFreeze) {\n          freeze(doc);\n        }\n        return doc;\n\n      } catch (err) {\n        this.rollback();\n        this.lokiConsoleWrapper.error(err.message);\n        this.emit('error', err);\n        return null;\n      }\n    };\n\n    /*---------------------+\n    | Finding methods     |\n    +----------------------*/\n\n    /**\n     * Get by Id - faster than other methods because of the searching algorithm\n     * @param {int} id - $loki id of document you want to retrieve\n     * @param {boolean} returnPosition - if 'true' we will return [object, position]\n     * @returns {(object|array|null)} Object reference if document was found, null if not,\n     *     or an array if 'returnPosition' was passed.\n     * @memberof Collection\n     */\n    Collection.prototype.get = function (id, returnPosition) {\n      if (!this.idIndex) {\n        this.ensureId();\n      }\n\n      var retpos = returnPosition || false,\n        data = this.idIndex,\n        max = data.length - 1,\n        min = 0,\n        mid = (min + max) >> 1;\n\n      id = typeof id === 'number' ? id : parseInt(id, 10);\n\n      if (isNaN(id)) {\n        throw new TypeError('Passed id is not an integer');\n      }\n\n      while (data[min] < data[max]) {\n        mid = (min + max) >> 1;\n\n        if (data[mid] < id) {\n          min = mid + 1;\n        } else {\n          max = mid;\n        }\n      }\n\n      if (max === min && data[min] === id) {\n        if (retpos) {\n          return [this.data[min], min];\n        }\n        return this.data[min];\n      }\n      return null;\n\n    };\n\n    /**\n     * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n     *    Since multiple documents may contain the same value (which the index is sorted on),\n     *    we hone in on range and then linear scan range to find exact index array position.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.getBinaryIndexPosition = function (dataPosition, binaryIndexName) {\n      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, true);\n      var index = this.binaryIndices[binaryIndexName].values;\n\n      // i think calculateRange can probably be moved to collection\n      // as it doesn't seem to need resultset.  need to verify\n      var range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n      if (range[0] === 0 && range[1] === -1) {\n        // uhoh didn't find range\n        return null;\n      }\n\n      var min = range[0];\n      var max = range[1];\n\n      // narrow down the sub-segment of index values\n      // where the indexed property value exactly matches our\n      // value and then linear scan to find exact -index- position\n      for (var idx = min; idx <= max; idx++) {\n        if (index[idx] === dataPosition) return idx;\n      }\n\n      // uhoh\n      return null;\n    };\n\n    /**\n     * Adaptively insert a selected item to the index.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.adaptiveBinaryIndexInsert = function (dataPosition, binaryIndexName) {\n      var usingDotNotation = (binaryIndexName.indexOf('.') !== -1);\n      var index = this.binaryIndices[binaryIndexName].values;\n      var val = Utils.getIn(this.data[dataPosition], binaryIndexName, usingDotNotation);\n\n      // If you are inserting a javascript Date value into a binary index, convert to epoch time\n      if (this.serializableIndices === true && val instanceof Date) {\n        this.data[dataPosition][binaryIndexName] = val.getTime();\n        val = Utils.getIn(this.data[dataPosition], binaryIndexName);\n      }\n\n      var idxPos = (index.length === 0) ? 0 : this.calculateRangeStart(binaryIndexName, val, true, usingDotNotation);\n\n      // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n      // doing this after adjusting dataPositions so no clash with previous item at that position.\n      this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n    };\n\n    /**\n     * Adaptively update a selected item within an index.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.adaptiveBinaryIndexUpdate = function (dataPosition, binaryIndexName) {\n      // linear scan needed to find old position within index unless we optimize for clone scenarios later\n      // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n      var idxPos,\n        index = this.binaryIndices[binaryIndexName].values,\n        len = index.length;\n\n      for (idxPos = 0; idxPos < len; idxPos++) {\n        if (index[idxPos] === dataPosition) break;\n      }\n\n      //var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n      //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n      this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n    };\n\n    /**\n     * Adaptively remove a selected item from the index.\n     * @param {number|number[]} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.adaptiveBinaryIndexRemove = function (dataPosition, binaryIndexName, removedFromIndexOnly) {\n      var bi = this.binaryIndices[binaryIndexName];\n      var len, idx, rmidx, rmlen, rxo = {};\n      var curr, shift, idxPos;\n\n      if (Array.isArray(dataPosition)) {\n        // when called from chained remove, and only one document in array,\n        // it will be faster to use old algorithm\n        rmlen = dataPosition.length;\n        if (rmlen === 1) {\n          dataPosition = dataPosition[0];\n        }\n        // we were passed an array (batch) of documents so use this 'batch optimized' algorithm\n        else {\n          for (rmidx = 0; rmidx < rmlen; rmidx++) {\n            rxo[dataPosition[rmidx]] = true;\n          }\n\n          // remove document from index (with filter function)\n          bi.values = bi.values.filter(function (di) { return !rxo[di]; });\n\n          // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n          // in which case data positions stay the same.\n          if (removedFromIndexOnly === true) {\n            return;\n          }\n\n          var sortedPositions = dataPosition.slice();\n          sortedPositions.sort(function (a, b) { return a - b; });\n\n          // to remove holes, we need to 'shift down' the index's data array positions\n          // we need to adjust array positions -1 for each index data positions greater than removed positions\n          len = bi.values.length;\n          for (idx = 0; idx < len; idx++) {\n            curr = bi.values[idx];\n            shift = 0;\n            for (rmidx = 0; rmidx < rmlen && curr > sortedPositions[rmidx]; rmidx++) {\n              shift++;\n            }\n            bi.values[idx] -= shift;\n          }\n\n          // batch processed, bail out\n          return;\n        }\n\n        // not a batch so continue...\n      }\n\n      idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\n      if (idxPos === null) {\n        // throw new Error('unable to determine binary index position');\n        return null;\n      }\n\n      // remove document from index (with splice)\n      bi.values.splice(idxPos, 1);\n\n      // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n      // in which case data positions stay the same.\n      if (removedFromIndexOnly === true) {\n        return;\n      }\n\n      // since index stores data array positions, if we remove a document\n      // we need to adjust array positions -1 for all document positions greater than removed position\n      len = bi.values.length;\n      for (idx = 0; idx < len; idx++) {\n        if (bi.values[idx] > dataPosition) {\n          bi.values[idx]--;\n        }\n      }\n    };\n\n    /**\n     * Internal method used for index maintenance and indexed searching.\n     * Calculates the beginning of an index range for a given value.\n     * For index maintainance (adaptive:true), we will return a valid index position to insert to.\n     * For querying (adaptive:false/undefined), we will :\n     *    return lower bound/index of range of that value (if found)\n     *    return next lower index position if not found (hole)\n     * If index is empty it is assumed to be handled at higher level, so\n     * this method assumes there is at least 1 document in index.\n     *\n     * @param {string} prop - name of property which has binary index\n     * @param {any} val - value to find within index\n     * @param {bool?} adaptive - if true, we will return insert position\n     */\n    Collection.prototype.calculateRangeStart = function (prop, val, adaptive, usingDotNotation) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n\n      if (index.length === 0) {\n        return -1;\n      }\n\n      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);\n      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);\n\n      // hone in on start position of value\n      while (min < max) {\n        mid = (min + max) >> 1;\n\n        if (Comparators.lt(Utils.getIn(rcd[index[mid]], prop, usingDotNotation), val, false)) {\n          min = mid + 1;\n        } else {\n          max = mid;\n        }\n      }\n\n      var lbound = min;\n\n      // found it... return it\n      if (Comparators.aeq(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation))) {\n        return lbound;\n      }\n\n      // if not in index and our value is less than the found one\n      if (Comparators.lt(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), false)) {\n        return adaptive ? lbound : lbound - 1;\n      }\n\n      // not in index and our value is greater than the found one\n      return adaptive ? lbound + 1 : lbound;\n    };\n\n    /**\n     * Internal method used for indexed $between.  Given a prop (index name), and a value\n     * (which may or may not yet exist) this will find the final position of that upper range value.\n     */\n    Collection.prototype.calculateRangeEnd = function (prop, val, usingDotNotation) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n\n      if (index.length === 0) {\n        return -1;\n      }\n\n      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);\n      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);\n\n      // hone in on start position of value\n      while (min < max) {\n        mid = (min + max) >> 1;\n\n        if (Comparators.lt(val, Utils.getIn(rcd[index[mid]], prop, usingDotNotation), false)) {\n          max = mid;\n        } else {\n          min = mid + 1;\n        }\n      }\n\n      var ubound = max;\n\n      // only eq if last element in array is our val\n      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation))) {\n        return ubound;\n      }\n\n      // if not in index and our value is less than the found one\n      if (Comparators.gt(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), false)) {\n        return ubound + 1;\n      }\n\n      // either hole or first nonmatch\n      if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound - 1]], prop, usingDotNotation))) {\n        return ubound - 1;\n      }\n\n      // hole, so ubound if nearest gt than the val we were looking for\n      return ubound;\n    };\n\n    /**\n     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n     *    this is used for collection.find() and first find filter of resultset/dynview\n     *    slightly different than get() binary search in that get() hones in on 1 value,\n     *    but we have to hone in on many (range)\n     * @param {string} op - operation, such as $eq\n     * @param {string} prop - name of property to calculate range for\n     * @param {object} val - value to use for range calculation.\n     * @returns {array} [start, end] index array positions\n     */\n    Collection.prototype.calculateRange = function (op, prop, val) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n      var lbound, lval;\n      var ubound, uval;\n\n      // when no documents are in collection, return empty range condition\n      if (rcd.length === 0) {\n        return [0, -1];\n      }\n\n      var usingDotNotation = (prop.indexOf('.') !== -1);\n\n      var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);\n      var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);\n\n      // if value falls outside of our range return [0, -1] to designate no results\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {\n            return [0, -1];\n          }\n          break;\n        case '$dteq':\n          if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {\n            return [0, -1];\n          }\n          break;\n        case '$gt':\n          // none are within range\n          if (Comparators.gt(val, maxVal, true)) {\n            return [0, -1];\n          }\n          // all are within range\n          if (Comparators.gt(minVal, val, false)) {\n            return [min, max];\n          }\n          break;\n        case '$gte':\n          // none are within range\n          if (Comparators.gt(val, maxVal, false)) {\n            return [0, -1];\n          }\n          // all are within range\n          if (Comparators.gt(minVal, val, true)) {\n            return [min, max];\n          }\n          break;\n        case '$lt':\n          // none are within range\n          if (Comparators.lt(val, minVal, true)) {\n            return [0, -1];\n          }\n          // all are within range\n          if (Comparators.lt(maxVal, val, false)) {\n            return [min, max];\n          }\n          break;\n        case '$lte':\n          // none are within range\n          if (Comparators.lt(val, minVal, false)) {\n            return [0, -1];\n          }\n          // all are within range\n          if (Comparators.lt(maxVal, val, true)) {\n            return [min, max];\n          }\n          break;\n        case '$between':\n          // none are within range (low range is greater)\n          if (Comparators.gt(val[0], maxVal, false)) {\n            return [0, -1];\n          }\n          // none are within range (high range lower)\n          if (Comparators.lt(val[1], minVal, false)) {\n            return [0, -1];\n          }\n\n          lbound = this.calculateRangeStart(prop, val[0], false, usingDotNotation);\n          ubound = this.calculateRangeEnd(prop, val[1], usingDotNotation);\n\n          if (lbound < 0) lbound++;\n          if (ubound > max) ubound--;\n\n          if (!Comparators.gt(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val[0], true)) lbound++;\n          if (!Comparators.lt(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val[1], true)) ubound--;\n\n          if (ubound < lbound) return [0, -1];\n\n          return ([lbound, ubound]);\n        case '$in':\n          var idxset = [],\n            segResult = [];\n          // query each value '$eq' operator and merge the seqment results.\n          for (var j = 0, len = val.length; j < len; j++) {\n            var seg = this.calculateRange('$eq', prop, val[j]);\n\n            for (var i = seg[0]; i <= seg[1]; i++) {\n              if (idxset[i] === undefined) {\n                idxset[i] = true;\n                segResult.push(i);\n              }\n            }\n          }\n          return segResult;\n      }\n\n      // determine lbound where needed\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n        case '$dteq':\n        case '$gte':\n        case '$lt':\n          lbound = this.calculateRangeStart(prop, val, false, usingDotNotation);\n          lval = Utils.getIn(rcd[index[lbound]], prop, usingDotNotation);\n          break;\n        default: break;\n      }\n\n      // determine ubound where needed\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n        case '$dteq':\n        case '$lte':\n        case '$gt':\n          ubound = this.calculateRangeEnd(prop, val, usingDotNotation);\n          uval = Utils.getIn(rcd[index[ubound]], prop, usingDotNotation);\n          break;\n        default: break;\n      }\n\n\n      switch (op) {\n        case '$eq':\n        case '$aeq':\n        case '$dteq':\n          // if hole (not found)\n          if (!Comparators.aeq(lval, val)) {\n            return [0, -1];\n          }\n\n          return [lbound, ubound];\n\n        case '$gt':\n          // if hole (not found) ub position is already greater\n          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {\n            return [ubound, max];\n          }\n          // otherwise (found) so ubound is still equal, get next\n          return [ubound + 1, max];\n\n        case '$gte':\n          // if hole (not found) lb position marks left outside of range\n          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {\n            return [lbound + 1, max];\n          }\n          // otherwise (found) so lb is first position where its equal\n          return [lbound, max];\n\n        case '$lt':\n          // if hole (not found) position already is less than\n          if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {\n            return [min, lbound];\n          }\n          // otherwise (found) so lb marks left inside of eq range, get previous\n          return [min, lbound - 1];\n\n        case '$lte':\n          // if hole (not found) ub position marks right outside so get previous\n          if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {\n            return [min, ubound - 1];\n          }\n          // otherwise (found) so ub is last position where its still equal\n          return [min, ubound];\n\n        default:\n          return [0, rcd.length - 1];\n      }\n    };\n\n    /**\n     * Retrieve doc by Unique index\n     * @param {string} field - name of uniquely indexed property to use when doing lookup\n     * @param {value} value - unique value to search for\n     * @returns {object} document matching the value passed\n     * @memberof Collection\n     */\n    Collection.prototype.by = function (field, value) {\n      var self;\n      if (value === undefined) {\n        self = this;\n        return function (value) {\n          return self.by(field, value);\n        };\n      }\n\n      var result = this.getUniqueIndex(field, true).get(value);\n      if (!this.cloneObjects) {\n        return result;\n      } else {\n        return clone(result, this.cloneMethod);\n      }\n    };\n\n    /**\n     * Find one object by index property, by property equal to value\n     * @param {object} query - query object used to perform search with\n     * @returns {(object|null)} First matching document, or null if none\n     * @memberof Collection\n     */\n    Collection.prototype.findOne = function (query) {\n      query = query || {};\n\n      // Instantiate Resultset and exec find op passing firstOnly = true param\n      var result = this.chain().find(query, true).data();\n\n      if (Array.isArray(result) && result.length === 0) {\n        return null;\n      } else {\n        if (!this.cloneObjects) {\n          return result[0];\n        } else {\n          return clone(result[0], this.cloneMethod);\n        }\n      }\n    };\n\n    /**\n     * Chain method, used for beginning a series of chained find() and/or view() operations\n     * on a collection.\n     *\n     * @param {string|array=} transform - named transform or array of transform steps\n     * @param {object=} parameters - Object containing properties representing parameters to substitute\n     * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n     * @memberof Collection\n     */\n    Collection.prototype.chain = function (transform, parameters) {\n      var rs = new Resultset(this);\n\n      if (typeof transform === 'undefined') {\n        return rs;\n      }\n\n      return rs.transform(transform, parameters);\n    };\n\n    /**\n     * Find method, api is similar to mongodb.\n     * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n     * @example {@tutorial Query Examples}\n     * @param {object} query - 'mongo-like' query object\n     * @returns {array} Array of matching documents\n     * @memberof Collection\n     */\n    Collection.prototype.find = function (query) {\n      return this.chain().find(query).data();\n    };\n\n    /**\n     * Find object by unindexed field by property equal to value,\n     * simply iterates and returns the first element matching the query\n     */\n    Collection.prototype.findOneUnindexed = function (prop, value) {\n      var i = this.data.length,\n        doc;\n      while (i--) {\n        if (Utils.getIn(this.data[i], prop, true) === value) {\n          doc = this.data[i];\n          return doc;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Transaction methods\n     */\n\n    /** start the transation */\n    Collection.prototype.startTransaction = function () {\n      if (this.transactional) {\n        this.cachedData = clone(this.data, this.cloneMethod);\n        this.cachedIndex = this.idIndex;\n        this.cachedBinaryIndex = this.binaryIndices;\n        this.cachedDirtyIds = this.dirtyIds;\n\n        // propagate startTransaction to dynamic views\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].startTransaction();\n        }\n      }\n    };\n\n    /** commit the transation */\n    Collection.prototype.commit = function () {\n      if (this.transactional) {\n        this.cachedData = null;\n        this.cachedIndex = null;\n        this.cachedBinaryIndex = null;\n        this.cachedDirtyIds = null;\n\n        // propagate commit to dynamic views\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].commit();\n        }\n      }\n    };\n\n    /** roll back the transation */\n    Collection.prototype.rollback = function () {\n      if (this.transactional) {\n        if (this.cachedData !== null && this.cachedIndex !== null) {\n          this.data = this.cachedData;\n          this.idIndex = this.cachedIndex;\n          this.binaryIndices = this.cachedBinaryIndex;\n          this.dirtyIds = this.cachedDirtyIds;\n        }\n\n        // propagate rollback to dynamic views\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].rollback();\n        }\n      }\n    };\n\n    // async executor. This is only to enable callbacks at the end of the execution.\n    Collection.prototype.async = function (fun, callback) {\n      setTimeout(function () {\n        if (typeof fun === 'function') {\n          fun();\n          callback();\n        } else {\n          throw new TypeError('Argument passed for async execution is not a function');\n        }\n      }, 0);\n    };\n\n    /**\n     * Query the collection by supplying a javascript filter function.\n     * @example\n     * var results = coll.where(function(obj) {\n     *   return obj.legs === 8;\n     * });\n     *\n     * @param {function} fun - filter function to run against all collection docs\n     * @returns {array} all documents which pass your filter function\n     * @memberof Collection\n     */\n    Collection.prototype.where = function (fun) {\n      return this.chain().where(fun).data();\n    };\n\n    /**\n     * Map Reduce operation\n     *\n     * @param {function} mapFunction - function to use as map function\n     * @param {function} reduceFunction - function to use as reduce function\n     * @returns {data} The result of your mapReduce operation\n     * @memberof Collection\n     */\n    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data.map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    /**\n     * Join two collections on specified properties\n     *\n     * @param {array|Resultset|Collection} joinData - array of documents to 'join' to this collection\n     * @param {string} leftJoinProp - property name in collection\n     * @param {string} rightJoinProp - property name in joinData\n     * @param {function=} mapFun - (Optional) map function to use\n     * @param {object=} dataOptions - options to data() before input to your map function\n     * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n     * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n     * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     * @returns {Resultset} Result of the mapping operation\n     * @memberof Collection\n     */\n    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions) {\n      // logic in Resultset class\n      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun, dataOptions);\n    };\n\n    /* ------ STAGING API -------- */\n    /**\n     * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n     * manipulated without affecting the data in the original collection\n     */\n    Collection.prototype.stages = {};\n\n    /**\n     * (Staging API) create a stage and/or retrieve it\n     * @memberof Collection\n     */\n    Collection.prototype.getStage = function (name) {\n      if (!this.stages[name]) {\n        this.stages[name] = {};\n      }\n      return this.stages[name];\n    };\n    /**\n     * a collection of objects recording the changes applied through a commmitStage\n     */\n    Collection.prototype.commitLog = [];\n\n    /**\n     * (Staging API) create a copy of an object and insert it into a stage\n     * @memberof Collection\n     */\n    Collection.prototype.stage = function (stageName, obj) {\n      var copy = JSON.parse(JSON.stringify(obj));\n      this.getStage(stageName)[obj.$loki] = copy;\n      return copy;\n    };\n\n    /**\n     * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n     * then create a message to be inserted in the commitlog\n     * @param {string} stageName - name of stage\n     * @param {string} message\n     * @memberof Collection\n     */\n    Collection.prototype.commitStage = function (stageName, message) {\n      var stage = this.getStage(stageName),\n        prop,\n        timestamp = new Date().getTime();\n\n      for (prop in stage) {\n\n        this.update(stage[prop]);\n        this.commitLog.push({\n          timestamp: timestamp,\n          message: message,\n          data: JSON.parse(JSON.stringify(stage[prop]))\n        });\n      }\n      this.stages[stageName] = {};\n    };\n\n    Collection.prototype.no_op = function () {\n      return;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.extract = function (field) {\n      var i = 0,\n        len = this.data.length,\n        isDotNotation = isDeepProperty(field),\n        result = [];\n      for (i; i < len; i += 1) {\n        result.push(deepProperty(this.data[i], field, isDotNotation));\n      }\n      return result;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.max = function (field) {\n      return Math.max.apply(null, this.extract(field));\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.min = function (field) {\n      return Math.min.apply(null, this.extract(field));\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.maxRecord = function (field) {\n      var i = 0,\n        len = this.data.length,\n        deep = isDeepProperty(field),\n        result = {\n          index: 0,\n          value: undefined\n        },\n        max;\n\n      for (i; i < len; i += 1) {\n        if (max !== undefined) {\n          if (max < deepProperty(this.data[i], field, deep)) {\n            max = deepProperty(this.data[i], field, deep);\n            result.index = this.data[i].$loki;\n          }\n        } else {\n          max = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      }\n      result.value = max;\n      return result;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.minRecord = function (field) {\n      var i = 0,\n        len = this.data.length,\n        deep = isDeepProperty(field),\n        result = {\n          index: 0,\n          value: undefined\n        },\n        min;\n\n      for (i; i < len; i += 1) {\n        if (min !== undefined) {\n          if (min > deepProperty(this.data[i], field, deep)) {\n            min = deepProperty(this.data[i], field, deep);\n            result.index = this.data[i].$loki;\n          }\n        } else {\n          min = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      }\n      result.value = min;\n      return result;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.extractNumerical = function (field) {\n      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n        return !(isNaN(n));\n      });\n    };\n\n    /**\n     * Calculates the average numerical value of a property\n     *\n     * @param {string} field - name of property in docs to average\n     * @returns {number} average of property in all docs in the collection\n     * @memberof Collection\n     */\n    Collection.prototype.avg = function (field) {\n      return average(this.extractNumerical(field));\n    };\n\n    /**\n     * Calculate standard deviation of a field\n     * @memberof Collection\n     * @param {string} field\n     */\n    Collection.prototype.stdDev = function (field) {\n      return standardDeviation(this.extractNumerical(field));\n    };\n\n    /**\n     * @memberof Collection\n     * @param {string} field\n     */\n    Collection.prototype.mode = function (field) {\n      var dict = {},\n        data = this.extract(field);\n      data.forEach(function (obj) {\n        if (dict[obj]) {\n          dict[obj] += 1;\n        } else {\n          dict[obj] = 1;\n        }\n      });\n      var max,\n        prop, mode;\n      for (prop in dict) {\n        if (max) {\n          if (max < dict[prop]) {\n            mode = prop;\n          }\n        } else {\n          mode = prop;\n          max = dict[prop];\n        }\n      }\n      return mode;\n    };\n\n    /**\n     * @memberof Collection\n     * @param {string} field - property name\n     */\n    Collection.prototype.median = function (field) {\n      var values = this.extractNumerical(field);\n      values.sort(sub);\n\n      var half = Math.floor(values.length / 2);\n\n      if (values.length % 2) {\n        return values[half];\n      } else {\n        return (values[half - 1] + values[half]) / 2.0;\n      }\n    };\n\n    /**\n     * General utils, including statistical functions\n     */\n    function isDeepProperty(field) {\n      return field.indexOf('.') !== -1;\n    }\n\n    function parseBase10(num) {\n      return parseFloat(num, 10);\n    }\n\n    function isNotUndefined(obj) {\n      return obj !== undefined;\n    }\n\n    function add(a, b) {\n      return a + b;\n    }\n\n    function sub(a, b) {\n      return a - b;\n    }\n\n    function median(values) {\n      values.sort(sub);\n      var half = Math.floor(values.length / 2);\n      return (values.length % 2) ? values[half] : ((values[half - 1] + values[half]) / 2.0);\n    }\n\n    function average(array) {\n      return (array.reduce(add, 0)) / array.length;\n    }\n\n    function standardDeviation(values) {\n      var avg = average(values);\n      var squareDiffs = values.map(function (value) {\n        var diff = value - avg;\n        var sqrDiff = diff * diff;\n        return sqrDiff;\n      });\n\n      var avgSquareDiff = average(squareDiffs);\n\n      var stdDev = Math.sqrt(avgSquareDiff);\n      return stdDev;\n    }\n\n    function deepProperty(obj, property, isDeep) {\n      if (isDeep === false) {\n        // pass without processing\n        return obj[property];\n      }\n      var pieces = property.split('.'),\n        root = obj;\n      while (pieces.length > 0) {\n        root = root[pieces.shift()];\n      }\n      return root;\n    }\n\n    function binarySearch(array, item, fun) {\n      var lo = 0,\n        hi = array.length,\n        compared,\n        mid;\n      while (lo < hi) {\n        mid = (lo + hi) >> 1;\n        compared = fun.apply(null, [item, array[mid]]);\n        if (compared === 0) {\n          return {\n            found: true,\n            index: mid\n          };\n        } else if (compared < 0) {\n          hi = mid;\n        } else {\n          lo = mid + 1;\n        }\n      }\n      return {\n        found: false,\n        index: hi\n      };\n    }\n\n    function BSonSort(fun) {\n      return function (array, item) {\n        return binarySearch(array, item, fun);\n      };\n    }\n\n    function KeyValueStore() { }\n\n    KeyValueStore.prototype = {\n      keys: [],\n      values: [],\n      sort: function (a, b) {\n        return (a < b) ? -1 : ((a > b) ? 1 : 0);\n      },\n      setSort: function (fun) {\n        this.bs = new BSonSort(fun);\n      },\n      bs: function () {\n        return new BSonSort(this.sort);\n      },\n      set: function (key, value) {\n        var pos = this.bs(this.keys, key);\n        if (pos.found) {\n          this.values[pos.index] = value;\n        } else {\n          this.keys.splice(pos.index, 0, key);\n          this.values.splice(pos.index, 0, value);\n        }\n      },\n      get: function (key) {\n        return this.values[binarySearch(this.keys, key, this.sort).index];\n      }\n    };\n\n    function UniqueIndex(uniqueField) {\n      this.field = uniqueField;\n      this.keyMap = Object.create(null);\n      this.lokiMap = Object.create(null);\n    }\n    UniqueIndex.prototype.keyMap = {};\n    UniqueIndex.prototype.lokiMap = {};\n    UniqueIndex.prototype.set = function (obj) {\n      var fieldValue = obj[this.field];\n      if (fieldValue !== null && typeof (fieldValue) !== 'undefined') {\n        if (this.keyMap[fieldValue]) {\n          throw new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n        } else {\n          this.keyMap[fieldValue] = obj;\n          this.lokiMap[obj.$loki] = fieldValue;\n        }\n      }\n    };\n    UniqueIndex.prototype.get = function (key) {\n      return this.keyMap[key];\n    };\n\n    UniqueIndex.prototype.byId = function (id) {\n      return this.keyMap[this.lokiMap[id]];\n    };\n    /**\n     * Updates a document's unique index given an updated object.\n     * @param  {Object} obj Original document object\n     * @param  {Object} doc New document object (likely the same as obj)\n     */\n    UniqueIndex.prototype.update = function (obj, doc) {\n      if (this.lokiMap[obj.$loki] !== doc[this.field]) {\n        var old = this.lokiMap[obj.$loki];\n        this.set(doc);\n        // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n        this.keyMap[old] = undefined;\n      } else {\n        this.keyMap[obj[this.field]] = doc;\n      }\n    };\n    UniqueIndex.prototype.remove = function (key) {\n      var obj = this.keyMap[key];\n      if (obj !== null && typeof obj !== 'undefined') {\n        // avoid using `delete`\n        this.keyMap[key] = undefined;\n        this.lokiMap[obj.$loki] = undefined;\n      } else {\n        throw new Error('Key is not in unique index: ' + this.field);\n      }\n    };\n    UniqueIndex.prototype.clear = function () {\n      this.keyMap = Object.create(null);\n      this.lokiMap = Object.create(null);\n    };\n\n    function ExactIndex(exactField) {\n      this.index = Object.create(null);\n      this.field = exactField;\n    }\n\n    // add the value you want returned to the key in the index\n    ExactIndex.prototype = {\n      set: function add(key, val) {\n        if (this.index[key]) {\n          this.index[key].push(val);\n        } else {\n          this.index[key] = [val];\n        }\n      },\n\n      // remove the value from the index, if the value was the last one, remove the key\n      remove: function remove(key, val) {\n        var idxSet = this.index[key];\n        for (var i in idxSet) {\n          if (idxSet[i] == val) {\n            idxSet.splice(i, 1);\n          }\n        }\n        if (idxSet.length < 1) {\n          this.index[key] = undefined;\n        }\n      },\n\n      // get the values related to the key, could be more than one\n      get: function get(key) {\n        return this.index[key];\n      },\n\n      // clear will zap the index\n      clear: function clear(key) {\n        this.index = {};\n      }\n    };\n\n    function SortedIndex(sortedField) {\n      this.field = sortedField;\n    }\n\n    SortedIndex.prototype = {\n      keys: [],\n      values: [],\n      // set the default sort\n      sort: function (a, b) {\n        return (a < b) ? -1 : ((a > b) ? 1 : 0);\n      },\n      bs: function () {\n        return new BSonSort(this.sort);\n      },\n      // and allow override of the default sort\n      setSort: function (fun) {\n        this.bs = new BSonSort(fun);\n      },\n      // add the value you want returned  to the key in the index\n      set: function (key, value) {\n        var pos = binarySearch(this.keys, key, this.sort);\n        if (pos.found) {\n          this.values[pos.index].push(value);\n        } else {\n          this.keys.splice(pos.index, 0, key);\n          this.values.splice(pos.index, 0, [value]);\n        }\n      },\n      // get all values which have a key == the given key\n      get: function (key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        if (bsr.found) {\n          return this.values[bsr.index];\n        } else {\n          return [];\n        }\n      },\n      // get all values which have a key < the given key\n      getLt: function (key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        var pos = bsr.index;\n        if (bsr.found) pos--;\n        return this.getAll(key, 0, pos);\n      },\n      // get all values which have a key > the given key\n      getGt: function (key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        var pos = bsr.index;\n        if (bsr.found) pos++;\n        return this.getAll(key, pos, this.keys.length);\n      },\n\n      // get all vals from start to end\n      getAll: function (key, start, end) {\n        var results = [];\n        for (var i = start; i < end; i++) {\n          results = results.concat(this.values[i]);\n        }\n        return results;\n      },\n      // just in case someone wants to do something smart with ranges\n      getPos: function (key) {\n        return binarySearch(this.keys, key, this.sort);\n      },\n      // remove the value from the index, if the value was the last one, remove the key\n      remove: function (key, value) {\n        var pos = binarySearch(this.keys, key, this.sort).index;\n        var idxSet = this.values[pos];\n        for (var i in idxSet) {\n          if (idxSet[i] == value) idxSet.splice(i, 1);\n        }\n        if (idxSet.length < 1) {\n          this.keys.splice(pos, 1);\n          this.values.splice(pos, 1);\n        }\n      },\n      // clear will zap the index\n      clear: function () {\n        this.keys = [];\n        this.values = [];\n      }\n    };\n\n    Loki.deepFreeze = deepFreeze;\n    Loki.freeze = freeze;\n    Loki.unFreeze = unFreeze;\n    Loki.LokiOps = LokiOps;\n    Loki.Collection = Collection;\n    Loki.DynamicView = DynamicView;\n    Loki.Resultset = Resultset;\n    Loki.KeyValueStore = KeyValueStore;\n    Loki.LokiMemoryAdapter = LokiMemoryAdapter;\n    Loki.LokiPartitioningAdapter = LokiPartitioningAdapter;\n    Loki.LokiLocalStorageAdapter = LokiLocalStorageAdapter;\n    Loki.LokiFsAdapter = LokiFsAdapter;\n    Loki.persistenceAdapters = {\n      fs: LokiFsAdapter,\n      localStorage: LokiLocalStorageAdapter\n    };\n    Loki.aeq = aeqHelper;\n    Loki.lt = ltHelper;\n    Loki.gt = gtHelper;\n    Loki.Comparators = Comparators;\n    return Loki;\n  }());\n\n}));\n"]},"metadata":{},"sourceType":"script"}
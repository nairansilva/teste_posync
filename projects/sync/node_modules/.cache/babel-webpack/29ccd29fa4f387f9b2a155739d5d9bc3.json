{"ast":null,"code":"/**\n * this queue tracks the currently running database-interactions\n * so we know when the database is in idle-state and can call\n * requestIdlePromise for semi-important actions\n */\n'use strict';\n/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\n\nvar IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\n\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n\n    _tryIdleCall(this);\n  },\n\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n\n    this.lock();\n    var maybePromise;\n\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n\n        throw err;\n      });\n    }\n  },\n\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n\n      resolve();\n    };\n\n    prom._manRes = resolveFromOutside;\n\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n\n    this._iC.add(prom);\n\n    _tryIdleCall(this);\n\n    return prom;\n  },\n\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n\n    this._hPM.set(handle, promise);\n\n    this._pHM.set(promise, handle);\n\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n\n    this.cancelIdlePromise(promise);\n  },\n\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this; // remove all non-cleared\n\n\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n\n    this._qC = 0;\n\n    this._iC.clear();\n\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n\n  var iterator = idleQueue._iC.values();\n\n  var oldestPromise = iterator.next().value;\n\n  oldestPromise._manRes(); // try to call the next tick\n\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n\n;\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n\n    idleQueue._hPM[\"delete\"](handle);\n\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n\n  idleQueue._iC[\"delete\"](promise);\n}\n\n;\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n\n    ;\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n\n      _resolveOneIdleCall(idleQueue);\n\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}\n\n;\nexport default IdleQueue;","map":{"version":3,"sources":["C:/Totvs/po-angular/node_modules/custom-idle-queue/dist/es/index.js"],"names":["IdleQueue","parallels","arguments","length","undefined","_parallels","_qC","_iC","Set","_lHN","_hPM","Map","_pHM","prototype","isIdle","lock","unlock","_tryIdleCall","wrapCall","fun","_this","maybePromise","err","then","ret","requestIdlePromise","options","_this2","resolve","prom","Promise","res","resolveFromOutside","_removeIdlePromise","_manRes","timeout","timeoutObj","setTimeout","_timeoutObj","add","cancelIdlePromise","promise","requestIdleCallback","callback","handle","set","cancelIdleCallback","get","clear","_this3","forEach","_resolveOneIdleCall","idleQueue","size","iterator","values","oldestPromise","next","value","clearTimeout","has","_tryIR"],"mappings":"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","sourcesContent":["/**\n * this queue tracks the currently running database-interactions\n * so we know when the database is in idle-state and can call\n * requestIdlePromise for semi-important actions\n */\n'use strict';\n/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\n\nvar IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\n\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n\n    _tryIdleCall(this);\n  },\n\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n\n    this.lock();\n    var maybePromise;\n\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n\n        throw err;\n      });\n    }\n  },\n\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n\n      resolve();\n    };\n\n    prom._manRes = resolveFromOutside;\n\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n\n    this._iC.add(prom);\n\n    _tryIdleCall(this);\n\n    return prom;\n  },\n\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n\n    this._hPM.set(handle, promise);\n\n    this._pHM.set(promise, handle);\n\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n\n    this.cancelIdlePromise(promise);\n  },\n\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n\n    this._qC = 0;\n\n    this._iC.clear();\n\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n\n  var iterator = idleQueue._iC.values();\n\n  var oldestPromise = iterator.next().value;\n\n  oldestPromise._manRes(); // try to call the next tick\n\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n\n;\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n\n    idleQueue._hPM[\"delete\"](handle);\n\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n\n  idleQueue._iC[\"delete\"](promise);\n}\n\n;\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n\n    ;\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n\n      _resolveOneIdleCall(idleQueue);\n\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}\n\n;\nexport default IdleQueue;"]},"metadata":{},"sourceType":"module"}
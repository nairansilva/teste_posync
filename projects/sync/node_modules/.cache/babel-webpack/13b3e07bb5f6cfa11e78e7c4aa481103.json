{"ast":null,"code":"import _inherits from \"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license Angular v12.0.2\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { EventEmitter, Injectable, InjectionToken, Inject, Optional } from '@angular/core';\nimport { LocationStrategy } from '@angular/common';\nimport { Subject } from 'rxjs';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A spy for {@link Location} that allows tests to fire simulated location events.\n *\n * @publicApi\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar SpyLocation = /*#__PURE__*/function () {\n  function SpyLocation() {\n    _classCallCheck(this, SpyLocation);\n\n    this.urlChanges = [];\n    this._history = [new LocationState('', '', null)];\n    this._historyIndex = 0;\n    /** @internal */\n\n    this._subject = new EventEmitter();\n    /** @internal */\n\n    this._baseHref = '';\n    /** @internal */\n\n    this._platformStrategy = null;\n    /** @internal */\n\n    this._platformLocation = null;\n    /** @internal */\n\n    this._urlChangeListeners = [];\n  }\n\n  _createClass(SpyLocation, [{\n    key: \"setInitialPath\",\n    value: function setInitialPath(url) {\n      this._history[this._historyIndex].path = url;\n    }\n  }, {\n    key: \"setBaseHref\",\n    value: function setBaseHref(url) {\n      this._baseHref = url;\n    }\n  }, {\n    key: \"path\",\n    value: function path() {\n      return this._history[this._historyIndex].path;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._history[this._historyIndex].state;\n    }\n  }, {\n    key: \"isCurrentPathEqualTo\",\n    value: function isCurrentPathEqualTo(path) {\n      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n      var currPath = this.path().endsWith('/') ? this.path().substring(0, this.path().length - 1) : this.path();\n      return currPath == givenPath + (query.length > 0 ? '?' + query : '');\n    }\n  }, {\n    key: \"simulateUrlPop\",\n    value: function simulateUrlPop(pathname) {\n      this._subject.emit({\n        'url': pathname,\n        'pop': true,\n        'type': 'popstate'\n      });\n    }\n  }, {\n    key: \"simulateHashChange\",\n    value: function simulateHashChange(pathname) {\n      // Because we don't prevent the native event, the browser will independently update the path\n      this.setInitialPath(pathname);\n      this.urlChanges.push('hash: ' + pathname);\n\n      this._subject.emit({\n        'url': pathname,\n        'pop': true,\n        'type': 'hashchange'\n      });\n    }\n  }, {\n    key: \"prepareExternalUrl\",\n    value: function prepareExternalUrl(url) {\n      if (url.length > 0 && !url.startsWith('/')) {\n        url = '/' + url;\n      }\n\n      return this._baseHref + url;\n    }\n  }, {\n    key: \"go\",\n    value: function go(path) {\n      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      path = this.prepareExternalUrl(path);\n\n      if (this._historyIndex > 0) {\n        this._history.splice(this._historyIndex + 1);\n      }\n\n      this._history.push(new LocationState(path, query, state));\n\n      this._historyIndex = this._history.length - 1;\n      var locationState = this._history[this._historyIndex - 1];\n\n      if (locationState.path == path && locationState.query == query) {\n        return;\n      }\n\n      var url = path + (query.length > 0 ? '?' + query : '');\n      this.urlChanges.push(url);\n\n      this._subject.emit({\n        'url': url,\n        'pop': false\n      });\n    }\n  }, {\n    key: \"replaceState\",\n    value: function replaceState(path) {\n      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      path = this.prepareExternalUrl(path);\n      var history = this._history[this._historyIndex];\n\n      if (history.path == path && history.query == query) {\n        return;\n      }\n\n      history.path = path;\n      history.query = query;\n      history.state = state;\n      var url = path + (query.length > 0 ? '?' + query : '');\n      this.urlChanges.push('replace: ' + url);\n    }\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      if (this._historyIndex < this._history.length - 1) {\n        this._historyIndex++;\n\n        this._subject.emit({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true\n        });\n      }\n    }\n  }, {\n    key: \"back\",\n    value: function back() {\n      if (this._historyIndex > 0) {\n        this._historyIndex--;\n\n        this._subject.emit({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true\n        });\n      }\n    }\n  }, {\n    key: \"historyGo\",\n    value: function historyGo() {\n      var relativePosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var nextPageIndex = this._historyIndex + relativePosition;\n\n      if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n        this._historyIndex = nextPageIndex;\n\n        this._subject.emit({\n          'url': this.path(),\n          'state': this.getState(),\n          'pop': true,\n          'type': 'popstate'\n        });\n      }\n    }\n  }, {\n    key: \"onUrlChange\",\n    value: function onUrlChange(fn) {\n      var _this = this;\n\n      this._urlChangeListeners.push(fn);\n\n      if (!this._urlChangeSubscription) {\n        this._urlChangeSubscription = this.subscribe(function (v) {\n          _this._notifyUrlChangeListeners(v.url, v.state);\n        });\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_notifyUrlChangeListeners\",\n    value: function _notifyUrlChangeListeners() {\n      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var state = arguments.length > 1 ? arguments[1] : undefined;\n\n      this._urlChangeListeners.forEach(function (fn) {\n        return fn(url, state);\n      });\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(onNext, onThrow, onReturn) {\n      return this._subject.subscribe({\n        next: onNext,\n        error: onThrow,\n        complete: onReturn\n      });\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(url) {\n      return null;\n    }\n  }]);\n\n  return SpyLocation;\n}();\n\nSpyLocation.ɵfac = function SpyLocation_Factory(t) {\n  return new (t || SpyLocation)();\n};\n\nSpyLocation.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: SpyLocation,\n  factory: SpyLocation.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SpyLocation, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nvar LocationState = function LocationState(path, query, state) {\n  _classCallCheck(this, LocationState);\n\n  this.path = path;\n  this.query = query;\n  this.state = state;\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A mock implementation of {@link LocationStrategy} that allows tests to fire simulated\n * location events.\n *\n * @publicApi\n */\n\n\nvar MockLocationStrategy = /*#__PURE__*/function (_LocationStrategy) {\n  _inherits(MockLocationStrategy, _LocationStrategy);\n\n  var _super = _createSuper(MockLocationStrategy);\n\n  function MockLocationStrategy() {\n    var _this2;\n\n    _classCallCheck(this, MockLocationStrategy);\n\n    _this2 = _super.call(this);\n    _this2.internalBaseHref = '/';\n    _this2.internalPath = '/';\n    _this2.internalTitle = '';\n    _this2.urlChanges = [];\n    /** @internal */\n\n    _this2._subject = new EventEmitter();\n    _this2.stateChanges = [];\n    return _this2;\n  }\n\n  _createClass(MockLocationStrategy, [{\n    key: \"simulatePopState\",\n    value: function simulatePopState(url) {\n      this.internalPath = url;\n\n      this._subject.emit(new _MockPopStateEvent(this.path()));\n    }\n  }, {\n    key: \"path\",\n    value: function path() {\n      var includeHash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.internalPath;\n    }\n  }, {\n    key: \"prepareExternalUrl\",\n    value: function prepareExternalUrl(internal) {\n      if (internal.startsWith('/') && this.internalBaseHref.endsWith('/')) {\n        return this.internalBaseHref + internal.substring(1);\n      }\n\n      return this.internalBaseHref + internal;\n    }\n  }, {\n    key: \"pushState\",\n    value: function pushState(ctx, title, path, query) {\n      // Add state change to changes array\n      this.stateChanges.push(ctx);\n      this.internalTitle = title;\n      var url = path + (query.length > 0 ? '?' + query : '');\n      this.internalPath = url;\n      var externalUrl = this.prepareExternalUrl(url);\n      this.urlChanges.push(externalUrl);\n    }\n  }, {\n    key: \"replaceState\",\n    value: function replaceState(ctx, title, path, query) {\n      // Reset the last index of stateChanges to the ctx (state) object\n      this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;\n      this.internalTitle = title;\n      var url = path + (query.length > 0 ? '?' + query : '');\n      this.internalPath = url;\n      var externalUrl = this.prepareExternalUrl(url);\n      this.urlChanges.push('replace: ' + externalUrl);\n    }\n  }, {\n    key: \"onPopState\",\n    value: function onPopState(fn) {\n      this._subject.subscribe({\n        next: fn\n      });\n    }\n  }, {\n    key: \"getBaseHref\",\n    value: function getBaseHref() {\n      return this.internalBaseHref;\n    }\n  }, {\n    key: \"back\",\n    value: function back() {\n      if (this.urlChanges.length > 0) {\n        this.urlChanges.pop();\n        this.stateChanges.pop();\n        var nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : '';\n        this.simulatePopState(nextUrl);\n      }\n    }\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      throw 'not implemented';\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this.stateChanges[(this.stateChanges.length || 1) - 1];\n    }\n  }]);\n\n  return MockLocationStrategy;\n}(LocationStrategy);\n\nMockLocationStrategy.ɵfac = function MockLocationStrategy_Factory(t) {\n  return new (t || MockLocationStrategy)();\n};\n\nMockLocationStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: MockLocationStrategy,\n  factory: MockLocationStrategy.ɵfac\n});\n\nMockLocationStrategy.ctorParameters = function () {\n  return [];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MockLocationStrategy, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n\nvar _MockPopStateEvent = function _MockPopStateEvent(newUrl) {\n  _classCallCheck(this, _MockPopStateEvent);\n\n  this.newUrl = newUrl;\n  this.pop = true;\n  this.type = 'popstate';\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Parser from https://tools.ietf.org/html/rfc3986#appendix-B\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n *\n * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related\n *\n * Results in:\n *\n * $1 = http:\n * $2 = http\n * $3 = //www.ics.uci.edu\n * $4 = www.ics.uci.edu\n * $5 = /pub/ietf/uri/\n * $6 = <undefined>\n * $7 = <undefined>\n * $8 = #Related\n * $9 = Related\n */\n\n\nvar urlParse = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\nfunction parseUrl(urlStr, baseHref) {\n  var verifyProtocol = /^((http[s]?|ftp):\\/\\/)/;\n  var serverBase; // URL class requires full URL. If the URL string doesn't start with protocol, we need to add\n  // an arbitrary base URL which can be removed afterward.\n\n  if (!verifyProtocol.test(urlStr)) {\n    serverBase = 'http://empty.com/';\n  }\n\n  var parsedUrl;\n\n  try {\n    parsedUrl = new URL(urlStr, serverBase);\n  } catch (e) {\n    var result = urlParse.exec(serverBase || '' + urlStr);\n\n    if (!result) {\n      throw new Error(\"Invalid URL: \".concat(urlStr, \" with base: \").concat(baseHref));\n    }\n\n    var hostSplit = result[4].split(':');\n    parsedUrl = {\n      protocol: result[1],\n      hostname: hostSplit[0],\n      port: hostSplit[1] || '',\n      pathname: result[5],\n      search: result[6],\n      hash: result[8]\n    };\n  }\n\n  if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {\n    parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);\n  }\n\n  return {\n    hostname: !serverBase && parsedUrl.hostname || '',\n    protocol: !serverBase && parsedUrl.protocol || '',\n    port: !serverBase && parsedUrl.port || '',\n    pathname: parsedUrl.pathname || '/',\n    search: parsedUrl.search || '',\n    hash: parsedUrl.hash || ''\n  };\n}\n/**\n * Provider for mock platform location config\n *\n * @publicApi\n */\n\n\nvar MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');\n/**\n * Mock implementation of URL state.\n *\n * @publicApi\n */\n\nvar MockPlatformLocation = /*#__PURE__*/function () {\n  function MockPlatformLocation(config) {\n    _classCallCheck(this, MockPlatformLocation);\n\n    this.baseHref = '';\n    this.hashUpdate = new Subject();\n    this.urlChangeIndex = 0;\n    this.urlChanges = [{\n      hostname: '',\n      protocol: '',\n      port: '',\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null\n    }];\n\n    if (config) {\n      this.baseHref = config.appBaseHref || '';\n      var parsedChanges = this.parseChanges(null, config.startUrl || 'http://<empty>/', this.baseHref);\n      this.urlChanges[0] = Object.assign({}, parsedChanges);\n    }\n  }\n\n  _createClass(MockPlatformLocation, [{\n    key: \"hostname\",\n    get: function get() {\n      return this.urlChanges[this.urlChangeIndex].hostname;\n    }\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this.urlChanges[this.urlChangeIndex].protocol;\n    }\n  }, {\n    key: \"port\",\n    get: function get() {\n      return this.urlChanges[this.urlChangeIndex].port;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.urlChanges[this.urlChangeIndex].pathname;\n    }\n  }, {\n    key: \"search\",\n    get: function get() {\n      return this.urlChanges[this.urlChangeIndex].search;\n    }\n  }, {\n    key: \"hash\",\n    get: function get() {\n      return this.urlChanges[this.urlChangeIndex].hash;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.urlChanges[this.urlChangeIndex].state;\n    }\n  }, {\n    key: \"getBaseHrefFromDOM\",\n    value: function getBaseHrefFromDOM() {\n      return this.baseHref;\n    }\n  }, {\n    key: \"onPopState\",\n    value: function onPopState(fn) {\n      // No-op: a state stack is not implemented, so\n      // no events will ever come.\n      return function () {};\n    }\n  }, {\n    key: \"onHashChange\",\n    value: function onHashChange(fn) {\n      var subscription = this.hashUpdate.subscribe(fn);\n      return function () {\n        return subscription.unsubscribe();\n      };\n    }\n  }, {\n    key: \"href\",\n    get: function get() {\n      var url = \"\".concat(this.protocol, \"//\").concat(this.hostname).concat(this.port ? ':' + this.port : '');\n      url += \"\".concat(this.pathname === '/' ? '' : this.pathname).concat(this.search).concat(this.hash);\n      return url;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return \"\".concat(this.pathname).concat(this.search).concat(this.hash);\n    }\n  }, {\n    key: \"parseChanges\",\n    value: function parseChanges(state, url) {\n      var baseHref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      // When the `history.state` value is stored, it is always copied.\n      state = JSON.parse(JSON.stringify(state));\n      return Object.assign(Object.assign({}, parseUrl(url, baseHref)), {\n        state: state\n      });\n    }\n  }, {\n    key: \"replaceState\",\n    value: function replaceState(state, title, newUrl) {\n      var _this$parseChanges = this.parseChanges(state, newUrl),\n          pathname = _this$parseChanges.pathname,\n          search = _this$parseChanges.search,\n          parsedState = _this$parseChanges.state,\n          hash = _this$parseChanges.hash;\n\n      this.urlChanges[this.urlChangeIndex] = Object.assign(Object.assign({}, this.urlChanges[this.urlChangeIndex]), {\n        pathname: pathname,\n        search: search,\n        hash: hash,\n        state: parsedState\n      });\n    }\n  }, {\n    key: \"pushState\",\n    value: function pushState(state, title, newUrl) {\n      var _this$parseChanges2 = this.parseChanges(state, newUrl),\n          pathname = _this$parseChanges2.pathname,\n          search = _this$parseChanges2.search,\n          parsedState = _this$parseChanges2.state,\n          hash = _this$parseChanges2.hash;\n\n      if (this.urlChangeIndex > 0) {\n        this.urlChanges.splice(this.urlChangeIndex + 1);\n      }\n\n      this.urlChanges.push(Object.assign(Object.assign({}, this.urlChanges[this.urlChangeIndex]), {\n        pathname: pathname,\n        search: search,\n        hash: hash,\n        state: parsedState\n      }));\n      this.urlChangeIndex = this.urlChanges.length - 1;\n    }\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      var oldUrl = this.url;\n      var oldHash = this.hash;\n\n      if (this.urlChangeIndex < this.urlChanges.length) {\n        this.urlChangeIndex++;\n      }\n\n      this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n  }, {\n    key: \"back\",\n    value: function back() {\n      var oldUrl = this.url;\n      var oldHash = this.hash;\n\n      if (this.urlChangeIndex > 0) {\n        this.urlChangeIndex--;\n      }\n\n      this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n  }, {\n    key: \"historyGo\",\n    value: function historyGo() {\n      var relativePosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var oldUrl = this.url;\n      var oldHash = this.hash;\n      var nextPageIndex = this.urlChangeIndex + relativePosition;\n\n      if (nextPageIndex >= 0 && nextPageIndex < this.urlChanges.length) {\n        this.urlChangeIndex = nextPageIndex;\n      }\n\n      this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this.state;\n    }\n  }, {\n    key: \"scheduleHashUpdate\",\n    value: function scheduleHashUpdate(oldHash, oldUrl) {\n      var _this3 = this;\n\n      if (oldHash !== this.hash) {\n        scheduleMicroTask(function () {\n          return _this3.hashUpdate.next({\n            type: 'hashchange',\n            state: null,\n            oldUrl: oldUrl,\n            newUrl: _this3.url\n          });\n        });\n      }\n    }\n  }]);\n\n  return MockPlatformLocation;\n}();\n\nMockPlatformLocation.ɵfac = function MockPlatformLocation_Factory(t) {\n  return new (t || MockPlatformLocation)(ɵngcc0.ɵɵinject(MOCK_PLATFORM_LOCATION_CONFIG, 8));\n};\n\nMockPlatformLocation.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: MockPlatformLocation,\n  factory: MockPlatformLocation.ɵfac\n});\n\nMockPlatformLocation.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [MOCK_PLATFORM_LOCATION_CONFIG]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MockPlatformLocation, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [MOCK_PLATFORM_LOCATION_CONFIG]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\nfunction scheduleMicroTask(cb) {\n  Promise.resolve(null).then(cb);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MOCK_PLATFORM_LOCATION_CONFIG, MockLocationStrategy, MockPlatformLocation, SpyLocation }; //# sourceMappingURL=testing.js.map","map":{"version":3,"sources":["C:/Totvs/po-angular/node_modules/@angular/common/__ivy_ngcc__/fesm2015/testing.js"],"names":["EventEmitter","Injectable","InjectionToken","Inject","Optional","LocationStrategy","Subject","ɵngcc0","SpyLocation","urlChanges","_history","LocationState","_historyIndex","_subject","_baseHref","_platformStrategy","_platformLocation","_urlChangeListeners","url","path","state","query","givenPath","endsWith","substring","length","currPath","pathname","emit","setInitialPath","push","startsWith","prepareExternalUrl","splice","locationState","history","getState","relativePosition","nextPageIndex","fn","_urlChangeSubscription","subscribe","v","_notifyUrlChangeListeners","forEach","onNext","onThrow","onReturn","next","error","complete","ɵfac","SpyLocation_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","MockLocationStrategy","internalBaseHref","internalPath","internalTitle","stateChanges","_MockPopStateEvent","includeHash","internal","ctx","title","externalUrl","pop","nextUrl","simulatePopState","MockLocationStrategy_Factory","ctorParameters","newUrl","urlParse","parseUrl","urlStr","baseHref","verifyProtocol","serverBase","test","parsedUrl","URL","e","result","exec","Error","hostSplit","split","protocol","hostname","port","search","hash","indexOf","MOCK_PLATFORM_LOCATION_CONFIG","MockPlatformLocation","config","hashUpdate","urlChangeIndex","appBaseHref","parsedChanges","parseChanges","startUrl","Object","assign","subscription","unsubscribe","JSON","parse","stringify","parsedState","oldUrl","oldHash","scheduleHashUpdate","scheduleMicroTask","MockPlatformLocation_Factory","ɵɵinject","undefined","decorators","args","cb","Promise","resolve","then"],"mappings":"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","sourcesContent":["/**\n * @license Angular v12.0.2\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { EventEmitter, Injectable, InjectionToken, Inject, Optional } from '@angular/core';\nimport { LocationStrategy } from '@angular/common';\nimport { Subject } from 'rxjs';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A spy for {@link Location} that allows tests to fire simulated location events.\n *\n * @publicApi\n */\nimport * as ɵngcc0 from '@angular/core';\nclass SpyLocation {\n    constructor() {\n        this.urlChanges = [];\n        this._history = [new LocationState('', '', null)];\n        this._historyIndex = 0;\n        /** @internal */\n        this._subject = new EventEmitter();\n        /** @internal */\n        this._baseHref = '';\n        /** @internal */\n        this._platformStrategy = null;\n        /** @internal */\n        this._platformLocation = null;\n        /** @internal */\n        this._urlChangeListeners = [];\n    }\n    setInitialPath(url) {\n        this._history[this._historyIndex].path = url;\n    }\n    setBaseHref(url) {\n        this._baseHref = url;\n    }\n    path() {\n        return this._history[this._historyIndex].path;\n    }\n    getState() {\n        return this._history[this._historyIndex].state;\n    }\n    isCurrentPathEqualTo(path, query = '') {\n        const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n        const currPath = this.path().endsWith('/') ? this.path().substring(0, this.path().length - 1) : this.path();\n        return currPath == givenPath + (query.length > 0 ? ('?' + query) : '');\n    }\n    simulateUrlPop(pathname) {\n        this._subject.emit({ 'url': pathname, 'pop': true, 'type': 'popstate' });\n    }\n    simulateHashChange(pathname) {\n        // Because we don't prevent the native event, the browser will independently update the path\n        this.setInitialPath(pathname);\n        this.urlChanges.push('hash: ' + pathname);\n        this._subject.emit({ 'url': pathname, 'pop': true, 'type': 'hashchange' });\n    }\n    prepareExternalUrl(url) {\n        if (url.length > 0 && !url.startsWith('/')) {\n            url = '/' + url;\n        }\n        return this._baseHref + url;\n    }\n    go(path, query = '', state = null) {\n        path = this.prepareExternalUrl(path);\n        if (this._historyIndex > 0) {\n            this._history.splice(this._historyIndex + 1);\n        }\n        this._history.push(new LocationState(path, query, state));\n        this._historyIndex = this._history.length - 1;\n        const locationState = this._history[this._historyIndex - 1];\n        if (locationState.path == path && locationState.query == query) {\n            return;\n        }\n        const url = path + (query.length > 0 ? ('?' + query) : '');\n        this.urlChanges.push(url);\n        this._subject.emit({ 'url': url, 'pop': false });\n    }\n    replaceState(path, query = '', state = null) {\n        path = this.prepareExternalUrl(path);\n        const history = this._history[this._historyIndex];\n        if (history.path == path && history.query == query) {\n            return;\n        }\n        history.path = path;\n        history.query = query;\n        history.state = state;\n        const url = path + (query.length > 0 ? ('?' + query) : '');\n        this.urlChanges.push('replace: ' + url);\n    }\n    forward() {\n        if (this._historyIndex < (this._history.length - 1)) {\n            this._historyIndex++;\n            this._subject.emit({ 'url': this.path(), 'state': this.getState(), 'pop': true });\n        }\n    }\n    back() {\n        if (this._historyIndex > 0) {\n            this._historyIndex--;\n            this._subject.emit({ 'url': this.path(), 'state': this.getState(), 'pop': true });\n        }\n    }\n    historyGo(relativePosition = 0) {\n        const nextPageIndex = this._historyIndex + relativePosition;\n        if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n            this._historyIndex = nextPageIndex;\n            this._subject.emit({ 'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate' });\n        }\n    }\n    onUrlChange(fn) {\n        this._urlChangeListeners.push(fn);\n        if (!this._urlChangeSubscription) {\n            this._urlChangeSubscription = this.subscribe(v => {\n                this._notifyUrlChangeListeners(v.url, v.state);\n            });\n        }\n    }\n    /** @internal */\n    _notifyUrlChangeListeners(url = '', state) {\n        this._urlChangeListeners.forEach(fn => fn(url, state));\n    }\n    subscribe(onNext, onThrow, onReturn) {\n        return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });\n    }\n    normalize(url) {\n        return null;\n    }\n}\nSpyLocation.ɵfac = function SpyLocation_Factory(t) { return new (t || SpyLocation)(); };\nSpyLocation.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SpyLocation, factory: SpyLocation.ɵfac });\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SpyLocation, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\nclass LocationState {\n    constructor(path, query, state) {\n        this.path = path;\n        this.query = query;\n        this.state = state;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A mock implementation of {@link LocationStrategy} that allows tests to fire simulated\n * location events.\n *\n * @publicApi\n */\nclass MockLocationStrategy extends LocationStrategy {\n    constructor() {\n        super();\n        this.internalBaseHref = '/';\n        this.internalPath = '/';\n        this.internalTitle = '';\n        this.urlChanges = [];\n        /** @internal */\n        this._subject = new EventEmitter();\n        this.stateChanges = [];\n    }\n    simulatePopState(url) {\n        this.internalPath = url;\n        this._subject.emit(new _MockPopStateEvent(this.path()));\n    }\n    path(includeHash = false) {\n        return this.internalPath;\n    }\n    prepareExternalUrl(internal) {\n        if (internal.startsWith('/') && this.internalBaseHref.endsWith('/')) {\n            return this.internalBaseHref + internal.substring(1);\n        }\n        return this.internalBaseHref + internal;\n    }\n    pushState(ctx, title, path, query) {\n        // Add state change to changes array\n        this.stateChanges.push(ctx);\n        this.internalTitle = title;\n        const url = path + (query.length > 0 ? ('?' + query) : '');\n        this.internalPath = url;\n        const externalUrl = this.prepareExternalUrl(url);\n        this.urlChanges.push(externalUrl);\n    }\n    replaceState(ctx, title, path, query) {\n        // Reset the last index of stateChanges to the ctx (state) object\n        this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;\n        this.internalTitle = title;\n        const url = path + (query.length > 0 ? ('?' + query) : '');\n        this.internalPath = url;\n        const externalUrl = this.prepareExternalUrl(url);\n        this.urlChanges.push('replace: ' + externalUrl);\n    }\n    onPopState(fn) {\n        this._subject.subscribe({ next: fn });\n    }\n    getBaseHref() {\n        return this.internalBaseHref;\n    }\n    back() {\n        if (this.urlChanges.length > 0) {\n            this.urlChanges.pop();\n            this.stateChanges.pop();\n            const nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : '';\n            this.simulatePopState(nextUrl);\n        }\n    }\n    forward() {\n        throw 'not implemented';\n    }\n    getState() {\n        return this.stateChanges[(this.stateChanges.length || 1) - 1];\n    }\n}\nMockLocationStrategy.ɵfac = function MockLocationStrategy_Factory(t) { return new (t || MockLocationStrategy)(); };\nMockLocationStrategy.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MockLocationStrategy, factory: MockLocationStrategy.ɵfac });\nMockLocationStrategy.ctorParameters = () => [];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MockLocationStrategy, [{\n        type: Injectable\n    }], function () { return []; }, null); })();\nclass _MockPopStateEvent {\n    constructor(newUrl) {\n        this.newUrl = newUrl;\n        this.pop = true;\n        this.type = 'popstate';\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parser from https://tools.ietf.org/html/rfc3986#appendix-B\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n *\n * Example: http://www.ics.uci.edu/pub/ietf/uri/#Related\n *\n * Results in:\n *\n * $1 = http:\n * $2 = http\n * $3 = //www.ics.uci.edu\n * $4 = www.ics.uci.edu\n * $5 = /pub/ietf/uri/\n * $6 = <undefined>\n * $7 = <undefined>\n * $8 = #Related\n * $9 = Related\n */\nconst urlParse = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nfunction parseUrl(urlStr, baseHref) {\n    const verifyProtocol = /^((http[s]?|ftp):\\/\\/)/;\n    let serverBase;\n    // URL class requires full URL. If the URL string doesn't start with protocol, we need to add\n    // an arbitrary base URL which can be removed afterward.\n    if (!verifyProtocol.test(urlStr)) {\n        serverBase = 'http://empty.com/';\n    }\n    let parsedUrl;\n    try {\n        parsedUrl = new URL(urlStr, serverBase);\n    }\n    catch (e) {\n        const result = urlParse.exec(serverBase || '' + urlStr);\n        if (!result) {\n            throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);\n        }\n        const hostSplit = result[4].split(':');\n        parsedUrl = {\n            protocol: result[1],\n            hostname: hostSplit[0],\n            port: hostSplit[1] || '',\n            pathname: result[5],\n            search: result[6],\n            hash: result[8],\n        };\n    }\n    if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {\n        parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);\n    }\n    return {\n        hostname: !serverBase && parsedUrl.hostname || '',\n        protocol: !serverBase && parsedUrl.protocol || '',\n        port: !serverBase && parsedUrl.port || '',\n        pathname: parsedUrl.pathname || '/',\n        search: parsedUrl.search || '',\n        hash: parsedUrl.hash || '',\n    };\n}\n/**\n * Provider for mock platform location config\n *\n * @publicApi\n */\nconst MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken('MOCK_PLATFORM_LOCATION_CONFIG');\n/**\n * Mock implementation of URL state.\n *\n * @publicApi\n */\nclass MockPlatformLocation {\n    constructor(config) {\n        this.baseHref = '';\n        this.hashUpdate = new Subject();\n        this.urlChangeIndex = 0;\n        this.urlChanges = [{ hostname: '', protocol: '', port: '', pathname: '/', search: '', hash: '', state: null }];\n        if (config) {\n            this.baseHref = config.appBaseHref || '';\n            const parsedChanges = this.parseChanges(null, config.startUrl || 'http://<empty>/', this.baseHref);\n            this.urlChanges[0] = Object.assign({}, parsedChanges);\n        }\n    }\n    get hostname() {\n        return this.urlChanges[this.urlChangeIndex].hostname;\n    }\n    get protocol() {\n        return this.urlChanges[this.urlChangeIndex].protocol;\n    }\n    get port() {\n        return this.urlChanges[this.urlChangeIndex].port;\n    }\n    get pathname() {\n        return this.urlChanges[this.urlChangeIndex].pathname;\n    }\n    get search() {\n        return this.urlChanges[this.urlChangeIndex].search;\n    }\n    get hash() {\n        return this.urlChanges[this.urlChangeIndex].hash;\n    }\n    get state() {\n        return this.urlChanges[this.urlChangeIndex].state;\n    }\n    getBaseHrefFromDOM() {\n        return this.baseHref;\n    }\n    onPopState(fn) {\n        // No-op: a state stack is not implemented, so\n        // no events will ever come.\n        return () => { };\n    }\n    onHashChange(fn) {\n        const subscription = this.hashUpdate.subscribe(fn);\n        return () => subscription.unsubscribe();\n    }\n    get href() {\n        let url = `${this.protocol}//${this.hostname}${this.port ? ':' + this.port : ''}`;\n        url += `${this.pathname === '/' ? '' : this.pathname}${this.search}${this.hash}`;\n        return url;\n    }\n    get url() {\n        return `${this.pathname}${this.search}${this.hash}`;\n    }\n    parseChanges(state, url, baseHref = '') {\n        // When the `history.state` value is stored, it is always copied.\n        state = JSON.parse(JSON.stringify(state));\n        return Object.assign(Object.assign({}, parseUrl(url, baseHref)), { state });\n    }\n    replaceState(state, title, newUrl) {\n        const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);\n        this.urlChanges[this.urlChangeIndex] = Object.assign(Object.assign({}, this.urlChanges[this.urlChangeIndex]), { pathname, search, hash, state: parsedState });\n    }\n    pushState(state, title, newUrl) {\n        const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);\n        if (this.urlChangeIndex > 0) {\n            this.urlChanges.splice(this.urlChangeIndex + 1);\n        }\n        this.urlChanges.push(Object.assign(Object.assign({}, this.urlChanges[this.urlChangeIndex]), { pathname, search, hash, state: parsedState }));\n        this.urlChangeIndex = this.urlChanges.length - 1;\n    }\n    forward() {\n        const oldUrl = this.url;\n        const oldHash = this.hash;\n        if (this.urlChangeIndex < this.urlChanges.length) {\n            this.urlChangeIndex++;\n        }\n        this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n    back() {\n        const oldUrl = this.url;\n        const oldHash = this.hash;\n        if (this.urlChangeIndex > 0) {\n            this.urlChangeIndex--;\n        }\n        this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n    historyGo(relativePosition = 0) {\n        const oldUrl = this.url;\n        const oldHash = this.hash;\n        const nextPageIndex = this.urlChangeIndex + relativePosition;\n        if (nextPageIndex >= 0 && nextPageIndex < this.urlChanges.length) {\n            this.urlChangeIndex = nextPageIndex;\n        }\n        this.scheduleHashUpdate(oldHash, oldUrl);\n    }\n    getState() {\n        return this.state;\n    }\n    scheduleHashUpdate(oldHash, oldUrl) {\n        if (oldHash !== this.hash) {\n            scheduleMicroTask(() => this.hashUpdate.next({ type: 'hashchange', state: null, oldUrl, newUrl: this.url }));\n        }\n    }\n}\nMockPlatformLocation.ɵfac = function MockPlatformLocation_Factory(t) { return new (t || MockPlatformLocation)(ɵngcc0.ɵɵinject(MOCK_PLATFORM_LOCATION_CONFIG, 8)); };\nMockPlatformLocation.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MockPlatformLocation, factory: MockPlatformLocation.ɵfac });\nMockPlatformLocation.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [MOCK_PLATFORM_LOCATION_CONFIG,] }, { type: Optional }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MockPlatformLocation, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [MOCK_PLATFORM_LOCATION_CONFIG]\n            }, {\n                type: Optional\n            }] }]; }, null); })();\nfunction scheduleMicroTask(cb) {\n    Promise.resolve(null).then(cb);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MOCK_PLATFORM_LOCATION_CONFIG, MockLocationStrategy, MockPlatformLocation, SpyLocation };\n\n//# sourceMappingURL=testing.js.map"]},"metadata":{},"sourceType":"module"}
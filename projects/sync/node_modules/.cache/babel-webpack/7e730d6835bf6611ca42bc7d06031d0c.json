{"ast":null,"code":"'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\n\nvar _construct = require(\"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/construct\").default;\n\nvar _toConsumableArray = require(\"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/toConsumableArray\").default;\n\nvar _createClass = require(\"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/createClass\").default;\n\nvar _classCallCheck = require(\"C:/Totvs/po-angular/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/classCallCheck\").default;\n\nvar NEWLINE = '\\n';\nvar IGNORE_FRAMES = {};\nvar creationTrace = '__creationTrace__';\nvar ERROR_TAG = 'STACKTRACE TRACKING';\nvar SEP_TAG = '__SEP_TAG__';\nvar sepTemplate = SEP_TAG + '@[native]';\n\nvar LongStackTrace = function LongStackTrace() {\n  _classCallCheck(this, LongStackTrace);\n\n  this.error = getStacktrace();\n  this.timestamp = new Date();\n};\n\nfunction getStacktraceWithUncaughtError() {\n  return new Error(ERROR_TAG);\n}\n\nfunction getStacktraceWithCaughtError() {\n  try {\n    throw getStacktraceWithUncaughtError();\n  } catch (err) {\n    return err;\n  }\n} // Some implementations of exception handling don't create a stack trace if the exception\n// isn't thrown, however it's faster not to actually throw the exception.\n\n\nvar error = getStacktraceWithUncaughtError();\nvar caughtError = getStacktraceWithCaughtError();\nvar getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;\n\nfunction getFrames(error) {\n  return error.stack ? error.stack.split(NEWLINE) : [];\n}\n\nfunction addErrorStack(lines, error) {\n  var trace = getFrames(error);\n\n  for (var i = 0; i < trace.length; i++) {\n    var frame = trace[i]; // Filter out the Frames which are part of stack capturing.\n\n    if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n      lines.push(trace[i]);\n    }\n  }\n}\n\nfunction renderLongStackTrace(frames, stack) {\n  var longTrace = [stack ? stack.trim() : ''];\n\n  if (frames) {\n    var timestamp = new Date().getTime();\n\n    for (var i = 0; i < frames.length; i++) {\n      var traceFrames = frames[i];\n      var lastTime = traceFrames.timestamp;\n      var separator = \"____________________Elapsed \".concat(timestamp - lastTime.getTime(), \" ms; At: \").concat(lastTime);\n      separator = separator.replace(/[^\\w\\d]/g, '_');\n      longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n      addErrorStack(longTrace, traceFrames.error);\n      timestamp = lastTime.getTime();\n    }\n  }\n\n  return longTrace.join(NEWLINE);\n} // if Error.stackTraceLimit is 0, means stack trace\n// is disabled, so we don't need to generate long stack trace\n// this will improve performance in some test(some test will\n// set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\n\n\nfunction stackTracesEnabled() {\n  // Cast through any since this property only exists on Error in the nodejs\n  // typings.\n  return Error.stackTraceLimit > 0;\n}\n\nZone['longStackTraceZoneSpec'] = {\n  name: 'long-stack-trace',\n  longStackTraceLimit: 10,\n  // add a getLongStackTrace method in spec to\n  // handle handled reject promise error.\n  getLongStackTrace: function getLongStackTrace(error) {\n    if (!error) {\n      return undefined;\n    }\n\n    var trace = error[Zone.__symbol__('currentTaskTrace')];\n\n    if (!trace) {\n      return error.stack;\n    }\n\n    return renderLongStackTrace(trace, error.stack);\n  },\n  onScheduleTask: function onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n    if (stackTracesEnabled()) {\n      var currentTask = Zone.currentTask;\n      var trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n      trace = [new LongStackTrace()].concat(trace);\n\n      if (trace.length > this.longStackTraceLimit) {\n        trace.length = this.longStackTraceLimit;\n      }\n\n      if (!task.data) task.data = {};\n\n      if (task.type === 'eventTask') {\n        // Fix issue https://github.com/angular/zone.js/issues/1195,\n        // For event task of browser, by default, all task will share a\n        // singleton instance of data object, we should create a new one here\n        // The cast to `any` is required to workaround a closure bug which wrongly applies\n        // URL sanitization rules to .data access.\n        task.data = Object.assign({}, task.data);\n      }\n\n      task.data[creationTrace] = trace;\n    }\n\n    return parentZoneDelegate.scheduleTask(targetZone, task);\n  },\n  onHandleError: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n    if (stackTracesEnabled()) {\n      var parentTask = Zone.currentTask || error.task;\n\n      if (error instanceof Error && parentTask) {\n        var longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n\n        try {\n          error.stack = error.longStack = longStack;\n        } catch (err) {}\n      }\n    }\n\n    return parentZoneDelegate.handleError(targetZone, error);\n  }\n};\n\nfunction captureStackTraces(stackTraces, count) {\n  if (count > 0) {\n    stackTraces.push(getFrames(new LongStackTrace().error));\n    captureStackTraces(stackTraces, count - 1);\n  }\n}\n\nfunction computeIgnoreFrames() {\n  if (!stackTracesEnabled()) {\n    return;\n  }\n\n  var frames = [];\n  captureStackTraces(frames, 2);\n  var frames1 = frames[0];\n  var frames2 = frames[1];\n\n  for (var i = 0; i < frames1.length; i++) {\n    var frame1 = frames1[i];\n\n    if (frame1.indexOf(ERROR_TAG) == -1) {\n      var match = frame1.match(/^\\s*at\\s+/);\n\n      if (match) {\n        sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n        break;\n      }\n    }\n  }\n\n  for (var _i = 0; _i < frames1.length; _i++) {\n    var _frame = frames1[_i];\n    var frame2 = frames2[_i];\n\n    if (_frame === frame2) {\n      IGNORE_FRAMES[_frame] = true;\n    } else {\n      break;\n    }\n  }\n}\n\ncomputeIgnoreFrames();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ProxyZoneSpec = /*#__PURE__*/function () {\n  function ProxyZoneSpec() {\n    var defaultSpecDelegate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, ProxyZoneSpec);\n\n    this.defaultSpecDelegate = defaultSpecDelegate;\n    this.name = 'ProxyZone';\n    this._delegateSpec = null;\n    this.properties = {\n      'ProxyZoneSpec': this\n    };\n    this.propertyKeys = null;\n    this.lastTaskState = null;\n    this.isNeedToTriggerHasTask = false;\n    this.tasks = [];\n    this.setDelegate(defaultSpecDelegate);\n  }\n\n  _createClass(ProxyZoneSpec, [{\n    key: \"setDelegate\",\n    value: function setDelegate(delegateSpec) {\n      var _this = this;\n\n      var isNewDelegate = this._delegateSpec !== delegateSpec;\n      this._delegateSpec = delegateSpec;\n      this.propertyKeys && this.propertyKeys.forEach(function (key) {\n        return delete _this.properties[key];\n      });\n      this.propertyKeys = null;\n\n      if (delegateSpec && delegateSpec.properties) {\n        this.propertyKeys = Object.keys(delegateSpec.properties);\n        this.propertyKeys.forEach(function (k) {\n          return _this.properties[k] = delegateSpec.properties[k];\n        });\n      } // if a new delegateSpec was set, check if we need to trigger hasTask\n\n\n      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n        this.isNeedToTriggerHasTask = true;\n      }\n    }\n  }, {\n    key: \"getDelegate\",\n    value: function getDelegate() {\n      return this._delegateSpec;\n    }\n  }, {\n    key: \"resetDelegate\",\n    value: function resetDelegate() {\n      var delegateSpec = this.getDelegate();\n      this.setDelegate(this.defaultSpecDelegate);\n    }\n  }, {\n    key: \"tryTriggerHasTask\",\n    value: function tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n      if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n        // last delegateSpec has microTask or macroTask\n        // should call onHasTask in current delegateSpec\n        this.isNeedToTriggerHasTask = false;\n        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n      }\n    }\n  }, {\n    key: \"removeFromTasks\",\n    value: function removeFromTasks(task) {\n      if (!this.tasks) {\n        return;\n      }\n\n      for (var i = 0; i < this.tasks.length; i++) {\n        if (this.tasks[i] === task) {\n          this.tasks.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"getAndClearPendingTasksInfo\",\n    value: function getAndClearPendingTasksInfo() {\n      if (this.tasks.length === 0) {\n        return '';\n      }\n\n      var taskInfo = this.tasks.map(function (task) {\n        var dataInfo = task.data && Object.keys(task.data).map(function (key) {\n          return key + ':' + task.data[key];\n        }).join(',');\n        return \"type: \".concat(task.type, \", source: \").concat(task.source, \", args: {\").concat(dataInfo, \"}\");\n      });\n      var pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']'; // clear tasks\n\n      this.tasks = [];\n      return pendingTasksInfo;\n    }\n  }, {\n    key: \"onFork\",\n    value: function onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n      if (this._delegateSpec && this._delegateSpec.onFork) {\n        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n      } else {\n        return parentZoneDelegate.fork(targetZone, zoneSpec);\n      }\n    }\n  }, {\n    key: \"onIntercept\",\n    value: function onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n      if (this._delegateSpec && this._delegateSpec.onIntercept) {\n        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n      } else {\n        return parentZoneDelegate.intercept(targetZone, delegate, source);\n      }\n    }\n  }, {\n    key: \"onInvoke\",\n    value: function onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvoke) {\n        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n      } else {\n        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n      }\n    }\n  }, {\n    key: \"onHandleError\",\n    value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n      if (this._delegateSpec && this._delegateSpec.onHandleError) {\n        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n      } else {\n        return parentZoneDelegate.handleError(targetZone, error);\n      }\n    }\n  }, {\n    key: \"onScheduleTask\",\n    value: function onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.tasks.push(task);\n      }\n\n      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n      }\n    }\n  }, {\n    key: \"onInvokeTask\",\n    value: function onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n      } else {\n        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      }\n    }\n  }, {\n    key: \"onCancelTask\",\n    value: function onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n      if (task.type !== 'eventTask') {\n        this.removeFromTasks(task);\n      }\n\n      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n\n      if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n      } else {\n        return parentZoneDelegate.cancelTask(targetZone, task);\n      }\n    }\n  }, {\n    key: \"onHasTask\",\n    value: function onHasTask(delegate, current, target, hasTaskState) {\n      this.lastTaskState = hasTaskState;\n\n      if (this._delegateSpec && this._delegateSpec.onHasTask) {\n        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n      } else {\n        delegate.hasTask(target, hasTaskState);\n      }\n    }\n  }], [{\n    key: \"get\",\n    value: function get() {\n      return Zone.current.get('ProxyZoneSpec');\n    }\n  }, {\n    key: \"isLoaded\",\n    value: function isLoaded() {\n      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    }\n  }, {\n    key: \"assertPresent\",\n    value: function assertPresent() {\n      if (!ProxyZoneSpec.isLoaded()) {\n        throw new Error(\"Expected to be running in 'ProxyZone', but it was not found.\");\n      }\n\n      return ProxyZoneSpec.get();\n    }\n  }]);\n\n  return ProxyZoneSpec;\n}(); // Export the class so that new instances can be created with proper\n// constructor params.\n\n\nZone['ProxyZoneSpec'] = ProxyZoneSpec;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar SyncTestZoneSpec = /*#__PURE__*/function () {\n  function SyncTestZoneSpec(namePrefix) {\n    _classCallCheck(this, SyncTestZoneSpec);\n\n    this.runZone = Zone.current;\n    this.name = 'syncTestZone for ' + namePrefix;\n  }\n\n  _createClass(SyncTestZoneSpec, [{\n    key: \"onScheduleTask\",\n    value: function onScheduleTask(delegate, current, target, task) {\n      switch (task.type) {\n        case 'microTask':\n        case 'macroTask':\n          throw new Error(\"Cannot call \".concat(task.source, \" from within a sync test.\"));\n\n        case 'eventTask':\n          task = delegate.scheduleTask(target, task);\n          break;\n      }\n\n      return task;\n    }\n  }]);\n\n  return SyncTestZoneSpec;\n}(); // Export the class so that new instances can be created with proper\n// constructor params.\n\n\nZone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nZone.__load_patch('jasmine', function (global, Zone, api) {\n  var __extends = function __extends(d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n  // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n  if (!Zone) throw new Error('Missing: zone.js');\n\n  if (typeof jest !== 'undefined') {\n    // return if jasmine is a light implementation inside jest\n    // in this case, we are running inside jest not jasmine\n    return;\n  }\n\n  if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n    return;\n  }\n\n  jasmine['__zone_patch__'] = true;\n  var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n  var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n  if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n  var ambientZone = Zone.current; // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n  // error if any asynchronous operations are attempted inside of a `describe` but outside of\n  // a `beforeEach` or `it`.\n\n  var syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n  var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n  var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n  // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n  // automatically disable the auto jump into fakeAsync feature\n\n  var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n  var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n  if (!ignoreUnhandledRejection) {\n    var globalErrors = jasmine.GlobalErrors;\n\n    if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n      jasmine[symbol('GlobalErrors')] = globalErrors;\n\n      jasmine.GlobalErrors = function () {\n        var instance = new globalErrors();\n        var originalInstall = instance.install;\n\n        if (originalInstall && !instance[symbol('install')]) {\n          instance[symbol('install')] = originalInstall;\n\n          instance.install = function () {\n            var originalHandlers = process.listeners('unhandledRejection');\n            var r = originalInstall.apply(this, arguments);\n            process.removeAllListeners('unhandledRejection');\n\n            if (originalHandlers) {\n              originalHandlers.forEach(function (h) {\n                return process.on('unhandledRejection', h);\n              });\n            }\n\n            return r;\n          };\n        }\n\n        return instance;\n      };\n    }\n  } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n  var jasmineEnv = jasmine.getEnv();\n  ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n    var originalJasmineFn = jasmineEnv[methodName];\n\n    jasmineEnv[methodName] = function (description, specDefinitions) {\n      return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n    };\n  });\n  ['it', 'xit', 'fit'].forEach(function (methodName) {\n    var originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n    jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n      arguments[1] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n    var originalJasmineFn = jasmineEnv[methodName];\n    jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n    jasmineEnv[methodName] = function (specDefinitions, timeout) {\n      arguments[0] = wrapTestInZone(specDefinitions);\n      return originalJasmineFn.apply(this, arguments);\n    };\n  });\n\n  if (!disablePatchingJasmineClock) {\n    // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n    // they can work properly in FakeAsyncTest\n    var originalClockFn = jasmine[symbol('clock')] = jasmine['clock'];\n\n    jasmine['clock'] = function () {\n      var clock = originalClockFn.apply(this, arguments);\n\n      if (!clock[symbol('patched')]) {\n        clock[symbol('patched')] = symbol('patched');\n        var originalTick = clock[symbol('tick')] = clock.tick;\n\n        clock.tick = function () {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n          }\n\n          return originalTick.apply(this, arguments);\n        };\n\n        var originalMockDate = clock[symbol('mockDate')] = clock.mockDate;\n\n        clock.mockDate = function () {\n          var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n          if (fakeAsyncZoneSpec) {\n            var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n          }\n\n          return originalMockDate.apply(this, arguments);\n        }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n        if (enableAutoFakeAsyncWhenClockPatched) {\n          ['install', 'uninstall'].forEach(function (methodName) {\n            var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n            clock[methodName] = function () {\n              var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n              if (FakeAsyncTestZoneSpec) {\n                jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                return;\n              }\n\n              return originalClockFn.apply(this, arguments);\n            };\n          });\n        }\n      }\n\n      return clock;\n    };\n  } // monkey patch createSpyObj to make properties enumerable to true\n\n\n  if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n    var originalCreateSpyObj = jasmine.createSpyObj;\n    jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n\n    jasmine.createSpyObj = function () {\n      var args = Array.prototype.slice.call(arguments);\n      var propertyNames = args.length >= 3 ? args[2] : null;\n      var spyObj;\n\n      if (propertyNames) {\n        var defineProperty = Object.defineProperty;\n\n        Object.defineProperty = function (obj, p, attributes) {\n          return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n            configurable: true,\n            enumerable: true\n          }));\n        };\n\n        try {\n          spyObj = originalCreateSpyObj.apply(this, args);\n        } finally {\n          Object.defineProperty = defineProperty;\n        }\n      } else {\n        spyObj = originalCreateSpyObj.apply(this, args);\n      }\n\n      return spyObj;\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n   * synchronous-only zone.\n   */\n\n\n  function wrapDescribeInZone(describeBody) {\n    return function () {\n      return syncZone.run(describeBody, this, arguments);\n    };\n  }\n\n  function runInTestZone(testBody, applyThis, queueRunner, done) {\n    var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n    var testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n    var testProxyZone = queueRunner.testProxyZone;\n\n    if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n      // auto run a fakeAsync\n      var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n      if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n        testBody = fakeAsyncModule.fakeAsync(testBody);\n      }\n    }\n\n    if (done) {\n      return testProxyZone.run(testBody, applyThis, [done]);\n    } else {\n      return testProxyZone.run(testBody, applyThis);\n    }\n  }\n  /**\n   * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n   */\n\n\n  function wrapTestInZone(testBody) {\n    // The `done` callback is only passed through if the function expects at least one argument.\n    // Note we have to make a function with correct number of arguments, otherwise jasmine will\n    // think that all functions are sync or async.\n    return testBody && (testBody.length ? function (done) {\n      return runInTestZone(testBody, this, this.queueRunner, done);\n    } : function () {\n      return runInTestZone(testBody, this, this.queueRunner);\n    });\n  }\n\n  var QueueRunner = jasmine.QueueRunner;\n\n  jasmine.QueueRunner = function (_super) {\n    __extends(ZoneQueueRunner, _super);\n\n    function ZoneQueueRunner(attrs) {\n      var _this2 = this;\n\n      if (attrs.onComplete) {\n        attrs.onComplete = function (fn) {\n          return function () {\n            // All functions are done, clear the test zone.\n            _this2.testProxyZone = null;\n            _this2.testProxyZoneSpec = null;\n            ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n          };\n        }(attrs.onComplete);\n      }\n\n      var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n      var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n      if (nativeSetTimeout) {\n        // should run setTimeout inside jasmine outside of zone\n        attrs.timeout = {\n          setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n          clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n        };\n      } // create a userContext to hold the queueRunner itself\n      // so we can access the testProxy in it/xit/beforeEach ...\n\n\n      if (jasmine.UserContext) {\n        if (!attrs.userContext) {\n          attrs.userContext = new jasmine.UserContext();\n        }\n\n        attrs.userContext.queueRunner = this;\n      } else {\n        if (!attrs.userContext) {\n          attrs.userContext = {};\n        }\n\n        attrs.userContext.queueRunner = this;\n      } // patch attrs.onException\n\n\n      var onException = attrs.onException;\n\n      attrs.onException = function (error) {\n        if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n          // jasmine timeout, we can make the error message more\n          // reasonable to tell what tasks are pending\n          var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n          if (proxyZoneSpec) {\n            var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n            try {\n              // try catch here in case error.message is not writable\n              error.message += pendingTasksInfo;\n            } catch (err) {}\n          }\n        }\n\n        if (onException) {\n          onException.call(this, error);\n        }\n      };\n\n      _super.call(this, attrs);\n    }\n\n    ZoneQueueRunner.prototype.execute = function () {\n      var _this3 = this;\n\n      var zone = Zone.current;\n      var isChildOfAmbientZone = false;\n\n      while (zone) {\n        if (zone === ambientZone) {\n          isChildOfAmbientZone = true;\n          break;\n        }\n\n        zone = zone.parent;\n      }\n\n      if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n      // It will be a proxy zone, so that the tests function can retroactively install\n      // different zones.\n      // Example:\n      //   - In beforeEach() do childZone = Zone.current.fork(...);\n      //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n      //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n      //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n      //     fakeAsync behavior to the childZone.\n\n      this.testProxyZoneSpec = new ProxyZoneSpec();\n      this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n      if (!Zone.currentTask) {\n        // if we are not running in a task then if someone would register a\n        // element.addEventListener and then calling element.click() the\n        // addEventListener callback would think that it is the top most task and would\n        // drain the microtask queue on element.click() which would be incorrect.\n        // For this reason we always force a task when running jasmine tests.\n        Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n          return QueueRunner.prototype.execute.call(_this3);\n        });\n      } else {\n        _super.prototype.execute.call(this);\n      }\n    };\n\n    return ZoneQueueRunner;\n  }(QueueRunner);\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('jest', function (context, Zone, api) {\n  if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n    return;\n  }\n\n  jest['__zone_patch__'] = true;\n  var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n\n  var rootZone = Zone.current;\n  var syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n  var proxyZoneSpec = new ProxyZoneSpec();\n  var proxyZone = rootZone.fork(proxyZoneSpec);\n\n  function wrapDescribeFactoryInZone(originalJestFn) {\n    return function () {\n      for (var _len = arguments.length, tableArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n        tableArgs[_key] = arguments[_key];\n      }\n\n      var originalDescribeFn = originalJestFn.apply(this, tableArgs);\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        args[1] = wrapDescribeInZone(args[1]);\n        return originalDescribeFn.apply(this, args);\n      };\n    };\n  }\n\n  function wrapTestFactoryInZone(originalJestFn) {\n    return function () {\n      for (var _len3 = arguments.length, tableArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        tableArgs[_key3] = arguments[_key3];\n      }\n\n      return function () {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        args[1] = wrapTestInZone(args[1]);\n        return originalJestFn.apply(this, tableArgs).apply(this, args);\n      };\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `describe` block to execute in a\n   * synchronous-only zone.\n   */\n\n\n  function wrapDescribeInZone(describeBody) {\n    return function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return syncZone.run(describeBody, this, args);\n    };\n  }\n  /**\n   * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n   * execute in a ProxyZone zone.\n   * This will run in the `proxyZone`.\n   */\n\n\n  function wrapTestInZone(testBody) {\n    var isTestFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (typeof testBody !== 'function') {\n      return testBody;\n    }\n\n    var wrappedFunc = function wrappedFunc() {\n      if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody && !testBody.isFakeAsync) {\n        // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      proxyZoneSpec.isTestFunc = isTestFunc;\n      return proxyZone.run(testBody, null, arguments);\n    }; // Update the length of wrappedFunc to be the same as the length of the testBody\n    // So jest core can handle whether the test function has `done()` or not correctly\n\n\n    Object.defineProperty(wrappedFunc, 'length', {\n      configurable: true,\n      writable: true,\n      enumerable: false\n    });\n    wrappedFunc.length = testBody.length;\n    return wrappedFunc;\n  }\n\n  ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n    var originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      args[1] = wrapDescribeInZone(args[1]);\n      return originalJestFn.apply(this, args);\n    };\n\n    context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n  });\n  context.describe.only = context.fdescribe;\n  context.describe.skip = context.xdescribe;\n  ['it', 'xit', 'fit', 'test', 'xtest'].forEach(function (methodName) {\n    var originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      args[1] = wrapTestInZone(args[1], true);\n      return originalJestFn.apply(this, args);\n    };\n\n    context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n    context[methodName].todo = originalJestFn.todo;\n  });\n  context.it.only = context.fit;\n  context.it.skip = context.xit;\n  context.test.only = context.fit;\n  context.test.skip = context.xit;\n  ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n    var originalJestFn = context[methodName];\n\n    if (context[Zone.__symbol__(methodName)]) {\n      return;\n    }\n\n    context[Zone.__symbol__(methodName)] = originalJestFn;\n\n    context[methodName] = function () {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      args[0] = wrapTestInZone(args[0]);\n      return originalJestFn.apply(this, args);\n    };\n  });\n\n  Zone.patchJestObject = function patchJestObject(Timer) {\n    var isModern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // check whether currently the test is inside fakeAsync()\n    function isPatchingFakeTimer() {\n      var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n      return !!fakeAsyncZoneSpec;\n    } // check whether the current function is inside `test/it` or other methods\n    // such as `describe/beforeEach`\n\n\n    function isInTestFunc() {\n      var proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n      return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n    }\n\n    if (Timer[api.symbol('fakeTimers')]) {\n      return;\n    }\n\n    Timer[api.symbol('fakeTimers')] = true; // patch jest fakeTimer internal method to make sure no console.warn print out\n\n    api.patchMethod(Timer, '_checkFakeTimers', function (delegate) {\n      return function (self, args) {\n        if (isPatchingFakeTimer()) {\n          return true;\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n\n    api.patchMethod(Timer, 'useFakeTimers', function (delegate) {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = true;\n\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n\n        return self;\n      };\n    }); // patch useRealTimers(), unset useFakeTimers flag\n\n    api.patchMethod(Timer, 'useRealTimers', function (delegate) {\n      return function (self, args) {\n        Zone[api.symbol('useFakeTimersCalled')] = false;\n\n        if (isModern || isInTestFunc()) {\n          return delegate.apply(self, args);\n        }\n\n        return self;\n      };\n    }); // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'setSystemTime', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'getRealSystemTime', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n          return fakeAsyncZoneSpec.getRealSystemTime();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runAllTicks(), run all microTasks inside fakeAsync\n\n    api.patchMethod(Timer, 'runAllTicks', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushMicrotasks();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runAllTimers(), run all macroTasks inside fakeAsync\n\n    api.patchMethod(Timer, 'runAllTimers', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flush(100, true);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'advanceTimersByTime', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tick(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'runOnlyPendingTimers', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.flushOnlyPendingTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'advanceTimersToNextTimer', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.tickToNext(args[0]);\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'clearAllTimers', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          fakeAsyncZoneSpec.removeAllTimers();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    }); // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n\n    api.patchMethod(Timer, 'getTimerCount', function (delegate) {\n      return function (self, args) {\n        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (fakeAsyncZoneSpec) {\n          return fakeAsyncZoneSpec.getTimerCount();\n        } else {\n          return delegate.apply(self, args);\n        }\n      };\n    });\n  };\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('mocha', function (global, Zone) {\n  var Mocha = global.Mocha;\n\n  if (typeof Mocha === 'undefined') {\n    // return if Mocha is not available, because now zone-testing\n    // will load mocha patch with jasmine/jest patch\n    return;\n  }\n\n  if (typeof Zone === 'undefined') {\n    throw new Error('Missing Zone.js');\n  }\n\n  var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n  var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n\n  if (!ProxyZoneSpec) {\n    throw new Error('Missing ProxyZoneSpec');\n  }\n\n  if (Mocha['__zone_patch__']) {\n    throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n  }\n\n  Mocha['__zone_patch__'] = true;\n  var rootZone = Zone.current;\n  var syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n  var testZone = null;\n  var suiteZone = rootZone.fork(new ProxyZoneSpec());\n  var mochaOriginal = {\n    after: Mocha.after,\n    afterEach: Mocha.afterEach,\n    before: Mocha.before,\n    beforeEach: Mocha.beforeEach,\n    describe: Mocha.describe,\n    it: Mocha.it\n  };\n\n  function modifyArguments(args, syncTest, asyncTest) {\n    var _loop = function _loop(i) {\n      var arg = args[i];\n\n      if (typeof arg === 'function') {\n        // The `done` callback is only passed through if the function expects at\n        // least one argument.\n        // Note we have to make a function with correct number of arguments,\n        // otherwise mocha will\n        // think that all functions are sync or async.\n        args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg); // Mocha uses toString to view the test body in the result list, make sure we return the\n        // correct function body\n\n        args[i].toString = function () {\n          return arg.toString();\n        };\n      }\n    };\n\n    for (var i = 0; i < args.length; i++) {\n      _loop(i);\n    }\n\n    return args;\n  }\n\n  function wrapDescribeInZone(args) {\n    var syncTest = function syncTest(fn) {\n      return function () {\n        return syncZone.run(fn, this, arguments);\n      };\n    };\n\n    return modifyArguments(args, syncTest);\n  }\n\n  function wrapTestInZone(args) {\n    var asyncTest = function asyncTest(fn) {\n      return function (done) {\n        return testZone.run(fn, this, [done]);\n      };\n    };\n\n    var syncTest = function syncTest(fn) {\n      return function () {\n        return testZone.run(fn, this);\n      };\n    };\n\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n\n  function wrapSuiteInZone(args) {\n    var asyncTest = function asyncTest(fn) {\n      return function (done) {\n        return suiteZone.run(fn, this, [done]);\n      };\n    };\n\n    var syncTest = function syncTest(fn) {\n      return function () {\n        return suiteZone.run(fn, this);\n      };\n    };\n\n    return modifyArguments(args, syncTest, asyncTest);\n  }\n\n  global.describe = global.suite = Mocha.describe = function () {\n    return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n    return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.describe.only = global.suite.only = Mocha.describe.only = function () {\n    return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n  };\n\n  global.it = global.specify = global.test = Mocha.it = function () {\n    return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.xit = global.xspecify = Mocha.it.skip = function () {\n    return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.it.only = global.test.only = Mocha.it.only = function () {\n    return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.after = global.suiteTeardown = Mocha.after = function () {\n    return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n  };\n\n  global.afterEach = global.teardown = Mocha.afterEach = function () {\n    return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n  };\n\n  global.before = global.suiteSetup = Mocha.before = function () {\n    return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n  };\n\n  global.beforeEach = global.setup = Mocha.beforeEach = function () {\n    return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n  };\n\n  (function (originalRunTest, originalRun) {\n    Mocha.Runner.prototype.runTest = function (fn) {\n      var _this4 = this;\n\n      Zone.current.scheduleMicroTask('mocha.forceTask', function () {\n        originalRunTest.call(_this4, fn);\n      });\n    };\n\n    Mocha.Runner.prototype.run = function (fn) {\n      this.on('test', function (e) {\n        testZone = rootZone.fork(new ProxyZoneSpec());\n      });\n      this.on('fail', function (test, err) {\n        var proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n\n        if (proxyZoneSpec && err) {\n          try {\n            // try catch here in case err.message is not writable\n            err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n          } catch (error) {}\n        }\n      });\n      return originalRun.call(this, fn);\n    };\n  })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (_global) {\n  var AsyncTestZoneSpec = /*#__PURE__*/function () {\n    function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n      _classCallCheck(this, AsyncTestZoneSpec);\n\n      this.finishCallback = finishCallback;\n      this.failCallback = failCallback;\n      this._pendingMicroTasks = false;\n      this._pendingMacroTasks = false;\n      this._alreadyErrored = false;\n      this._isSync = false;\n      this.runZone = Zone.current;\n      this.unresolvedChainedPromiseCount = 0;\n      this.supportWaitUnresolvedChainedPromise = false;\n      this.name = 'asyncTestZone for ' + namePrefix;\n      this.properties = {\n        'AsyncTestZoneSpec': this\n      };\n      this.supportWaitUnresolvedChainedPromise = _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n    }\n\n    _createClass(AsyncTestZoneSpec, [{\n      key: \"isUnresolvedChainedPromisePending\",\n      value: function isUnresolvedChainedPromisePending() {\n        return this.unresolvedChainedPromiseCount > 0;\n      }\n    }, {\n      key: \"_finishCallbackIfDone\",\n      value: function _finishCallbackIfDone() {\n        var _this5 = this;\n\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {\n          // We do this because we would like to catch unhandled rejected promises.\n          this.runZone.run(function () {\n            setTimeout(function () {\n              if (!_this5._alreadyErrored && !(_this5._pendingMicroTasks || _this5._pendingMacroTasks)) {\n                _this5.finishCallback();\n              }\n            }, 0);\n          });\n        }\n      }\n    }, {\n      key: \"patchPromiseForTest\",\n      value: function patchPromiseForTest() {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n\n        if (patchPromiseForTest) {\n          patchPromiseForTest();\n        }\n      }\n    }, {\n      key: \"unPatchPromiseForTest\",\n      value: function unPatchPromiseForTest() {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n          return;\n        }\n\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n\n        if (unPatchPromiseForTest) {\n          unPatchPromiseForTest();\n        }\n      }\n    }, {\n      key: \"onScheduleTask\",\n      value: function onScheduleTask(delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n          // check whether the promise is a chained promise\n          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n            // chained promise is being scheduled\n            this.unresolvedChainedPromiseCount--;\n          }\n        }\n\n        return delegate.scheduleTask(target, task);\n      }\n    }, {\n      key: \"onInvokeTask\",\n      value: function onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      }\n    }, {\n      key: \"onCancelTask\",\n      value: function onCancelTask(delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n          this._isSync = false;\n        }\n\n        return delegate.cancelTask(target, task);\n      } // Note - we need to use onInvoke at the moment to call finish when a test is\n      // fully synchronous. TODO(juliemr): remove this when the logic for\n      // onHasTask changes and it calls whenever the task queues are dirty.\n      // updated by(JiaLiPassion), only call finish callback when no task\n      // was scheduled/invoked/canceled.\n\n    }, {\n      key: \"onInvoke\",\n      value: function onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        try {\n          this._isSync = true;\n          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        } finally {\n          var afterTaskCounts = parentZoneDelegate._taskCounts;\n\n          if (this._isSync) {\n            this._finishCallbackIfDone();\n          }\n        }\n      }\n    }, {\n      key: \"onHandleError\",\n      value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n\n        if (result) {\n          this.failCallback(error);\n          this._alreadyErrored = true;\n        }\n\n        return false;\n      }\n    }, {\n      key: \"onHasTask\",\n      value: function onHasTask(delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState);\n\n        if (hasTaskState.change == 'microTask') {\n          this._pendingMicroTasks = hasTaskState.microTask;\n\n          this._finishCallbackIfDone();\n        } else if (hasTaskState.change == 'macroTask') {\n          this._pendingMacroTasks = hasTaskState.macroTask;\n\n          this._finishCallbackIfDone();\n        }\n      }\n    }]);\n\n    return AsyncTestZoneSpec;\n  }();\n\n  AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved'); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n  Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\nZone.__load_patch('asynctest', function (global, Zone, api) {\n  /**\n   * Wraps a test function in an asynchronous test zone. The test will automatically\n   * complete when all asynchronous calls within this zone are done.\n   */\n  Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\n    // function when asynchronous activity is finished.\n    if (global.jasmine) {\n      // Not using an arrow function to preserve context passed from call site\n      return function (done) {\n        if (!done) {\n          // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n          // fake it here and assume sync.\n          done = function done() {};\n\n          done.fail = function (e) {\n            throw e;\n          };\n        }\n\n        runInTestZone(fn, this, done, function (err) {\n          if (typeof err === 'string') {\n            return done.fail(new Error(err));\n          } else {\n            done.fail(err);\n          }\n        });\n      };\n    } // Otherwise, return a promise which will resolve when asynchronous activity\n    // is finished. This will be correctly consumed by the Mocha framework with\n    // it('...', async(myFn)); or can be used in a custom framework.\n    // Not using an arrow function to preserve context passed from call site\n\n\n    return function () {\n      var _this6 = this;\n\n      return new Promise(function (finishCallback, failCallback) {\n        runInTestZone(fn, _this6, finishCallback, failCallback);\n      });\n    };\n  };\n\n  function runInTestZone(fn, context, finishCallback, failCallback) {\n    var currentZone = Zone.current;\n    var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n\n    if (AsyncTestZoneSpec === undefined) {\n      throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/async-test.js');\n    }\n\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n\n    if (!ProxyZoneSpec) {\n      throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n    }\n\n    var proxyZoneSpec = ProxyZoneSpec.get();\n    ProxyZoneSpec.assertPresent(); // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n    // If we do it in ProxyZone then we will get to infinite recursion.\n\n    var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n    var previousDelegate = proxyZoneSpec.getDelegate();\n    proxyZone.parent.run(function () {\n      var testZoneSpec = new AsyncTestZoneSpec(function () {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's\n          // sill this one. Otherwise, assume\n          // it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(function () {\n          finishCallback();\n        });\n      }, function (error) {\n        // Need to restore the original zone.\n        if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n          // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n          proxyZoneSpec.setDelegate(previousDelegate);\n        }\n\n        testZoneSpec.unPatchPromiseForTest();\n        currentZone.run(function () {\n          failCallback(error);\n        });\n      }, 'test');\n      proxyZoneSpec.setDelegate(testZoneSpec);\n      testZoneSpec.patchPromiseForTest();\n    });\n    return Zone.current.runGuarded(fn, context);\n  }\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (global) {\n  var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n  // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n  // there will be an error which is `Cannot assign to read only property 'prototype'`\n  // so we need to use function implementation here.\n\n  function FakeDate() {\n    if (arguments.length === 0) {\n      var d = new OriginalDate();\n      d.setTime(FakeDate.now());\n      return d;\n    } else {\n      var args = Array.prototype.slice.call(arguments);\n      return _construct(OriginalDate, _toConsumableArray(args));\n    }\n  }\n\n  FakeDate.now = function () {\n    var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n    if (fakeAsyncTestZoneSpec) {\n      return fakeAsyncTestZoneSpec.getFakeSystemTime();\n    }\n\n    return OriginalDate.now.apply(this, arguments);\n  };\n\n  FakeDate.UTC = OriginalDate.UTC;\n  FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n  var timers = {\n    setTimeout: global.setTimeout,\n    setInterval: global.setInterval,\n    clearTimeout: global.clearTimeout,\n    clearInterval: global.clearInterval\n  };\n\n  var Scheduler = /*#__PURE__*/function () {\n    function Scheduler() {\n      _classCallCheck(this, Scheduler);\n\n      // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n      this._schedulerQueue = []; // Current simulated time in millis.\n\n      this._currentTickTime = 0; // Current fake system base time in millis.\n\n      this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n      this._currentTickRequeuePeriodicEntries = [];\n    }\n\n    _createClass(Scheduler, [{\n      key: \"getCurrentTickTime\",\n      value: function getCurrentTickTime() {\n        return this._currentTickTime;\n      }\n    }, {\n      key: \"getFakeSystemTime\",\n      value: function getFakeSystemTime() {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      }\n    }, {\n      key: \"setFakeBaseSystemTime\",\n      value: function setFakeBaseSystemTime(fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      }\n    }, {\n      key: \"getRealSystemTime\",\n      value: function getRealSystemTime() {\n        return OriginalDate.now();\n      }\n    }, {\n      key: \"scheduleFunction\",\n      value: function scheduleFunction(cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      }\n    }, {\n      key: \"removeScheduledFunctionWithId\",\n      value: function removeScheduledFunctionWithId(id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      }\n    }, {\n      key: \"removeAll\",\n      value: function removeAll() {\n        this._schedulerQueue = [];\n      }\n    }, {\n      key: \"getTimerCount\",\n      value: function getTimerCount() {\n        return this._schedulerQueue.length;\n      }\n    }, {\n      key: \"tickToNext\",\n      value: function tickToNext() {\n        var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var doTick = arguments.length > 1 ? arguments[1] : undefined;\n        var tickOptions = arguments.length > 2 ? arguments[2] : undefined;\n\n        if (this._schedulerQueue.length < step) {\n          return;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      }\n    }, {\n      key: \"tick\",\n      value: function tick() {\n        var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var doTick = arguments.length > 1 ? arguments[1] : undefined;\n        var tickOptions = arguments.length > 2 ? arguments[2] : undefined;\n        var finalTime = this._currentTickTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var _current = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(_current);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = _current.endTime;\n\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n\n            var retval = _current.func.apply(global, _current.isRequestAnimationFrame ? [this._currentTickTime] : _current.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      }\n    }, {\n      key: \"flushOnlyPendingTimers\",\n      value: function flushOnlyPendingTimers(doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      }\n    }, {\n      key: \"flush\",\n      value: function flush() {\n        var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;\n        var flushPeriodic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var doTick = arguments.length > 2 ? arguments[2] : undefined;\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      }\n    }, {\n      key: \"flushPeriodic\",\n      value: function flushPeriodic(doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      }\n    }, {\n      key: \"flushNonPeriodic\",\n      value: function flushNonPeriodic(limit, doTick) {\n        var startTime = this._currentTickTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTickTime - startTime;\n      }\n    }]);\n\n    return Scheduler;\n  }(); // Next scheduler id.\n\n\n  Scheduler.nextId = 1;\n\n  var FakeAsyncTestZoneSpec = /*#__PURE__*/function () {\n    function FakeAsyncTestZoneSpec(namePrefix) {\n      var trackPendingRequestAnimationFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var macroTaskOptions = arguments.length > 2 ? arguments[2] : undefined;\n\n      _classCallCheck(this, FakeAsyncTestZoneSpec);\n\n      this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n      this.macroTaskOptions = macroTaskOptions;\n      this._scheduler = new Scheduler();\n      this._microtasks = [];\n      this._lastError = null;\n      this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n      this.pendingPeriodicTimers = [];\n      this.pendingTimers = [];\n      this.patchDateLocked = false;\n      this.properties = {\n        'FakeAsyncTestZoneSpec': this\n      };\n      this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n      // user can also define macroTaskOptions by define a global variable.\n\n      if (!this.macroTaskOptions) {\n        this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n      }\n    }\n\n    _createClass(FakeAsyncTestZoneSpec, [{\n      key: \"_fnAndFlush\",\n      value: function _fnAndFlush(fn, completers) {\n        var _this7 = this;\n\n        return function () {\n          for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n            args[_key9] = arguments[_key9];\n          }\n\n          fn.apply(global, args);\n\n          if (_this7._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this7.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this7._lastError === null;\n        };\n      }\n    }, {\n      key: \"_dequeueTimer\",\n      value: function _dequeueTimer(id) {\n        var _this8 = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this8.pendingTimers, id);\n        };\n      }\n    }, {\n      key: \"_requeuePeriodicTimer\",\n      value: function _requeuePeriodicTimer(fn, interval, args, id) {\n        var _this9 = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this9.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this9._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      }\n    }, {\n      key: \"_dequeuePeriodicTimer\",\n      value: function _dequeuePeriodicTimer(id) {\n        var _this10 = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this10.pendingPeriodicTimers, id);\n        };\n      }\n    }, {\n      key: \"_setTimeout\",\n      value: function _setTimeout(fn, delay, args) {\n        var isTimer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      }\n    }, {\n      key: \"_clearTimeout\",\n      value: function _clearTimeout(id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      }\n    }, {\n      key: \"_setInterval\",\n      value: function _setInterval(fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      }\n    }, {\n      key: \"_clearInterval\",\n      value: function _clearInterval(id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      }\n    }, {\n      key: \"_resetLastErrorAndThrow\",\n      value: function _resetLastErrorAndThrow() {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      }\n    }, {\n      key: \"getCurrentTickTime\",\n      value: function getCurrentTickTime() {\n        return this._scheduler.getCurrentTickTime();\n      }\n    }, {\n      key: \"getFakeSystemTime\",\n      value: function getFakeSystemTime() {\n        return this._scheduler.getFakeSystemTime();\n      }\n    }, {\n      key: \"setFakeBaseSystemTime\",\n      value: function setFakeBaseSystemTime(realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n      }\n    }, {\n      key: \"getRealSystemTime\",\n      value: function getRealSystemTime() {\n        return this._scheduler.getRealSystemTime();\n      }\n    }, {\n      key: \"lockDatePatch\",\n      value: function lockDatePatch() {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      }\n    }, {\n      key: \"unlockDatePatch\",\n      value: function unlockDatePatch() {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      }\n    }, {\n      key: \"tickToNext\",\n      value: function tickToNext() {\n        var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n        var doTick = arguments.length > 1 ? arguments[1] : undefined;\n        var tickOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n          processNewMacroTasksSynchronously: true\n        };\n\n        if (steps <= 0) {\n          return;\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      }\n    }, {\n      key: \"tick\",\n      value: function tick() {\n        var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var doTick = arguments.length > 1 ? arguments[1] : undefined;\n        var tickOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n          processNewMacroTasksSynchronously: true\n        };\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      }\n    }, {\n      key: \"flushMicrotasks\",\n      value: function flushMicrotasks() {\n        var _this11 = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function flushErrors() {\n          if (_this11._lastError !== null || _this11._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this11._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      }\n    }, {\n      key: \"flush\",\n      value: function flush(limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      }\n    }, {\n      key: \"flushOnlyPendingTimers\",\n      value: function flushOnlyPendingTimers(doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      }\n    }, {\n      key: \"removeAllTimers\",\n      value: function removeAllTimers() {\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        this._scheduler.removeAll();\n\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n      }\n    }, {\n      key: \"getTimerCount\",\n      value: function getTimerCount() {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n      }\n    }, {\n      key: \"onScheduleTask\",\n      value: function onScheduleTask(delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var _args = task.data && task.data['args'];\n\n                  var delay = _args && _args.length > 1 ? _args[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : _args;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      }\n    }, {\n      key: \"onCancelTask\",\n      value: function onCancelTask(delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      }\n    }, {\n      key: \"onInvoke\",\n      value: function onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      }\n    }, {\n      key: \"findMacroTaskOption\",\n      value: function findMacroTaskOption(task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      }\n    }, {\n      key: \"onHandleError\",\n      value: function onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      }\n    }], [{\n      key: \"assertInZone\",\n      value: function assertInZone() {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n    }, {\n      key: \"_removeTimer\",\n      value: function _removeTimer(timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      }\n    }, {\n      key: \"patchDate\",\n      value: function patchDate() {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      }\n    }, {\n      key: \"resetDate\",\n      value: function resetDate() {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      }\n    }, {\n      key: \"checkTimerPatch\",\n      value: function checkTimerPatch() {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      }\n    }]);\n\n    return FakeAsyncTestZoneSpec;\n  }(); // Export the class so that new instances can be created with proper\n  // constructor params.\n\n\n  Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\nZone.__load_patch('fakeasync', function (global, Zone, api) {\n  var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n  function getProxyZoneSpec() {\n    return Zone && Zone['ProxyZoneSpec'];\n  }\n\n  var _fakeAsyncTestZoneSpec = null;\n  /**\n   * Clears out the shared fake async zone for a test.\n   * To be called in a global `beforeEach`.\n   *\n   * @experimental\n   */\n\n  function resetFakeAsyncZone() {\n    if (_fakeAsyncTestZoneSpec) {\n      _fakeAsyncTestZoneSpec.unlockDatePatch();\n    }\n\n    _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n    getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n  }\n  /**\n   * Wraps a function to be executed in the fakeAsync zone:\n   * - microtasks are manually executed by calling `flushMicrotasks()`,\n   * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n   *\n   * If there are any pending timers at the end of the function, an exception will be thrown.\n   *\n   * Can be used to wrap inject() calls.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @param fn\n   * @returns The function wrapped to be executed in the fakeAsync zone\n   *\n   * @experimental\n   */\n\n\n  function fakeAsync(fn) {\n    // Not using an arrow function to preserve context passed from call site\n    var fakeAsyncFn = function fakeAsyncFn() {\n      var ProxyZoneSpec = getProxyZoneSpec();\n\n      if (!ProxyZoneSpec) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n      }\n\n      var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n      if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n        throw new Error('fakeAsync() calls can not be nested');\n      }\n\n      try {\n        // in case jasmine.clock init a fakeAsyncTestZoneSpec\n        if (!_fakeAsyncTestZoneSpec) {\n          if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n            throw new Error('fakeAsync() calls can not be nested');\n          }\n\n          _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n        }\n\n        var res;\n        var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n        proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n        _fakeAsyncTestZoneSpec.lockDatePatch();\n\n        try {\n          for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n            args[_key10] = arguments[_key10];\n          }\n\n          res = fn.apply(this, args);\n          flushMicrotasks();\n        } finally {\n          proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n        }\n\n        if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n          throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length, \" \") + \"periodic timer(s) still in the queue.\");\n        }\n\n        if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n          throw new Error(\"\".concat(_fakeAsyncTestZoneSpec.pendingTimers.length, \" timer(s) still in the queue.\"));\n        }\n\n        return res;\n      } finally {\n        resetFakeAsyncZone();\n      }\n    };\n\n    fakeAsyncFn.isFakeAsync = true;\n    return fakeAsyncFn;\n  }\n\n  function _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n      _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (_fakeAsyncTestZoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n      }\n    }\n\n    return _fakeAsyncTestZoneSpec;\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n   *\n   * The microtasks queue is drained at the very start of this function and after any timer callback\n   * has been executed.\n   *\n   * ## Example\n   *\n   * {@example core/testing/ts/fake_async.ts region='basic'}\n   *\n   * @experimental\n   */\n\n\n  function tick() {\n    var millis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var ignoreNestedTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n  }\n  /**\n   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n   * draining the macrotask queue until it is empty. The returned value is the milliseconds\n   * of time that would have been elapsed.\n   *\n   * @param maxTurns\n   * @returns The simulated time elapsed, in millis.\n   *\n   * @experimental\n   */\n\n\n  function flush(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n  }\n  /**\n   * Discard all remaining periodic tasks.\n   *\n   * @experimental\n   */\n\n\n  function discardPeriodicTasks() {\n    var zoneSpec = _getFakeAsyncZoneSpec();\n\n    var pendingTimers = zoneSpec.pendingPeriodicTimers;\n    zoneSpec.pendingPeriodicTimers.length = 0;\n  }\n  /**\n   * Flush any pending microtasks.\n   *\n   * @experimental\n   */\n\n\n  function flushMicrotasks() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n  }\n\n  Zone[api.symbol('fakeAsyncTest')] = {\n    resetFakeAsyncZone: resetFakeAsyncZone,\n    flushMicrotasks: flushMicrotasks,\n    discardPeriodicTasks: discardPeriodicTasks,\n    tick: tick,\n    flush: flush,\n    fakeAsync: fakeAsync\n  };\n}, true);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Promise for async/fakeAsync zoneSpec test\n * can support async operation which not supported by zone.js\n * such as\n * it ('test jsonp in AsyncZone', async() => {\n *   new Promise(res => {\n *     jsonp(url, (data) => {\n *       // success callback\n *       res(data);\n *     });\n *   }).then((jsonpResult) => {\n *     // get jsonp result.\n *\n *     // user will expect AsyncZoneSpec wait for\n *     // then, but because jsonp is not zone aware\n *     // AsyncZone will finish before then is called.\n *   });\n * });\n */\n\n\nZone.__load_patch('promisefortest', function (global, Zone, api) {\n  var symbolState = api.symbol('state');\n  var UNRESOLVED = null;\n  var symbolParentUnresolved = api.symbol('parentUnresolved'); // patch Promise.prototype.then to keep an internal\n  // number for tracking unresolved chained promise\n  // we will decrease this number when the parent promise\n  // being resolved/rejected and chained promise was\n  // scheduled as a microTask.\n  // so we can know such kind of chained promise still\n  // not resolved in AsyncTestZone\n\n  Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n    var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n    if (oriThen) {\n      return;\n    }\n\n    oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n\n    Promise.prototype.then = function () {\n      var chained = oriThen.apply(this, arguments);\n\n      if (this[symbolState] === UNRESOLVED) {\n        // parent promise is unresolved.\n        var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n\n        if (asyncTestZoneSpec) {\n          asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n          chained[symbolParentUnresolved] = true;\n        }\n      }\n\n      return chained;\n    };\n  };\n\n  Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n    // restore origin then\n    var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n\n    if (oriThen) {\n      Promise.prototype.then = oriThen;\n      Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n    }\n  };\n});","map":{"version":3,"sources":["C:/Totvs/po-angular/node_modules/zone.js/fesm2015/zone-testing.js"],"names":["NEWLINE","IGNORE_FRAMES","creationTrace","ERROR_TAG","SEP_TAG","sepTemplate","LongStackTrace","error","getStacktrace","timestamp","Date","getStacktraceWithUncaughtError","Error","getStacktraceWithCaughtError","err","caughtError","stack","getFrames","split","addErrorStack","lines","trace","i","length","frame","hasOwnProperty","push","renderLongStackTrace","frames","longTrace","trim","getTime","traceFrames","lastTime","separator","replace","join","stackTracesEnabled","stackTraceLimit","Zone","name","longStackTraceLimit","getLongStackTrace","undefined","__symbol__","onScheduleTask","parentZoneDelegate","currentZone","targetZone","task","currentTask","data","concat","type","Object","assign","scheduleTask","onHandleError","parentTask","longStack","handleError","captureStackTraces","stackTraces","count","computeIgnoreFrames","frames1","frames2","frame1","indexOf","match","frame2","ProxyZoneSpec","defaultSpecDelegate","_delegateSpec","properties","propertyKeys","lastTaskState","isNeedToTriggerHasTask","tasks","setDelegate","delegateSpec","isNewDelegate","forEach","key","keys","k","macroTask","microTask","getDelegate","onHasTask","splice","taskInfo","map","dataInfo","source","pendingTasksInfo","zoneSpec","onFork","fork","delegate","onIntercept","intercept","applyThis","applyArgs","tryTriggerHasTask","onInvoke","invoke","removeFromTasks","onInvokeTask","invokeTask","onCancelTask","cancelTask","current","target","hasTaskState","hasTask","get","isLoaded","SyncTestZoneSpec","namePrefix","runZone","__load_patch","global","api","__extends","d","b","p","__","constructor","prototype","create","jest","jasmine","ambientZone","syncZone","symbol","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors","GlobalErrors","instance","originalInstall","install","originalHandlers","process","listeners","r","apply","arguments","removeAllListeners","h","on","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","call","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn","clock","originalTick","tick","fakeAsyncZoneSpec","originalMockDate","mockDate","dateTime","setFakeBaseSystemTime","FakeAsyncTestZoneSpec","originalCreateSpyObj","createSpyObj","args","Array","slice","propertyNames","spyObj","defineProperty","obj","attributes","configurable","enumerable","describeBody","run","runInTestZone","testBody","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","message","proxyZoneSpec","getAndClearPendingTasksInfo","execute","zone","isChildOfAmbientZone","parent","context","rootZone","proxyZone","wrapDescribeFactoryInZone","originalJestFn","tableArgs","originalDescribeFn","wrapTestFactoryInZone","isTestFunc","wrappedFunc","isFakeAsync","writable","each","describe","only","fdescribe","skip","xdescribe","todo","it","fit","xit","test","patchJestObject","Timer","isModern","isPatchingFakeTimer","isInTestFunc","patchMethod","self","getRealSystemTime","flushMicrotasks","flush","flushOnlyPendingTimers","tickToNext","removeAllTimers","getTimerCount","Mocha","testZone","suiteZone","mochaOriginal","after","afterEach","before","beforeEach","modifyArguments","syncTest","asyncTest","arg","toString","wrapSuiteInZone","suite","specify","xspecify","suiteTeardown","teardown","suiteSetup","setup","originalRunTest","originalRun","Runner","runTest","e","_global","AsyncTestZoneSpec","finishCallback","failCallback","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","isUnresolvedChainedPromisePending","patchPromiseForTest","Promise","unPatchPromiseForTest","symbolParentUnresolved","afterTaskCounts","_taskCounts","_finishCallbackIfDone","result","change","window","fail","assertPresent","getZoneWith","previousDelegate","testZoneSpec","runGuarded","OriginalDate","FakeDate","setTime","now","fakeAsyncTestZoneSpec","getFakeSystemTime","UTC","parse","timers","setInterval","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","fakeBaseSystemTime","cb","delay","options","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","currentEntry","step","doTick","tickOptions","startTime","targetTask","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","shift","idx","retval","lastTask","limit","flushPeriodic","flushNonPeriodic","filter","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","pendingPeriodicTimers","pendingTimers","patchDateLocked","completers","onSuccess","onError","_removeTimer","interval","scheduleFunction","isTimer","removeTimerFn","_dequeueTimer","_fnAndFlush","removeScheduledFunctionWithId","_dequeuePeriodicTimer","_requeuePeriodicTimer","getCurrentTickTime","realTime","patchDate","resetDate","steps","assertInZone","_resetLastErrorAndThrow","flushErrors","microtask","elapsed","removeAll","additionalArgs","callbackIndex","cbIdx","_setTimeout","_setInterval","macroTaskOption","findMacroTaskOption","callbackArgs","_clearTimeout","_clearInterval","handleId","callback","index","checkTimerPatch","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","unlockDatePatch","resetDelegate","fakeAsyncFn","res","lastProxyZoneSpec","lockDatePatch","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","symbolState","UNRESOLVED","oriThen","then","chained","asyncTestZoneSpec","unpatchPromiseForTest"],"mappings":"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","sourcesContent":["'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview\n * @suppress {globalThis}\n */\nconst NEWLINE = '\\n';\nconst IGNORE_FRAMES = {};\nconst creationTrace = '__creationTrace__';\nconst ERROR_TAG = 'STACKTRACE TRACKING';\nconst SEP_TAG = '__SEP_TAG__';\nlet sepTemplate = SEP_TAG + '@[native]';\nclass LongStackTrace {\n    constructor() {\n        this.error = getStacktrace();\n        this.timestamp = new Date();\n    }\n}\nfunction getStacktraceWithUncaughtError() {\n    return new Error(ERROR_TAG);\n}\nfunction getStacktraceWithCaughtError() {\n    try {\n        throw getStacktraceWithUncaughtError();\n    }\n    catch (err) {\n        return err;\n    }\n}\n// Some implementations of exception handling don't create a stack trace if the exception\n// isn't thrown, however it's faster not to actually throw the exception.\nconst error = getStacktraceWithUncaughtError();\nconst caughtError = getStacktraceWithCaughtError();\nconst getStacktrace = error.stack ?\n    getStacktraceWithUncaughtError :\n    (caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError);\nfunction getFrames(error) {\n    return error.stack ? error.stack.split(NEWLINE) : [];\n}\nfunction addErrorStack(lines, error) {\n    let trace = getFrames(error);\n    for (let i = 0; i < trace.length; i++) {\n        const frame = trace[i];\n        // Filter out the Frames which are part of stack capturing.\n        if (!IGNORE_FRAMES.hasOwnProperty(frame)) {\n            lines.push(trace[i]);\n        }\n    }\n}\nfunction renderLongStackTrace(frames, stack) {\n    const longTrace = [stack ? stack.trim() : ''];\n    if (frames) {\n        let timestamp = new Date().getTime();\n        for (let i = 0; i < frames.length; i++) {\n            const traceFrames = frames[i];\n            const lastTime = traceFrames.timestamp;\n            let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;\n            separator = separator.replace(/[^\\w\\d]/g, '_');\n            longTrace.push(sepTemplate.replace(SEP_TAG, separator));\n            addErrorStack(longTrace, traceFrames.error);\n            timestamp = lastTime.getTime();\n        }\n    }\n    return longTrace.join(NEWLINE);\n}\n// if Error.stackTraceLimit is 0, means stack trace\n// is disabled, so we don't need to generate long stack trace\n// this will improve performance in some test(some test will\n// set stackTraceLimit to 0, https://github.com/angular/zone.js/issues/698\nfunction stackTracesEnabled() {\n    // Cast through any since this property only exists on Error in the nodejs\n    // typings.\n    return Error.stackTraceLimit > 0;\n}\nZone['longStackTraceZoneSpec'] = {\n    name: 'long-stack-trace',\n    longStackTraceLimit: 10,\n    // add a getLongStackTrace method in spec to\n    // handle handled reject promise error.\n    getLongStackTrace: function (error) {\n        if (!error) {\n            return undefined;\n        }\n        const trace = error[Zone.__symbol__('currentTaskTrace')];\n        if (!trace) {\n            return error.stack;\n        }\n        return renderLongStackTrace(trace, error.stack);\n    },\n    onScheduleTask: function (parentZoneDelegate, currentZone, targetZone, task) {\n        if (stackTracesEnabled()) {\n            const currentTask = Zone.currentTask;\n            let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];\n            trace = [new LongStackTrace()].concat(trace);\n            if (trace.length > this.longStackTraceLimit) {\n                trace.length = this.longStackTraceLimit;\n            }\n            if (!task.data)\n                task.data = {};\n            if (task.type === 'eventTask') {\n                // Fix issue https://github.com/angular/zone.js/issues/1195,\n                // For event task of browser, by default, all task will share a\n                // singleton instance of data object, we should create a new one here\n                // The cast to `any` is required to workaround a closure bug which wrongly applies\n                // URL sanitization rules to .data access.\n                task.data = Object.assign({}, task.data);\n            }\n            task.data[creationTrace] = trace;\n        }\n        return parentZoneDelegate.scheduleTask(targetZone, task);\n    },\n    onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n        if (stackTracesEnabled()) {\n            const parentTask = Zone.currentTask || error.task;\n            if (error instanceof Error && parentTask) {\n                const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error.stack);\n                try {\n                    error.stack = error.longStack = longStack;\n                }\n                catch (err) {\n                }\n            }\n        }\n        return parentZoneDelegate.handleError(targetZone, error);\n    }\n};\nfunction captureStackTraces(stackTraces, count) {\n    if (count > 0) {\n        stackTraces.push(getFrames((new LongStackTrace()).error));\n        captureStackTraces(stackTraces, count - 1);\n    }\n}\nfunction computeIgnoreFrames() {\n    if (!stackTracesEnabled()) {\n        return;\n    }\n    const frames = [];\n    captureStackTraces(frames, 2);\n    const frames1 = frames[0];\n    const frames2 = frames[1];\n    for (let i = 0; i < frames1.length; i++) {\n        const frame1 = frames1[i];\n        if (frame1.indexOf(ERROR_TAG) == -1) {\n            let match = frame1.match(/^\\s*at\\s+/);\n            if (match) {\n                sepTemplate = match[0] + SEP_TAG + ' (http://localhost)';\n                break;\n            }\n        }\n    }\n    for (let i = 0; i < frames1.length; i++) {\n        const frame1 = frames1[i];\n        const frame2 = frames2[i];\n        if (frame1 === frame2) {\n            IGNORE_FRAMES[frame1] = true;\n        }\n        else {\n            break;\n        }\n    }\n}\ncomputeIgnoreFrames();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ProxyZoneSpec {\n    constructor(defaultSpecDelegate = null) {\n        this.defaultSpecDelegate = defaultSpecDelegate;\n        this.name = 'ProxyZone';\n        this._delegateSpec = null;\n        this.properties = { 'ProxyZoneSpec': this };\n        this.propertyKeys = null;\n        this.lastTaskState = null;\n        this.isNeedToTriggerHasTask = false;\n        this.tasks = [];\n        this.setDelegate(defaultSpecDelegate);\n    }\n    static get() {\n        return Zone.current.get('ProxyZoneSpec');\n    }\n    static isLoaded() {\n        return ProxyZoneSpec.get() instanceof ProxyZoneSpec;\n    }\n    static assertPresent() {\n        if (!ProxyZoneSpec.isLoaded()) {\n            throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);\n        }\n        return ProxyZoneSpec.get();\n    }\n    setDelegate(delegateSpec) {\n        const isNewDelegate = this._delegateSpec !== delegateSpec;\n        this._delegateSpec = delegateSpec;\n        this.propertyKeys && this.propertyKeys.forEach((key) => delete this.properties[key]);\n        this.propertyKeys = null;\n        if (delegateSpec && delegateSpec.properties) {\n            this.propertyKeys = Object.keys(delegateSpec.properties);\n            this.propertyKeys.forEach((k) => this.properties[k] = delegateSpec.properties[k]);\n        }\n        // if a new delegateSpec was set, check if we need to trigger hasTask\n        if (isNewDelegate && this.lastTaskState &&\n            (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {\n            this.isNeedToTriggerHasTask = true;\n        }\n    }\n    getDelegate() {\n        return this._delegateSpec;\n    }\n    resetDelegate() {\n        const delegateSpec = this.getDelegate();\n        this.setDelegate(this.defaultSpecDelegate);\n    }\n    tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {\n        if (this.isNeedToTriggerHasTask && this.lastTaskState) {\n            // last delegateSpec has microTask or macroTask\n            // should call onHasTask in current delegateSpec\n            this.isNeedToTriggerHasTask = false;\n            this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);\n        }\n    }\n    removeFromTasks(task) {\n        if (!this.tasks) {\n            return;\n        }\n        for (let i = 0; i < this.tasks.length; i++) {\n            if (this.tasks[i] === task) {\n                this.tasks.splice(i, 1);\n                return;\n            }\n        }\n    }\n    getAndClearPendingTasksInfo() {\n        if (this.tasks.length === 0) {\n            return '';\n        }\n        const taskInfo = this.tasks.map((task) => {\n            const dataInfo = task.data &&\n                Object.keys(task.data)\n                    .map((key) => {\n                    return key + ':' + task.data[key];\n                })\n                    .join(',');\n            return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;\n        });\n        const pendingTasksInfo = '--Pending async tasks are: [' + taskInfo + ']';\n        // clear tasks\n        this.tasks = [];\n        return pendingTasksInfo;\n    }\n    onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {\n        if (this._delegateSpec && this._delegateSpec.onFork) {\n            return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);\n        }\n        else {\n            return parentZoneDelegate.fork(targetZone, zoneSpec);\n        }\n    }\n    onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {\n        if (this._delegateSpec && this._delegateSpec.onIntercept) {\n            return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);\n        }\n        else {\n            return parentZoneDelegate.intercept(targetZone, delegate, source);\n        }\n    }\n    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onInvoke) {\n            return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);\n        }\n        else {\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        }\n    }\n    onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n        if (this._delegateSpec && this._delegateSpec.onHandleError) {\n            return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error);\n        }\n        else {\n            return parentZoneDelegate.handleError(targetZone, error);\n        }\n    }\n    onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n            this.tasks.push(task);\n        }\n        if (this._delegateSpec && this._delegateSpec.onScheduleTask) {\n            return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);\n        }\n        else {\n            return parentZoneDelegate.scheduleTask(targetZone, task);\n        }\n    }\n    onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n            this.removeFromTasks(task);\n        }\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onInvokeTask) {\n            return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);\n        }\n        else {\n            return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        }\n    }\n    onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n        if (task.type !== 'eventTask') {\n            this.removeFromTasks(task);\n        }\n        this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);\n        if (this._delegateSpec && this._delegateSpec.onCancelTask) {\n            return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);\n        }\n        else {\n            return parentZoneDelegate.cancelTask(targetZone, task);\n        }\n    }\n    onHasTask(delegate, current, target, hasTaskState) {\n        this.lastTaskState = hasTaskState;\n        if (this._delegateSpec && this._delegateSpec.onHasTask) {\n            this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);\n        }\n        else {\n            delegate.hasTask(target, hasTaskState);\n        }\n    }\n}\n// Export the class so that new instances can be created with proper\n// constructor params.\nZone['ProxyZoneSpec'] = ProxyZoneSpec;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass SyncTestZoneSpec {\n    constructor(namePrefix) {\n        this.runZone = Zone.current;\n        this.name = 'syncTestZone for ' + namePrefix;\n    }\n    onScheduleTask(delegate, current, target, task) {\n        switch (task.type) {\n            case 'microTask':\n            case 'macroTask':\n                throw new Error(`Cannot call ${task.source} from within a sync test.`);\n            case 'eventTask':\n                task = delegate.scheduleTask(target, task);\n                break;\n        }\n        return task;\n    }\n}\n// Export the class so that new instances can be created with proper\n// constructor params.\nZone['SyncTestZoneSpec'] = SyncTestZoneSpec;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('jasmine', (global, Zone, api) => {\n    const __extends = function (d, b) {\n        for (const p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p];\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n    };\n    // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n    if (!Zone)\n        throw new Error('Missing: zone.js');\n    if (typeof jest !== 'undefined') {\n        // return if jasmine is a light implementation inside jest\n        // in this case, we are running inside jest not jasmine\n        return;\n    }\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n        return;\n    }\n    jasmine['__zone_patch__'] = true;\n    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec)\n        throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec)\n        throw new Error('Missing: ProxyZoneSpec');\n    const ambientZone = Zone.current;\n    // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n    // error if any asynchronous operations are attempted inside of a `describe` but outside of\n    // a `beforeEach` or `it`.\n    const syncZone = ambientZone.fork(new SyncTestZoneSpec('jasmine.describe'));\n    const symbol = Zone.__symbol__;\n    // whether patch jasmine clock when in fakeAsync\n    const disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n    // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n    const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n        ((global[symbol('fakeAsyncPatchLock')] === true) ||\n            (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n    const ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n    if (!ignoreUnhandledRejection) {\n        const globalErrors = jasmine.GlobalErrors;\n        if (globalErrors && !jasmine[symbol('GlobalErrors')]) {\n            jasmine[symbol('GlobalErrors')] = globalErrors;\n            jasmine.GlobalErrors = function () {\n                const instance = new globalErrors();\n                const originalInstall = instance.install;\n                if (originalInstall && !instance[symbol('install')]) {\n                    instance[symbol('install')] = originalInstall;\n                    instance.install = function () {\n                        const originalHandlers = process.listeners('unhandledRejection');\n                        const r = originalInstall.apply(this, arguments);\n                        process.removeAllListeners('unhandledRejection');\n                        if (originalHandlers) {\n                            originalHandlers.forEach(h => process.on('unhandledRejection', h));\n                        }\n                        return r;\n                    };\n                }\n                return instance;\n            };\n        }\n    }\n    // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n    const jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n        let originalJasmineFn = jasmineEnv[methodName];\n        jasmineEnv[methodName] = function (description, specDefinitions) {\n            return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));\n        };\n    });\n    ['it', 'xit', 'fit'].forEach(methodName => {\n        let originalJasmineFn = jasmineEnv[methodName];\n        jasmineEnv[symbol(methodName)] = originalJasmineFn;\n        jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n            arguments[1] = wrapTestInZone(specDefinitions);\n            return originalJasmineFn.apply(this, arguments);\n        };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n        let originalJasmineFn = jasmineEnv[methodName];\n        jasmineEnv[symbol(methodName)] = originalJasmineFn;\n        jasmineEnv[methodName] = function (specDefinitions, timeout) {\n            arguments[0] = wrapTestInZone(specDefinitions);\n            return originalJasmineFn.apply(this, arguments);\n        };\n    });\n    if (!disablePatchingJasmineClock) {\n        // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n        // they can work properly in FakeAsyncTest\n        const originalClockFn = (jasmine[symbol('clock')] = jasmine['clock']);\n        jasmine['clock'] = function () {\n            const clock = originalClockFn.apply(this, arguments);\n            if (!clock[symbol('patched')]) {\n                clock[symbol('patched')] = symbol('patched');\n                const originalTick = (clock[symbol('tick')] = clock.tick);\n                clock.tick = function () {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                    }\n                    return originalTick.apply(this, arguments);\n                };\n                const originalMockDate = (clock[symbol('mockDate')] = clock.mockDate);\n                clock.mockDate = function () {\n                    const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                    if (fakeAsyncZoneSpec) {\n                        const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                        return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                            arguments);\n                    }\n                    return originalMockDate.apply(this, arguments);\n                };\n                // for auto go into fakeAsync feature, we need the flag to enable it\n                if (enableAutoFakeAsyncWhenClockPatched) {\n                    ['install', 'uninstall'].forEach(methodName => {\n                        const originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                        clock[methodName] = function () {\n                            const FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                            if (FakeAsyncTestZoneSpec) {\n                                jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                return;\n                            }\n                            return originalClockFn.apply(this, arguments);\n                        };\n                    });\n                }\n            }\n            return clock;\n        };\n    }\n    // monkey patch createSpyObj to make properties enumerable to true\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n        const originalCreateSpyObj = jasmine.createSpyObj;\n        jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj;\n        jasmine.createSpyObj = function () {\n            const args = Array.prototype.slice.call(arguments);\n            const propertyNames = args.length >= 3 ? args[2] : null;\n            let spyObj;\n            if (propertyNames) {\n                const defineProperty = Object.defineProperty;\n                Object.defineProperty = function (obj, p, attributes) {\n                    return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                };\n                try {\n                    spyObj = originalCreateSpyObj.apply(this, args);\n                }\n                finally {\n                    Object.defineProperty = defineProperty;\n                }\n            }\n            else {\n                spyObj = originalCreateSpyObj.apply(this, args);\n            }\n            return spyObj;\n        };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n    function wrapDescribeInZone(describeBody) {\n        return function () {\n            return syncZone.run(describeBody, this, arguments);\n        };\n    }\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n        const isClockInstalled = !!jasmine[symbol('clockInstalled')];\n        const testProxyZoneSpec = queueRunner.testProxyZoneSpec;\n        const testProxyZone = queueRunner.testProxyZone;\n        if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n            // auto run a fakeAsync\n            const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n            if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                testBody = fakeAsyncModule.fakeAsync(testBody);\n            }\n        }\n        if (done) {\n            return testProxyZone.run(testBody, applyThis, [done]);\n        }\n        else {\n            return testProxyZone.run(testBody, applyThis);\n        }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n    function wrapTestInZone(testBody) {\n        // The `done` callback is only passed through if the function expects at least one argument.\n        // Note we have to make a function with correct number of arguments, otherwise jasmine will\n        // think that all functions are sync or async.\n        return (testBody && (testBody.length ? function (done) {\n            return runInTestZone(testBody, this, this.queueRunner, done);\n        } : function () {\n            return runInTestZone(testBody, this, this.queueRunner);\n        }));\n    }\n    const QueueRunner = jasmine.QueueRunner;\n    jasmine.QueueRunner = (function (_super) {\n        __extends(ZoneQueueRunner, _super);\n        function ZoneQueueRunner(attrs) {\n            if (attrs.onComplete) {\n                attrs.onComplete = (fn => () => {\n                    // All functions are done, clear the test zone.\n                    this.testProxyZone = null;\n                    this.testProxyZoneSpec = null;\n                    ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                })(attrs.onComplete);\n            }\n            const nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n            const nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n            if (nativeSetTimeout) {\n                // should run setTimeout inside jasmine outside of zone\n                attrs.timeout = {\n                    setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                    clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                };\n            }\n            // create a userContext to hold the queueRunner itself\n            // so we can access the testProxy in it/xit/beforeEach ...\n            if (jasmine.UserContext) {\n                if (!attrs.userContext) {\n                    attrs.userContext = new jasmine.UserContext();\n                }\n                attrs.userContext.queueRunner = this;\n            }\n            else {\n                if (!attrs.userContext) {\n                    attrs.userContext = {};\n                }\n                attrs.userContext.queueRunner = this;\n            }\n            // patch attrs.onException\n            const onException = attrs.onException;\n            attrs.onException = function (error) {\n                if (error &&\n                    error.message ===\n                        'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                    // jasmine timeout, we can make the error message more\n                    // reasonable to tell what tasks are pending\n                    const proxyZoneSpec = this && this.testProxyZoneSpec;\n                    if (proxyZoneSpec) {\n                        const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                        try {\n                            // try catch here in case error.message is not writable\n                            error.message += pendingTasksInfo;\n                        }\n                        catch (err) {\n                        }\n                    }\n                }\n                if (onException) {\n                    onException.call(this, error);\n                }\n            };\n            _super.call(this, attrs);\n        }\n        ZoneQueueRunner.prototype.execute = function () {\n            let zone = Zone.current;\n            let isChildOfAmbientZone = false;\n            while (zone) {\n                if (zone === ambientZone) {\n                    isChildOfAmbientZone = true;\n                    break;\n                }\n                zone = zone.parent;\n            }\n            if (!isChildOfAmbientZone)\n                throw new Error('Unexpected Zone: ' + Zone.current.name);\n            // This is the zone which will be used for running individual tests.\n            // It will be a proxy zone, so that the tests function can retroactively install\n            // different zones.\n            // Example:\n            //   - In beforeEach() do childZone = Zone.current.fork(...);\n            //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n            //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n            //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n            //     fakeAsync behavior to the childZone.\n            this.testProxyZoneSpec = new ProxyZoneSpec();\n            this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n            if (!Zone.currentTask) {\n                // if we are not running in a task then if someone would register a\n                // element.addEventListener and then calling element.click() the\n                // addEventListener callback would think that it is the top most task and would\n                // drain the microtask queue on element.click() which would be incorrect.\n                // For this reason we always force a task when running jasmine tests.\n                Zone.current.scheduleMicroTask('jasmine.execute().forceTask', () => QueueRunner.prototype.execute.call(this));\n            }\n            else {\n                _super.prototype.execute.call(this);\n            }\n        };\n        return ZoneQueueRunner;\n    })(QueueRunner);\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('jest', (context, Zone, api) => {\n    if (typeof jest === 'undefined' || jest['__zone_patch__']) {\n        return;\n    }\n    jest['__zone_patch__'] = true;\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    if (!ProxyZoneSpec) {\n        throw new Error('Missing ProxyZoneSpec');\n    }\n    const rootZone = Zone.current;\n    const syncZone = rootZone.fork(new SyncTestZoneSpec('jest.describe'));\n    const proxyZoneSpec = new ProxyZoneSpec();\n    const proxyZone = rootZone.fork(proxyZoneSpec);\n    function wrapDescribeFactoryInZone(originalJestFn) {\n        return function (...tableArgs) {\n            const originalDescribeFn = originalJestFn.apply(this, tableArgs);\n            return function (...args) {\n                args[1] = wrapDescribeInZone(args[1]);\n                return originalDescribeFn.apply(this, args);\n            };\n        };\n    }\n    function wrapTestFactoryInZone(originalJestFn) {\n        return function (...tableArgs) {\n            return function (...args) {\n                args[1] = wrapTestInZone(args[1]);\n                return originalJestFn.apply(this, tableArgs).apply(this, args);\n            };\n        };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `describe` block to execute in a\n     * synchronous-only zone.\n     */\n    function wrapDescribeInZone(describeBody) {\n        return function (...args) {\n            return syncZone.run(describeBody, this, args);\n        };\n    }\n    /**\n     * Gets a function wrapping the body of a jest `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in the `proxyZone`.\n     */\n    function wrapTestInZone(testBody, isTestFunc = false) {\n        if (typeof testBody !== 'function') {\n            return testBody;\n        }\n        const wrappedFunc = function () {\n            if (Zone[api.symbol('useFakeTimersCalled')] === true && testBody &&\n                !testBody.isFakeAsync) {\n                // jest.useFakeTimers is called, run into fakeAsyncTest automatically.\n                const fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            proxyZoneSpec.isTestFunc = isTestFunc;\n            return proxyZone.run(testBody, null, arguments);\n        };\n        // Update the length of wrappedFunc to be the same as the length of the testBody\n        // So jest core can handle whether the test function has `done()` or not correctly\n        Object.defineProperty(wrappedFunc, 'length', { configurable: true, writable: true, enumerable: false });\n        wrappedFunc.length = testBody.length;\n        return wrappedFunc;\n    }\n    ['describe', 'xdescribe', 'fdescribe'].forEach(methodName => {\n        let originalJestFn = context[methodName];\n        if (context[Zone.__symbol__(methodName)]) {\n            return;\n        }\n        context[Zone.__symbol__(methodName)] = originalJestFn;\n        context[methodName] = function (...args) {\n            args[1] = wrapDescribeInZone(args[1]);\n            return originalJestFn.apply(this, args);\n        };\n        context[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);\n    });\n    context.describe.only = context.fdescribe;\n    context.describe.skip = context.xdescribe;\n    ['it', 'xit', 'fit', 'test', 'xtest'].forEach(methodName => {\n        let originalJestFn = context[methodName];\n        if (context[Zone.__symbol__(methodName)]) {\n            return;\n        }\n        context[Zone.__symbol__(methodName)] = originalJestFn;\n        context[methodName] = function (...args) {\n            args[1] = wrapTestInZone(args[1], true);\n            return originalJestFn.apply(this, args);\n        };\n        context[methodName].each = wrapTestFactoryInZone(originalJestFn.each);\n        context[methodName].todo = originalJestFn.todo;\n    });\n    context.it.only = context.fit;\n    context.it.skip = context.xit;\n    context.test.only = context.fit;\n    context.test.skip = context.xit;\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(methodName => {\n        let originalJestFn = context[methodName];\n        if (context[Zone.__symbol__(methodName)]) {\n            return;\n        }\n        context[Zone.__symbol__(methodName)] = originalJestFn;\n        context[methodName] = function (...args) {\n            args[0] = wrapTestInZone(args[0]);\n            return originalJestFn.apply(this, args);\n        };\n    });\n    Zone.patchJestObject = function patchJestObject(Timer, isModern = false) {\n        // check whether currently the test is inside fakeAsync()\n        function isPatchingFakeTimer() {\n            const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            return !!fakeAsyncZoneSpec;\n        }\n        // check whether the current function is inside `test/it` or other methods\n        // such as `describe/beforeEach`\n        function isInTestFunc() {\n            const proxyZoneSpec = Zone.current.get('ProxyZoneSpec');\n            return proxyZoneSpec && proxyZoneSpec.isTestFunc;\n        }\n        if (Timer[api.symbol('fakeTimers')]) {\n            return;\n        }\n        Timer[api.symbol('fakeTimers')] = true;\n        // patch jest fakeTimer internal method to make sure no console.warn print out\n        api.patchMethod(Timer, '_checkFakeTimers', delegate => {\n            return function (self, args) {\n                if (isPatchingFakeTimer()) {\n                    return true;\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch useFakeTimers(), set useFakeTimersCalled flag, and make test auto run into fakeAsync\n        api.patchMethod(Timer, 'useFakeTimers', delegate => {\n            return function (self, args) {\n                Zone[api.symbol('useFakeTimersCalled')] = true;\n                if (isModern || isInTestFunc()) {\n                    return delegate.apply(self, args);\n                }\n                return self;\n            };\n        });\n        // patch useRealTimers(), unset useFakeTimers flag\n        api.patchMethod(Timer, 'useRealTimers', delegate => {\n            return function (self, args) {\n                Zone[api.symbol('useFakeTimersCalled')] = false;\n                if (isModern || isInTestFunc()) {\n                    return delegate.apply(self, args);\n                }\n                return self;\n            };\n        });\n        // patch setSystemTime(), call setCurrentRealTime() in the fakeAsyncTest\n        api.patchMethod(Timer, 'setSystemTime', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                    fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch getSystemTime(), call getCurrentRealTime() in the fakeAsyncTest\n        api.patchMethod(Timer, 'getRealSystemTime', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n                    return fakeAsyncZoneSpec.getRealSystemTime();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch runAllTicks(), run all microTasks inside fakeAsync\n        api.patchMethod(Timer, 'runAllTicks', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.flushMicrotasks();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch runAllTimers(), run all macroTasks inside fakeAsync\n        api.patchMethod(Timer, 'runAllTimers', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.flush(100, true);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch advanceTimersByTime(), call tick() in the fakeAsyncTest\n        api.patchMethod(Timer, 'advanceTimersByTime', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.tick(args[0]);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch runOnlyPendingTimers(), call flushOnlyPendingTimers() in the fakeAsyncTest\n        api.patchMethod(Timer, 'runOnlyPendingTimers', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.flushOnlyPendingTimers();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch advanceTimersToNextTimer(), call tickToNext() in the fakeAsyncTest\n        api.patchMethod(Timer, 'advanceTimersToNextTimer', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.tickToNext(args[0]);\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch clearAllTimers(), call removeAllTimers() in the fakeAsyncTest\n        api.patchMethod(Timer, 'clearAllTimers', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    fakeAsyncZoneSpec.removeAllTimers();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n        // patch getTimerCount(), call getTimerCount() in the fakeAsyncTest\n        api.patchMethod(Timer, 'getTimerCount', delegate => {\n            return function (self, args) {\n                const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (fakeAsyncZoneSpec) {\n                    return fakeAsyncZoneSpec.getTimerCount();\n                }\n                else {\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n    };\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('mocha', (global, Zone) => {\n    const Mocha = global.Mocha;\n    if (typeof Mocha === 'undefined') {\n        // return if Mocha is not available, because now zone-testing\n        // will load mocha patch with jasmine/jest patch\n        return;\n    }\n    if (typeof Zone === 'undefined') {\n        throw new Error('Missing Zone.js');\n    }\n    const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    const SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    if (!ProxyZoneSpec) {\n        throw new Error('Missing ProxyZoneSpec');\n    }\n    if (Mocha['__zone_patch__']) {\n        throw new Error('\"Mocha\" has already been patched with \"Zone\".');\n    }\n    Mocha['__zone_patch__'] = true;\n    const rootZone = Zone.current;\n    const syncZone = rootZone.fork(new SyncTestZoneSpec('Mocha.describe'));\n    let testZone = null;\n    const suiteZone = rootZone.fork(new ProxyZoneSpec());\n    const mochaOriginal = {\n        after: Mocha.after,\n        afterEach: Mocha.afterEach,\n        before: Mocha.before,\n        beforeEach: Mocha.beforeEach,\n        describe: Mocha.describe,\n        it: Mocha.it\n    };\n    function modifyArguments(args, syncTest, asyncTest) {\n        for (let i = 0; i < args.length; i++) {\n            let arg = args[i];\n            if (typeof arg === 'function') {\n                // The `done` callback is only passed through if the function expects at\n                // least one argument.\n                // Note we have to make a function with correct number of arguments,\n                // otherwise mocha will\n                // think that all functions are sync or async.\n                args[i] = (arg.length === 0) ? syncTest(arg) : asyncTest(arg);\n                // Mocha uses toString to view the test body in the result list, make sure we return the\n                // correct function body\n                args[i].toString = function () {\n                    return arg.toString();\n                };\n            }\n        }\n        return args;\n    }\n    function wrapDescribeInZone(args) {\n        const syncTest = function (fn) {\n            return function () {\n                return syncZone.run(fn, this, arguments);\n            };\n        };\n        return modifyArguments(args, syncTest);\n    }\n    function wrapTestInZone(args) {\n        const asyncTest = function (fn) {\n            return function (done) {\n                return testZone.run(fn, this, [done]);\n            };\n        };\n        const syncTest = function (fn) {\n            return function () {\n                return testZone.run(fn, this);\n            };\n        };\n        return modifyArguments(args, syncTest, asyncTest);\n    }\n    function wrapSuiteInZone(args) {\n        const asyncTest = function (fn) {\n            return function (done) {\n                return suiteZone.run(fn, this, [done]);\n            };\n        };\n        const syncTest = function (fn) {\n            return function () {\n                return suiteZone.run(fn, this);\n            };\n        };\n        return modifyArguments(args, syncTest, asyncTest);\n    }\n    global.describe = global.suite = Mocha.describe = function () {\n        return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.xdescribe = global.suite.skip = Mocha.describe.skip = function () {\n        return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.describe.only = global.suite.only = Mocha.describe.only = function () {\n        return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));\n    };\n    global.it = global.specify = global.test = Mocha.it = function () {\n        return mochaOriginal.it.apply(this, wrapTestInZone(arguments));\n    };\n    global.xit = global.xspecify = Mocha.it.skip = function () {\n        return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));\n    };\n    global.it.only = global.test.only = Mocha.it.only = function () {\n        return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));\n    };\n    global.after = global.suiteTeardown = Mocha.after = function () {\n        return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));\n    };\n    global.afterEach = global.teardown = Mocha.afterEach = function () {\n        return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));\n    };\n    global.before = global.suiteSetup = Mocha.before = function () {\n        return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));\n    };\n    global.beforeEach = global.setup = Mocha.beforeEach = function () {\n        return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));\n    };\n    ((originalRunTest, originalRun) => {\n        Mocha.Runner.prototype.runTest = function (fn) {\n            Zone.current.scheduleMicroTask('mocha.forceTask', () => {\n                originalRunTest.call(this, fn);\n            });\n        };\n        Mocha.Runner.prototype.run = function (fn) {\n            this.on('test', (e) => {\n                testZone = rootZone.fork(new ProxyZoneSpec());\n            });\n            this.on('fail', (test, err) => {\n                const proxyZoneSpec = testZone && testZone.get('ProxyZoneSpec');\n                if (proxyZoneSpec && err) {\n                    try {\n                        // try catch here in case err.message is not writable\n                        err.message += proxyZoneSpec.getAndClearPendingTasksInfo();\n                    }\n                    catch (error) {\n                    }\n                }\n            });\n            return originalRun.call(this, fn);\n        };\n    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (_global) {\n    class AsyncTestZoneSpec {\n        constructor(finishCallback, failCallback, namePrefix) {\n            this.finishCallback = finishCallback;\n            this.failCallback = failCallback;\n            this._pendingMicroTasks = false;\n            this._pendingMacroTasks = false;\n            this._alreadyErrored = false;\n            this._isSync = false;\n            this.runZone = Zone.current;\n            this.unresolvedChainedPromiseCount = 0;\n            this.supportWaitUnresolvedChainedPromise = false;\n            this.name = 'asyncTestZone for ' + namePrefix;\n            this.properties = { 'AsyncTestZoneSpec': this };\n            this.supportWaitUnresolvedChainedPromise =\n                _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n        }\n        isUnresolvedChainedPromisePending() {\n            return this.unresolvedChainedPromiseCount > 0;\n        }\n        _finishCallbackIfDone() {\n            if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n                (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n                // We do this because we would like to catch unhandled rejected promises.\n                this.runZone.run(() => {\n                    setTimeout(() => {\n                        if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {\n                            this.finishCallback();\n                        }\n                    }, 0);\n                });\n            }\n        }\n        patchPromiseForTest() {\n            if (!this.supportWaitUnresolvedChainedPromise) {\n                return;\n            }\n            const patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n            if (patchPromiseForTest) {\n                patchPromiseForTest();\n            }\n        }\n        unPatchPromiseForTest() {\n            if (!this.supportWaitUnresolvedChainedPromise) {\n                return;\n            }\n            const unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n            if (unPatchPromiseForTest) {\n                unPatchPromiseForTest();\n            }\n        }\n        onScheduleTask(delegate, current, target, task) {\n            if (task.type !== 'eventTask') {\n                this._isSync = false;\n            }\n            if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n                // check whether the promise is a chained promise\n                if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                    // chained promise is being scheduled\n                    this.unresolvedChainedPromiseCount--;\n                }\n            }\n            return delegate.scheduleTask(target, task);\n        }\n        onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {\n            if (task.type !== 'eventTask') {\n                this._isSync = false;\n            }\n            return delegate.invokeTask(target, task, applyThis, applyArgs);\n        }\n        onCancelTask(delegate, current, target, task) {\n            if (task.type !== 'eventTask') {\n                this._isSync = false;\n            }\n            return delegate.cancelTask(target, task);\n        }\n        // Note - we need to use onInvoke at the moment to call finish when a test is\n        // fully synchronous. TODO(juliemr): remove this when the logic for\n        // onHasTask changes and it calls whenever the task queues are dirty.\n        // updated by(JiaLiPassion), only call finish callback when no task\n        // was scheduled/invoked/canceled.\n        onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n            try {\n                this._isSync = true;\n                return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n            }\n            finally {\n                const afterTaskCounts = parentZoneDelegate._taskCounts;\n                if (this._isSync) {\n                    this._finishCallbackIfDone();\n                }\n            }\n        }\n        onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n            // Let the parent try to handle the error.\n            const result = parentZoneDelegate.handleError(targetZone, error);\n            if (result) {\n                this.failCallback(error);\n                this._alreadyErrored = true;\n            }\n            return false;\n        }\n        onHasTask(delegate, current, target, hasTaskState) {\n            delegate.hasTask(target, hasTaskState);\n            if (hasTaskState.change == 'microTask') {\n                this._pendingMicroTasks = hasTaskState.microTask;\n                this._finishCallbackIfDone();\n            }\n            else if (hasTaskState.change == 'macroTask') {\n                this._pendingMacroTasks = hasTaskState.macroTask;\n                this._finishCallbackIfDone();\n            }\n        }\n    }\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\nZone.__load_patch('asynctest', (global, Zone, api) => {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n        // If we're running using the Jasmine test framework, adapt to call the 'done'\n        // function when asynchronous activity is finished.\n        if (global.jasmine) {\n            // Not using an arrow function to preserve context passed from call site\n            return function (done) {\n                if (!done) {\n                    // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                    // fake it here and assume sync.\n                    done = function () { };\n                    done.fail = function (e) {\n                        throw e;\n                    };\n                }\n                runInTestZone(fn, this, done, (err) => {\n                    if (typeof err === 'string') {\n                        return done.fail(new Error(err));\n                    }\n                    else {\n                        done.fail(err);\n                    }\n                });\n            };\n        }\n        // Otherwise, return a promise which will resolve when asynchronous activity\n        // is finished. This will be correctly consumed by the Mocha framework with\n        // it('...', async(myFn)); or can be used in a custom framework.\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            return new Promise((finishCallback, failCallback) => {\n                runInTestZone(fn, this, finishCallback, failCallback);\n            });\n        };\n    };\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n        const currentZone = Zone.current;\n        const AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n        if (AsyncTestZoneSpec === undefined) {\n            throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/async-test.js');\n        }\n        const ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!ProxyZoneSpec) {\n            throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/proxy.js');\n        }\n        const proxyZoneSpec = ProxyZoneSpec.get();\n        ProxyZoneSpec.assertPresent();\n        // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n        // If we do it in ProxyZone then we will get to infinite recursion.\n        const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n        const previousDelegate = proxyZoneSpec.getDelegate();\n        proxyZone.parent.run(() => {\n            const testZoneSpec = new AsyncTestZoneSpec(() => {\n                // Need to restore the original zone.\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's\n                    // sill this one. Otherwise, assume\n                    // it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                testZoneSpec.unPatchPromiseForTest();\n                currentZone.run(() => {\n                    finishCallback();\n                });\n            }, (error) => {\n                // Need to restore the original zone.\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                testZoneSpec.unPatchPromiseForTest();\n                currentZone.run(() => {\n                    failCallback(error);\n                });\n            }, 'test');\n            proxyZoneSpec.setDelegate(testZoneSpec);\n            testZoneSpec.patchPromiseForTest();\n        });\n        return Zone.current.runGuarded(fn, context);\n    }\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (global) {\n    const OriginalDate = global.Date;\n    // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n    function FakeDate() {\n        if (arguments.length === 0) {\n            const d = new OriginalDate();\n            d.setTime(FakeDate.now());\n            return d;\n        }\n        else {\n            const args = Array.prototype.slice.call(arguments);\n            return new OriginalDate(...args);\n        }\n    }\n    FakeDate.now = function () {\n        const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n        if (fakeAsyncTestZoneSpec) {\n            return fakeAsyncTestZoneSpec.getFakeSystemTime();\n        }\n        return OriginalDate.now.apply(this, arguments);\n    };\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse;\n    // keep a reference for zone patched timer function\n    const timers = {\n        setTimeout: global.setTimeout,\n        setInterval: global.setInterval,\n        clearTimeout: global.clearTimeout,\n        clearInterval: global.clearInterval\n    };\n    class Scheduler {\n        constructor() {\n            // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n            this._schedulerQueue = [];\n            // Current simulated time in millis.\n            this._currentTickTime = 0;\n            // Current fake system base time in millis.\n            this._currentFakeBaseSystemTime = OriginalDate.now();\n            // track requeuePeriodicTimer\n            this._currentTickRequeuePeriodicEntries = [];\n        }\n        getCurrentTickTime() {\n            return this._currentTickTime;\n        }\n        getFakeSystemTime() {\n            return this._currentFakeBaseSystemTime + this._currentTickTime;\n        }\n        setFakeBaseSystemTime(fakeBaseSystemTime) {\n            this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n        }\n        getRealSystemTime() {\n            return OriginalDate.now();\n        }\n        scheduleFunction(cb, delay, options) {\n            options = Object.assign({\n                args: [],\n                isPeriodic: false,\n                isRequestAnimationFrame: false,\n                id: -1,\n                isRequeuePeriodic: false\n            }, options);\n            let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n            let endTime = this._currentTickTime + delay;\n            // Insert so that scheduler queue remains sorted by end time.\n            let newEntry = {\n                endTime: endTime,\n                id: currentId,\n                func: cb,\n                args: options.args,\n                delay: delay,\n                isPeriodic: options.isPeriodic,\n                isRequestAnimationFrame: options.isRequestAnimationFrame\n            };\n            if (options.isRequeuePeriodic) {\n                this._currentTickRequeuePeriodicEntries.push(newEntry);\n            }\n            let i = 0;\n            for (; i < this._schedulerQueue.length; i++) {\n                let currentEntry = this._schedulerQueue[i];\n                if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                }\n            }\n            this._schedulerQueue.splice(i, 0, newEntry);\n            return currentId;\n        }\n        removeScheduledFunctionWithId(id) {\n            for (let i = 0; i < this._schedulerQueue.length; i++) {\n                if (this._schedulerQueue[i].id == id) {\n                    this._schedulerQueue.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        removeAll() {\n            this._schedulerQueue = [];\n        }\n        getTimerCount() {\n            return this._schedulerQueue.length;\n        }\n        tickToNext(step = 1, doTick, tickOptions) {\n            if (this._schedulerQueue.length < step) {\n                return;\n            }\n            // Find the last task currently queued in the scheduler queue and tick\n            // till that time.\n            const startTime = this._currentTickTime;\n            const targetTask = this._schedulerQueue[step - 1];\n            this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n        }\n        tick(millis = 0, doTick, tickOptions) {\n            let finalTime = this._currentTickTime + millis;\n            let lastCurrentTime = 0;\n            tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n            // we need to copy the schedulerQueue so nested timeout\n            // will not be wrongly called in the current tick\n            // https://github.com/angular/angular/issues/33799\n            const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                this._schedulerQueue :\n                this._schedulerQueue.slice();\n            if (schedulerQueue.length === 0 && doTick) {\n                doTick(millis);\n                return;\n            }\n            while (schedulerQueue.length > 0) {\n                // clear requeueEntries before each loop\n                this._currentTickRequeuePeriodicEntries = [];\n                let current = schedulerQueue[0];\n                if (finalTime < current.endTime) {\n                    // Done processing the queue since it's sorted by endTime.\n                    break;\n                }\n                else {\n                    // Time to run scheduled function. Remove it from the head of queue.\n                    let current = schedulerQueue.shift();\n                    if (!tickOptions.processNewMacroTasksSynchronously) {\n                        const idx = this._schedulerQueue.indexOf(current);\n                        if (idx >= 0) {\n                            this._schedulerQueue.splice(idx, 1);\n                        }\n                    }\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    let retval = current.func.apply(global, current.isRequestAnimationFrame ? [this._currentTickTime] : current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                    // check is there any requeue periodic entry is added in\n                    // current loop, if there is, we need to add to current loop\n                    if (!tickOptions.processNewMacroTasksSynchronously) {\n                        this._currentTickRequeuePeriodicEntries.forEach(newEntry => {\n                            let i = 0;\n                            for (; i < schedulerQueue.length; i++) {\n                                const currentEntry = schedulerQueue[i];\n                                if (newEntry.endTime < currentEntry.endTime) {\n                                    break;\n                                }\n                            }\n                            schedulerQueue.splice(i, 0, newEntry);\n                        });\n                    }\n                }\n            }\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = finalTime;\n            if (doTick) {\n                doTick(this._currentTickTime - lastCurrentTime);\n            }\n        }\n        flushOnlyPendingTimers(doTick) {\n            if (this._schedulerQueue.length === 0) {\n                return 0;\n            }\n            // Find the last task currently queued in the scheduler queue and tick\n            // till that time.\n            const startTime = this._currentTickTime;\n            const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n            this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n            return this._currentTickTime - startTime;\n        }\n        flush(limit = 20, flushPeriodic = false, doTick) {\n            if (flushPeriodic) {\n                return this.flushPeriodic(doTick);\n            }\n            else {\n                return this.flushNonPeriodic(limit, doTick);\n            }\n        }\n        flushPeriodic(doTick) {\n            if (this._schedulerQueue.length === 0) {\n                return 0;\n            }\n            // Find the last task currently queued in the scheduler queue and tick\n            // till that time.\n            const startTime = this._currentTickTime;\n            const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n            this.tick(lastTask.endTime - startTime, doTick);\n            return this._currentTickTime - startTime;\n        }\n        flushNonPeriodic(limit, doTick) {\n            const startTime = this._currentTickTime;\n            let lastCurrentTime = 0;\n            let count = 0;\n            while (this._schedulerQueue.length > 0) {\n                count++;\n                if (count > limit) {\n                    throw new Error('flush failed after reaching the limit of ' + limit +\n                        ' tasks. Does your code use a polling timeout?');\n                }\n                // flush only non-periodic timers.\n                // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                if (this._schedulerQueue.filter(task => !task.isPeriodic && !task.isRequestAnimationFrame)\n                    .length === 0) {\n                    break;\n                }\n                const current = this._schedulerQueue.shift();\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = current.endTime;\n                if (doTick) {\n                    // Update any secondary schedulers like Jasmine mock Date.\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n                const retval = current.func.apply(global, current.args);\n                if (!retval) {\n                    // Uncaught exception in the current scheduled function. Stop processing the queue.\n                    break;\n                }\n            }\n            return this._currentTickTime - startTime;\n        }\n    }\n    // Next scheduler id.\n    Scheduler.nextId = 1;\n    class FakeAsyncTestZoneSpec {\n        constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {\n            this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n            this.macroTaskOptions = macroTaskOptions;\n            this._scheduler = new Scheduler();\n            this._microtasks = [];\n            this._lastError = null;\n            this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n            this.pendingPeriodicTimers = [];\n            this.pendingTimers = [];\n            this.patchDateLocked = false;\n            this.properties = { 'FakeAsyncTestZoneSpec': this };\n            this.name = 'fakeAsyncTestZone for ' + namePrefix;\n            // in case user can't access the construction of FakeAsyncTestSpec\n            // user can also define macroTaskOptions by define a global variable.\n            if (!this.macroTaskOptions) {\n                this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n            }\n        }\n        static assertInZone() {\n            if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                throw new Error('The code should be running in the fakeAsync zone to call this function');\n            }\n        }\n        _fnAndFlush(fn, completers) {\n            return (...args) => {\n                fn.apply(global, args);\n                if (this._lastError === null) { // Success\n                    if (completers.onSuccess != null) {\n                        completers.onSuccess.apply(global);\n                    }\n                    // Flush microtasks only on success.\n                    this.flushMicrotasks();\n                }\n                else { // Failure\n                    if (completers.onError != null) {\n                        completers.onError.apply(global);\n                    }\n                }\n                // Return true if there were no errors, false otherwise.\n                return this._lastError === null;\n            };\n        }\n        static _removeTimer(timers, id) {\n            let index = timers.indexOf(id);\n            if (index > -1) {\n                timers.splice(index, 1);\n            }\n        }\n        _dequeueTimer(id) {\n            return () => {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n            };\n        }\n        _requeuePeriodicTimer(fn, interval, args, id) {\n            return () => {\n                // Requeue the timer callback if it's not been canceled.\n                if (this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                    this._scheduler.scheduleFunction(fn, interval, { args, isPeriodic: true, id, isRequeuePeriodic: true });\n                }\n            };\n        }\n        _dequeuePeriodicTimer(id) {\n            return () => {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n            };\n        }\n        _setTimeout(fn, delay, args, isTimer = true) {\n            let removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n            // Queue the callback and dequeue the timer on success and error.\n            let cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n            let id = this._scheduler.scheduleFunction(cb, delay, { args, isRequestAnimationFrame: !isTimer });\n            if (isTimer) {\n                this.pendingTimers.push(id);\n            }\n            return id;\n        }\n        _clearTimeout(id) {\n            FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n            this._scheduler.removeScheduledFunctionWithId(id);\n        }\n        _setInterval(fn, interval, args) {\n            let id = Scheduler.nextId;\n            let completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n            let cb = this._fnAndFlush(fn, completers);\n            // Use the callback created above to requeue on success.\n            completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n            // Queue the callback and dequeue the periodic timer only on error.\n            this._scheduler.scheduleFunction(cb, interval, { args, isPeriodic: true });\n            this.pendingPeriodicTimers.push(id);\n            return id;\n        }\n        _clearInterval(id) {\n            FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n            this._scheduler.removeScheduledFunctionWithId(id);\n        }\n        _resetLastErrorAndThrow() {\n            let error = this._lastError || this._uncaughtPromiseErrors[0];\n            this._uncaughtPromiseErrors.length = 0;\n            this._lastError = null;\n            throw error;\n        }\n        getCurrentTickTime() {\n            return this._scheduler.getCurrentTickTime();\n        }\n        getFakeSystemTime() {\n            return this._scheduler.getFakeSystemTime();\n        }\n        setFakeBaseSystemTime(realTime) {\n            this._scheduler.setFakeBaseSystemTime(realTime);\n        }\n        getRealSystemTime() {\n            return this._scheduler.getRealSystemTime();\n        }\n        static patchDate() {\n            if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                // we don't want to patch global Date\n                // because in some case, global Date\n                // is already being patched, we need to provide\n                // an option to let user still use their\n                // own version of Date.\n                return;\n            }\n            if (global['Date'] === FakeDate) {\n                // already patched\n                return;\n            }\n            global['Date'] = FakeDate;\n            FakeDate.prototype = OriginalDate.prototype;\n            // try check and reset timers\n            // because jasmine.clock().install() may\n            // have replaced the global timer\n            FakeAsyncTestZoneSpec.checkTimerPatch();\n        }\n        static resetDate() {\n            if (global['Date'] === FakeDate) {\n                global['Date'] = OriginalDate;\n            }\n        }\n        static checkTimerPatch() {\n            if (global.setTimeout !== timers.setTimeout) {\n                global.setTimeout = timers.setTimeout;\n                global.clearTimeout = timers.clearTimeout;\n            }\n            if (global.setInterval !== timers.setInterval) {\n                global.setInterval = timers.setInterval;\n                global.clearInterval = timers.clearInterval;\n            }\n        }\n        lockDatePatch() {\n            this.patchDateLocked = true;\n            FakeAsyncTestZoneSpec.patchDate();\n        }\n        unlockDatePatch() {\n            this.patchDateLocked = false;\n            FakeAsyncTestZoneSpec.resetDate();\n        }\n        tickToNext(steps = 1, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n            if (steps <= 0) {\n                return;\n            }\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            this._scheduler.tickToNext(steps, doTick, tickOptions);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n        }\n        tick(millis = 0, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            this._scheduler.tick(millis, doTick, tickOptions);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n        }\n        flushMicrotasks() {\n            FakeAsyncTestZoneSpec.assertInZone();\n            const flushErrors = () => {\n                if (this._lastError !== null || this._uncaughtPromiseErrors.length) {\n                    // If there is an error stop processing the microtask queue and rethrow the error.\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            while (this._microtasks.length > 0) {\n                let microtask = this._microtasks.shift();\n                microtask.func.apply(microtask.target, microtask.args);\n            }\n            flushErrors();\n        }\n        flush(limit, flushPeriodic, doTick) {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n            return elapsed;\n        }\n        flushOnlyPendingTimers(doTick) {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this.flushMicrotasks();\n            const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n            if (this._lastError !== null) {\n                this._resetLastErrorAndThrow();\n            }\n            return elapsed;\n        }\n        removeAllTimers() {\n            FakeAsyncTestZoneSpec.assertInZone();\n            this._scheduler.removeAll();\n            this.pendingPeriodicTimers = [];\n            this.pendingTimers = [];\n        }\n        getTimerCount() {\n            return this._scheduler.getTimerCount() + this._microtasks.length;\n        }\n        onScheduleTask(delegate, current, target, task) {\n            switch (task.type) {\n                case 'microTask':\n                    let args = task.data && task.data.args;\n                    // should pass additional arguments to callback if have any\n                    // currently we know process.nextTick will have such additional\n                    // arguments\n                    let additionalArgs;\n                    if (args) {\n                        let callbackIndex = task.data.cbIdx;\n                        if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                            additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                        }\n                    }\n                    this._microtasks.push({\n                        func: task.invoke,\n                        args: additionalArgs,\n                        target: task.data && task.data.target\n                    });\n                    break;\n                case 'macroTask':\n                    switch (task.source) {\n                        case 'setTimeout':\n                            task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                            break;\n                        case 'setImmediate':\n                            task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                            break;\n                        case 'setInterval':\n                            task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                            break;\n                        case 'XMLHttpRequest.send':\n                            throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                task.data['url']);\n                        case 'requestAnimationFrame':\n                        case 'webkitRequestAnimationFrame':\n                        case 'mozRequestAnimationFrame':\n                            // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                            // (60 frames per second)\n                            task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                            break;\n                        default:\n                            // user can define which macroTask they want to support by passing\n                            // macroTaskOptions\n                            const macroTaskOption = this.findMacroTaskOption(task);\n                            if (macroTaskOption) {\n                                const args = task.data && task.data['args'];\n                                const delay = args && args.length > 1 ? args[1] : 0;\n                                let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args;\n                                if (!!macroTaskOption.isPeriodic) {\n                                    // periodic macroTask, use setInterval to simulate\n                                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                    task.data.isPeriodic = true;\n                                }\n                                else {\n                                    // not periodic, use setTimeout to simulate\n                                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                }\n                                break;\n                            }\n                            throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                    }\n                    break;\n                case 'eventTask':\n                    task = delegate.scheduleTask(target, task);\n                    break;\n            }\n            return task;\n        }\n        onCancelTask(delegate, current, target, task) {\n            switch (task.source) {\n                case 'setTimeout':\n                case 'requestAnimationFrame':\n                case 'webkitRequestAnimationFrame':\n                case 'mozRequestAnimationFrame':\n                    return this._clearTimeout(task.data['handleId']);\n                case 'setInterval':\n                    return this._clearInterval(task.data['handleId']);\n                default:\n                    // user can define which macroTask they want to support by passing\n                    // macroTaskOptions\n                    const macroTaskOption = this.findMacroTaskOption(task);\n                    if (macroTaskOption) {\n                        const handleId = task.data['handleId'];\n                        return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                            this._clearTimeout(handleId);\n                    }\n                    return delegate.cancelTask(target, task);\n            }\n        }\n        onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {\n            try {\n                FakeAsyncTestZoneSpec.patchDate();\n                return delegate.invoke(target, callback, applyThis, applyArgs, source);\n            }\n            finally {\n                if (!this.patchDateLocked) {\n                    FakeAsyncTestZoneSpec.resetDate();\n                }\n            }\n        }\n        findMacroTaskOption(task) {\n            if (!this.macroTaskOptions) {\n                return null;\n            }\n            for (let i = 0; i < this.macroTaskOptions.length; i++) {\n                const macroTaskOption = this.macroTaskOptions[i];\n                if (macroTaskOption.source === task.source) {\n                    return macroTaskOption;\n                }\n            }\n            return null;\n        }\n        onHandleError(parentZoneDelegate, currentZone, targetZone, error) {\n            this._lastError = error;\n            return false; // Don't propagate error to parent zone.\n        }\n    }\n    // Export the class so that new instances can be created with proper\n    // constructor params.\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n})(typeof window === 'object' && window || typeof self === 'object' && self || global);\nZone.__load_patch('fakeasync', (global, Zone, api) => {\n    const FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n    function getProxyZoneSpec() {\n        return Zone && Zone['ProxyZoneSpec'];\n    }\n    let _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n    function resetFakeAsyncZone() {\n        if (_fakeAsyncTestZoneSpec) {\n            _fakeAsyncTestZoneSpec.unlockDatePatch();\n        }\n        _fakeAsyncTestZoneSpec = null;\n        // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n        getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n    function fakeAsync(fn) {\n        // Not using an arrow function to preserve context passed from call site\n        const fakeAsyncFn = function (...args) {\n            const ProxyZoneSpec = getProxyZoneSpec();\n            if (!ProxyZoneSpec) {\n                throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                    'Please make sure that your environment includes zone.js/dist/proxy.js');\n            }\n            const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n            if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                throw new Error('fakeAsync() calls can not be nested');\n            }\n            try {\n                // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                if (!_fakeAsyncTestZoneSpec) {\n                    if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                        throw new Error('fakeAsync() calls can not be nested');\n                    }\n                    _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                }\n                let res;\n                const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                _fakeAsyncTestZoneSpec.lockDatePatch();\n                try {\n                    res = fn.apply(this, args);\n                    flushMicrotasks();\n                }\n                finally {\n                    proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                }\n                if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                    throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n                        `periodic timer(s) still in the queue.`);\n                }\n                if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                    throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n                }\n                return res;\n            }\n            finally {\n                resetFakeAsyncZone();\n            }\n        };\n        fakeAsyncFn.isFakeAsync = true;\n        return fakeAsyncFn;\n    }\n    function _getFakeAsyncZoneSpec() {\n        if (_fakeAsyncTestZoneSpec == null) {\n            _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (_fakeAsyncTestZoneSpec == null) {\n                throw new Error('The code should be running in the fakeAsync zone to call this function');\n            }\n        }\n        return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n    function tick(millis = 0, ignoreNestedTimeout = false) {\n        _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n    function flush(maxTurns) {\n        return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n    function discardPeriodicTasks() {\n        const zoneSpec = _getFakeAsyncZoneSpec();\n        const pendingTimers = zoneSpec.pendingPeriodicTimers;\n        zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n    function flushMicrotasks() {\n        _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n    Zone[api.symbol('fakeAsyncTest')] =\n        { resetFakeAsyncZone, flushMicrotasks, discardPeriodicTasks, tick, flush, fakeAsync };\n}, true);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Promise for async/fakeAsync zoneSpec test\n * can support async operation which not supported by zone.js\n * such as\n * it ('test jsonp in AsyncZone', async() => {\n *   new Promise(res => {\n *     jsonp(url, (data) => {\n *       // success callback\n *       res(data);\n *     });\n *   }).then((jsonpResult) => {\n *     // get jsonp result.\n *\n *     // user will expect AsyncZoneSpec wait for\n *     // then, but because jsonp is not zone aware\n *     // AsyncZone will finish before then is called.\n *   });\n * });\n */\nZone.__load_patch('promisefortest', (global, Zone, api) => {\n    const symbolState = api.symbol('state');\n    const UNRESOLVED = null;\n    const symbolParentUnresolved = api.symbol('parentUnresolved');\n    // patch Promise.prototype.then to keep an internal\n    // number for tracking unresolved chained promise\n    // we will decrease this number when the parent promise\n    // being resolved/rejected and chained promise was\n    // scheduled as a microTask.\n    // so we can know such kind of chained promise still\n    // not resolved in AsyncTestZone\n    Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {\n        let oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n        if (oriThen) {\n            return;\n        }\n        oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;\n        Promise.prototype.then = function () {\n            const chained = oriThen.apply(this, arguments);\n            if (this[symbolState] === UNRESOLVED) {\n                // parent promise is unresolved.\n                const asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');\n                if (asyncTestZoneSpec) {\n                    asyncTestZoneSpec.unresolvedChainedPromiseCount++;\n                    chained[symbolParentUnresolved] = true;\n                }\n            }\n            return chained;\n        };\n    };\n    Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {\n        // restore origin then\n        const oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];\n        if (oriThen) {\n            Promise.prototype.then = oriThen;\n            Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;\n        }\n    };\n});\n"]},"metadata":{},"sourceType":"script"}